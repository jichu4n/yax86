#include "gtest/gtest.h"
#include "fdc.h"

namespace {

enum DmaMode {
  kDmaModeRead,
  kDmaModeWrite,
};

class FDCTest : public ::testing::Test {
 protected:
  void SetUp() override {
    config_.context = this;
    config_.raise_irq6 = [](void* context) {
      static_cast<FDCTest*>(context)->irq6_raised_ = true;
    };
    config_.read_image_byte = [](void* context, uint8_t drive, uint32_t offset) -> uint8_t {
      // Return a pattern based on offset.
      return (uint8_t)(offset & 0xFF);
    };
    config_.write_image_byte = [](void* context, uint8_t drive, uint32_t offset, uint8_t value) {
      FDCTest* test = static_cast<FDCTest*>(context);
      test->last_written_byte_ = value;
      test->last_written_offset_ = offset;
    };
    config_.request_dma = [](void* context) {
      FDCTest* test = static_cast<FDCTest*>(context);
      test->dma_requested_ = true;
      if (test->dma_mode_ == kDmaModeRead) {
        test->last_dma_byte_ = FDCReadPort(&test->fdc_, kFDCPortData);
      }
    };

    FDCInit(&fdc_, &config_);
    // Enable interrupts and release reset by default for tests.
    // This simulates the state after a proper BIOS initialization.
    FDCWritePort(&fdc_, kFDCPortDOR, kFDCDORReset | kFDCDORInterruptEnable);

    // Consume the 4 interrupts generated by the reset.
    for (int i = 0; i < 4; ++i) {
      SendCommand(0x08);
      FDCTick(&fdc_);
      ReadResult(); // ST0
      ReadResult(); // PCN
    }
    // Clear the IRQ flag so tests start fresh.
    irq6_raised_ = false;
    dma_requested_ = false;
    dma_mode_ = kDmaModeRead;
  }

  void SendCommand(uint8_t cmd) {
    FDCWritePort(&fdc_, kFDCPortData, cmd);
  }

  void SendParameter(uint8_t param) {
    FDCWritePort(&fdc_, kFDCPortData, param);
  }

  void WriteDmaByte(uint8_t value) {
    FDCWritePort(&fdc_, kFDCPortData, value);
  }

  uint8_t ReadResult() {
    return FDCReadPort(&fdc_, kFDCPortData);
  }

  FDCConfig config_;
  FDCState fdc_;
  bool irq6_raised_ = false;
  bool dma_requested_ = false;
  DmaMode dma_mode_ = kDmaModeRead;
  uint8_t last_dma_byte_ = 0;
  uint8_t last_written_byte_ = 0;
  uint32_t last_written_offset_ = 0;
};

TEST_F(FDCTest, ReadData) {
  // Insert a disk into Drive 0.
  FDCInsertDisk(&fdc_, 0, &kFDCFormat360KB);

  // Issue Read Data command (0x06).
  // Parameters: Head/Drive, C, H, R, N, EOT, GPL, DTL.
  irq6_raised_ = false;
  dma_requested_ = false;
  dma_mode_ = kDmaModeRead;

  SendCommand(0x06); // Read Data
  SendParameter(0x00); // Drive 0, Head 0
  SendParameter(0x00); // C=0
  SendParameter(0x00); // H=0
  SendParameter(0x01); // R=1 (Sector 1)
  SendParameter(0x02); // N=2 (512 bytes)
  SendParameter(0x09); // EOT=9
  SendParameter(0x2A); // GPL
  SendParameter(0xFF); // DTL

  // Tick 1: Initialization.
  FDCTick(&fdc_);
  EXPECT_FALSE(dma_requested_);
  EXPECT_EQ(fdc_.phase, kFDCPhaseExecution);

  // Tick 2: Read first byte.
  FDCTick(&fdc_);
  EXPECT_TRUE(dma_requested_);
  // Offset 0 should be 0x00.
  EXPECT_EQ(last_dma_byte_, 0x00);

  // Simulate reading 511 more bytes.
  for (int i = 1; i < 512; ++i) {
    dma_requested_ = false;
    FDCTick(&fdc_);
    EXPECT_TRUE(dma_requested_);
    EXPECT_EQ(last_dma_byte_, (uint8_t)(i & 0xFF));
  }

  // Simulate Terminal Count from DMA controller.
  FDCHandleTC(&fdc_);

  // Tick: Terminate command.
  irq6_raised_ = false;
  FDCTick(&fdc_);

  // Verify IRQ6 and Result Phase.
  EXPECT_TRUE(irq6_raised_);
  EXPECT_EQ(fdc_.phase, kFDCPhaseResult);

  // Read Result Bytes (ST0, ST1, ST2, C, H, R, N).
  uint8_t st0 = ReadResult();
  uint8_t st1 = ReadResult();
  uint8_t st2 = ReadResult();
  uint8_t c = ReadResult();
  uint8_t h = ReadResult();
  uint8_t r = ReadResult();
  uint8_t n = ReadResult();

  // ST0: Normal Termination (Bits 7-6 = 00).
  EXPECT_EQ(st0 & 0xC0, 0x00);
  // Sector should be 1 (current sector was read, maybe incremented? 
  // Code increments sector AFTER byte index reaches size).
  // Wait, if TC happened at end of sector, sector might be 2.
  // But here we manually sent TC after 512 bytes.
  // The code increments R after the sector loop.
  // If we stopped exactly at 512, R might be 1 or 2 depending on check order.
  // Let's just check valid read for now.
  (void)c; (void)h; (void)r; (void)n;
  
  // FDC should be Idle now.
  EXPECT_EQ(fdc_.phase, kFDCPhaseIdle);
}

TEST_F(FDCTest, WriteData) {
  // Insert a disk into Drive 0.
  FDCInsertDisk(&fdc_, 0, &kFDCFormat360KB);

  irq6_raised_ = false;
  dma_requested_ = false;
  dma_mode_ = kDmaModeWrite;

  // Issue Write Data command (0x05).
  SendCommand(0x05); 
  SendParameter(0x00); // Drive 0
  SendParameter(0x00); 
  SendParameter(0x00); 
  SendParameter(0x01); // Sector 1
  SendParameter(0x02); 
  SendParameter(0x09); 
  SendParameter(0x2A); 
  SendParameter(0xFF); 

  // Tick 1: Initialization. 
  // NOTE: Write Data requests first byte immediately in Init block.
  FDCTick(&fdc_);
  EXPECT_TRUE(dma_requested_);
  EXPECT_EQ(fdc_.phase, kFDCPhaseExecution);

  // Provide first byte (0xAA).
  dma_requested_ = false;
  WriteDmaByte(0xAA);

  // Tick 2: Process byte 0xAA, request next.
  FDCTick(&fdc_);
  EXPECT_EQ(last_written_byte_, 0xAA);
  EXPECT_EQ(last_written_offset_, 0);
  EXPECT_TRUE(dma_requested_);

  // Provide second byte (0xBB).
  dma_requested_ = false;
  WriteDmaByte(0xBB);

  // Tick 3: Process byte 0xBB.
  FDCTick(&fdc_);
  EXPECT_EQ(last_written_byte_, 0xBB);
  EXPECT_EQ(last_written_offset_, 1);
  EXPECT_TRUE(dma_requested_);

  // Simulate TC.
  FDCHandleTC(&fdc_);

  // Tick: Terminate.
  FDCTick(&fdc_);
  EXPECT_TRUE(irq6_raised_);
  EXPECT_EQ(fdc_.phase, kFDCPhaseResult);
}

TEST_F(FDCTest, ReadTrackEnd) {
  // Insert a disk into Drive 0.
  FDCInsertDisk(&fdc_, 0, &kFDCFormat360KB);

  // Issue Read Data command for Sector 9 (End of Track).
  irq6_raised_ = false;
  dma_requested_ = false;
  dma_mode_ = kDmaModeRead;
  SendCommand(0x06); 
  SendParameter(0x00); 
  SendParameter(0x00); 
  SendParameter(0x00); 
  SendParameter(0x09); // R=9 (Last Sector)
  SendParameter(0x02); // N=2
  SendParameter(0x09); // EOT=9
  SendParameter(0x2A); 
  SendParameter(0xFF); 

  // Tick 1: Init.
  FDCTick(&fdc_);

  // Read 512 bytes (1 sector).
  for (int i = 0; i < 512; ++i) {
    FDCTick(&fdc_); // Read byte, Request DMA
    // Handle DMA read immediately (simulated by test callback setting dma_requested)
    dma_requested_ = false; 
  }

  // At this point, we finished the last byte of Sector 9.
  // The handler should have incremented sector to 10 and set tc_received (EOT).
  
  // Tick: Terminate command (detects tc_received).
  FDCTick(&fdc_);

  // Verify IRQ6.
  EXPECT_TRUE(irq6_raised_);

  // Check Result Sector (R).
  ReadResult(); // ST0
  ReadResult(); // ST1
  ReadResult(); // ST2
  ReadResult(); // C
  ReadResult(); // H
  uint8_t r = ReadResult(); // R
  ReadResult(); // N

  // Expect R = 10 (9 + 1).
  EXPECT_EQ(r, 10);
}

TEST_F(FDCTest, ReadDataMultiTrack) {
  // Insert a disk into Drive 0.
  FDCInsertDisk(&fdc_, 0, &kFDCFormat360KB);

  // Issue Read Data command (0x06) with MT bit set.
  irq6_raised_ = false;
  dma_requested_ = false;
  dma_mode_ = kDmaModeRead;
  // Command 0x86: MT=1, MFM=0, SK=0, CMD=06
  SendCommand(0x86); 
  SendParameter(0x00); // Drive 0, Head 0
  SendParameter(0x00); // C=0
  SendParameter(0x00); // H=0
  SendParameter(0x09); // R=9 (Last Sector of Side 0)
  SendParameter(0x02); // N=2 (512 bytes)
  SendParameter(0x09); // EOT=9
  SendParameter(0x2A); 
  SendParameter(0xFF); 

  // Tick 1: Init.
  FDCTick(&fdc_);

  // Read 512 bytes (Sector 9, Head 0).
  for (int i = 0; i < 512; ++i) {
    FDCTick(&fdc_); 
    dma_requested_ = false;
  }

  // At this point, we finished Head 0, Sector 9.
  // With MT=1, it should rollover to Head 1, Sector 1.
  // dma_requested_ should be true again for the next byte (from Head 1).
  
  // Read 512 bytes (Sector 1, Head 1).
  for (int i = 0; i < 512; ++i) {
    FDCTick(&fdc_); 
    EXPECT_TRUE(dma_requested_);
    dma_requested_ = false;
  }

  // Simulate Terminal Count (TC) at end of 2nd sector read.
  FDCHandleTC(&fdc_);

  // Tick: Terminate command.
  FDCTick(&fdc_);

  // Verify IRQ6.
  EXPECT_TRUE(irq6_raised_);

  // Check Result Phase.
  ReadResult(); // ST0
  ReadResult(); // ST1
  ReadResult(); // ST2
  ReadResult(); // C
  uint8_t h = ReadResult(); // H
  uint8_t r = ReadResult(); // R
  ReadResult(); // N

  // Expect Head = 1 (Rolled over).
  EXPECT_EQ(h, 1);
  // Expect Sector = 2 (Read Sector 1, incremented to 2).
  EXPECT_EQ(r, 2);
}

TEST_F(FDCTest, RecalibrateAndSenseInterruptStatus) {
  // 1. Issue Recalibrate command for Drive 0.
  irq6_raised_ = false;
  SendCommand(0x07); // Recalibrate
  SendParameter(0x00); // Drive 0

  // Tick the FDC to process the command. Recalibrate needs at least 2 ticks
  // (start seek, finish seek).
  FDCTick(&fdc_);
  FDCTick(&fdc_);

  // Verify IRQ6 was raised.
  EXPECT_TRUE(irq6_raised_);
  EXPECT_EQ(fdc_.phase, kFDCPhaseIdle);

  // 2. Issue Sense Interrupt Status command.
  SendCommand(0x08); // Sense Interrupt Status

  // Tick to execute Sense Interrupt Status.
  FDCTick(&fdc_);

  // No execution phase for Sense Interrupt Status, goes straight to Result.
  // Actually, wait, Sense Interrupt Status handler finishes execution immediately.
  // But FDCFinishCommandExecution transitions to kFDCPhaseResult if there are bytes.
  
  // Actually, Sense Interrupt Status result bytes are available immediately.
  // Read ST0.
  uint8_t st0 = ReadResult();
  // Bits 7-6: 00 (Normal Termination)
  // Bit 5: 1 (Seek End)
  // Bits 1-0: 00 (Drive 0)
  // Expected: 00100000 = 0x20
  EXPECT_EQ(st0, 0x20);

  // Read PCN (Present Cylinder Number).
  uint8_t pcn = ReadResult();
  EXPECT_EQ(pcn, 0x00); // Should be 0 after recalibrate.

  // Verify we are back to Idle.
  EXPECT_EQ(fdc_.phase, kFDCPhaseIdle);
}

TEST_F(FDCTest, SenseInterruptStatusNoPending) {
  // Issue Sense Interrupt Status command without any prior Seek/Recalibrate.
  SendCommand(0x08); // Sense Interrupt Status

  // Tick to execute.
  FDCTick(&fdc_);

  // Read ST0.
  uint8_t st0 = ReadResult();
  // Should be Invalid Command (0x80).
  EXPECT_EQ(st0, 0x80);

  // Verify we are back to Idle.
  EXPECT_EQ(fdc_.phase, kFDCPhaseIdle);
}

TEST_F(FDCTest, DORResetAndInterrupt) {
  irq6_raised_ = false;

  // 1. Enter Reset (Bit 2 = 0).
  // Write DOR with Reset=0, InterruptEnable=0.
  FDCWritePort(&fdc_, kFDCPortDOR, 0x00);
  EXPECT_FALSE(irq6_raised_);

  // 2. Exit Reset (Bit 2 = 1) and Enable Interrupts (Bit 3 = 1).
  // Write DOR with Reset=1, InterruptEnable=1.
  FDCWritePort(&fdc_, kFDCPortDOR, kFDCDORReset | kFDCDORInterruptEnable);
  
  // Interrupt should be raised immediately upon exiting reset.
  EXPECT_TRUE(irq6_raised_);

  // 3. Verify status for all drives using Sense Interrupt Status.
  // After a reset, FDC sets "Abnormal Termination due to Polling" for all drives.
  for (int i = 0; i < 4; ++i) {
    SendCommand(0x08); // Sense Interrupt Status
    FDCTick(&fdc_); // Execute command

    uint8_t st0 = ReadResult();
    uint8_t pcn = ReadResult();

    // ST0 should be 0xC0 (Abnormal Polling) | Drive Index.
    // 0xC0 = 11000000
    uint8_t expected_st0 = 0xC0 | i;
    EXPECT_EQ(st0, expected_st0);
    // PCN is usually 0 after reset.
    EXPECT_EQ(pcn, 0);
  }

  // 4. Next Sense Interrupt Status should return Invalid Command.
  SendCommand(0x08);
  FDCTick(&fdc_);
  uint8_t st0 = ReadResult();
  EXPECT_EQ(st0, 0x80); // Invalid Command
}

TEST_F(FDCTest, SeekAndSenseInterruptStatus) {
  // 1. Issue Seek command for Drive 1 to Cylinder 10.
  irq6_raised_ = false;
  SendCommand(0x0F); // Seek
  SendParameter(0x01); // Drive 1
  SendParameter(0x0A); // NCN = 10

  // Tick the FDC to process the command (start seek, finish seek).
  FDCTick(&fdc_);
  FDCTick(&fdc_);

  // Verify IRQ6 was raised.
  EXPECT_TRUE(irq6_raised_);
  EXPECT_EQ(fdc_.phase, kFDCPhaseIdle);

  // 2. Issue Sense Interrupt Status command.
  SendCommand(0x08); // Sense Interrupt Status
  FDCTick(&fdc_);

  uint8_t st0 = ReadResult();
  // Bits 7-6: 00 (Normal Termination)
  // Bit 5: 1 (Seek End)
  // Bits 1-0: 01 (Drive 1)
  // Expected: 00100001 = 0x21
  EXPECT_EQ(st0, 0x21);

  // Read PCN (Present Cylinder Number).
  uint8_t pcn = ReadResult();
  EXPECT_EQ(pcn, 0x0A); // Should be 10.

  // Verify we are back to Idle.
  EXPECT_EQ(fdc_.phase, kFDCPhaseIdle);
}

TEST_F(FDCTest, SpecifyCommand) {
  // Issue Specify command (0x03).
  SendCommand(0x03);
  // Send Parameter 1 (SRT/HUT).
  SendParameter(0xDF); 
  // Send Parameter 2 (HLT/ND).
  SendParameter(0x03);

  // Tick to execute.
  FDCTick(&fdc_);

  // Verify FDC returned to Idle.
  EXPECT_EQ(fdc_.phase, kFDCPhaseIdle);
  
  // Verify no interrupt was raised.
  EXPECT_FALSE(irq6_raised_);
}

} // namespace
