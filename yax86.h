// 8086 CPU emulator.
#ifndef YAX86_H
#define YAX86_H

#include <stdbool.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// ============================================================================
// CPU state
// ============================================================================

// CPU registers.
// Note that the order / numeric values of these constants are important here as
// they must match how the registers are encoded in the ModR/M byte.
typedef enum {
  // General-purpose and index registers.

  // Accumulator Register
  kAX = 0,
  // Counter Register
  kCX = 1,
  // Data Register
  kDX = 2,
  // Base Register
  kBX = 3,
  // Stack Pointer Register
  kSP = 4,
  // Base Pointer Register
  kBP = 5,
  // Source Index Register
  kSI = 6,
  // Destination Index Register
  kDI = 7,

  // Segment registers.

  // Extra Segment Register
  kES = 8,
  // Code Segment Register
  kCS = 9,
  // Stack Segment Register
  kSS = 10,
  // Data Segment Register
  kDS = 11,

  // Instruction Pointer Register
  kIP,
} RegisterIndex;

#define kNumRegisters (kIP + 1)

// CPU flag masks.
typedef enum {
  // Carry Flag
  kCF = (1 << 0),
  // Parity Flag
  kPF = (1 << 2),
  // Auxiliary Carry Flag
  kAF = (1 << 4),
  // Zero Flag
  kZF = (1 << 6),
  // Sign Flag
  kSF = (1 << 7),
  // Trap Flag
  kTF = (1 << 8),
  // Interrupt Enable Flag
  kIF = (1 << 9),
  // Direction Flag
  kDF = (1 << 10),
  // Overflow Flag
  kOF = (1 << 11),
} CPUFlags;

// CPU flags value on reset.
#define kInitialCPUFlags (1 << 1)  // Reserved_1 is always 1.

// Standard interrupts.
typedef enum {
  kInterruptDivideByZero = 0,
  kInterruptSingleStep = 1,
  kInterruptNMI = 2,
  kInterruptBreakpoint = 3,
  kInterruptOverflow = 4,

  // Not actually used in real 8086, but thrown by this emulator when an
  // instruction's prefix exceeds MAX_NUM_PREFIX_BYTES.
  kInterruptInvalidOpcode = 6,
} Interrupt;

// Runtime configuration
typedef struct {
  // Callback context.
  void* context;
  // Required - hooks to read and write memory.
  uint8_t (*read_memory_byte)(void* context, uint16_t address);
  void (*write_memory_byte)(void* context, uint16_t address, uint8_t value);
  // Required - handle interrupts.
  void (*handle_interrupt)(void* context, uint8_t interrupt_number);
} CPUConfig;

// CPU state
typedef struct {
  // Pointer to the configuration
  CPUConfig* config;

  // Register values
  uint16_t registers[kNumRegisters];
  // Flag values
  uint16_t flags;
} CPUState;

// Initialize CPU state.
void InitCPU(CPUState* cpu);

// ============================================================================
// Instructions
// ============================================================================

// Maximum number of prefix bytes supported. On the 8086 and 80186, the length
// of prefix bytes was actually unlimited. But well-formed code generated by
// compilers would only have 1 or 2 bytes.
#define kMaxPrefixBytes 2
// Maximum number of displacement bytes in an 8086 instruction.
#define kMaxDisplacementBytes 2
// Maximum number of immediate data bytes in an 8086 instruction.
#define kMaxImmediateBytes 4

// The Mod R/M byte.
typedef struct {
  // Mod field - bits 6 and 7
  uint8_t mod : 2;
  // REG field - bits 3 to 5
  uint8_t reg : 3;
  // R/M field - bits 0 to 2
  uint8_t rm : 3;
} ModRM;

// An encoded instruction.
typedef struct {
  // Prefix bytes.
  uint8_t prefix[kMaxPrefixBytes];

  // The primary opcode byte.
  uint8_t opcode;

  // The ModR/M byte, which specifies addressing modes. For some instructions,
  // the REG field within this byte acts as an opcode extension.
  ModRM mod_rm;

  // Raw displacement bytes. If displacement_size is 1, only disp_bytes[0] is
  // valid (value is typically sign-extended). If displacement_size is 2,
  // disp_bytes[0] is the low byte, disp_bytes[1] is the high byte.
  uint8_t displacement[kMaxDisplacementBytes];

  // Raw immediate data bytes.
  uint8_t immediate[kMaxImmediateBytes];

  // Flags

  // Whether prefix byte is part of this instruction.
  uint8_t prefix_size : 2;
  // Flag indicating if a ModR/M byte is part of this instruction.
  bool has_mod_rm : 1;
  // Number of displacement bytes present: 0, 1, or 2.
  uint8_t displacement_size : 2;
  // Number of immediate data bytes present: 0, 1, 2, or 4.
  uint8_t immediate_size : 3;

  // Total length of the original encoded instruction in bytes.
  uint8_t size;
} EncodedInstruction;

// ============================================================================
// Execution
// ============================================================================

// Result status from fetching the next instruction.
typedef enum {
  kFetchSuccess = 0,
  // Prefix exceeds maximum allowed size.
  kFetchPrefixTooLong = -1,
} FetchNextInstructionStatus;

// Fetch the next instruction from CS:IP.
FetchNextInstructionStatus FetchNextInstruction(
    CPUState* cpu, EncodedInstruction* instruction);

// Result status from executing an instruction.
typedef enum {
  kExecuteSuccess = 0,
  // Invalid instruction opcode.
  kExecuteInvalidOpcode = -2,
  // Instruction parameters are invalid.
  kExecuteInvalidInstruction = -1,
} ExecuteInstructionStatus;

// Execute a single instruction.
ExecuteInstructionStatus ExecuteInstruction(
    CPUState* cpu, const EncodedInstruction* instruction);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // YAX86_H
