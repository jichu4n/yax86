// 8086 CPU emulator.
#ifndef YAX86_H
#define YAX86_H

#include <stdbool.h>
#include <stdint.h>

typedef struct {
  // Accumulator Register
  uint16_t AX;
  // Base Register
  uint16_t BX;
  // Counter Register
  uint16_t CX;
  // Data Register
  uint16_t DX;
  // Code Segment Register
  uint16_t CS;
  // Data Segment Register
  uint16_t DS;
  // Stack Segment Register
  uint16_t SS;
  // Extra Segment Register
  uint16_t ES;
  // Stack Pointer Register
  uint16_t SP;
  // Base Pointer Register
  uint16_t BP;
  // Source Index Register
  uint16_t SI;
  // Destination Index Register
  uint16_t DI;
  // Instruction Pointer Register
  uint16_t IP;
} CPURegisters;
#define NUM_REGISTERS (IP + 1)

// CPU flags
typedef union {
  // 16-bit value representing all flags
  uint16_t value;
  // Individual flags
  struct {
    // Carry Flag
    uint16_t CF : 1;
    // Reserved, always 1
    uint16_t reserved_1 : 1;
    // Parity Flag
    uint16_t PF : 1;
    // Reserved, always 0
    uint16_t reserved_2 : 1;
    // Auxiliary Carry Flag
    uint16_t AF : 1;
    // Reserved, always 0
    uint16_t reserved_3 : 1;
    // Zero Flag
    uint16_t ZF : 1;
    // Sign Flag
    uint16_t SF : 1;

    // Trap Flag
    uint16_t TF : 1;
    // Interrupt Enable Flag
    uint16_t IF : 1;
    // Direction Flag
    uint16_t DF : 1;
    // Overflow Flag
    uint16_t OF : 1;

    // Reserved (bits 12â€“15 are unused in 8086)
    uint16_t reserved_4 : 4;
  } fields;
} CPUFlags;

// Standard interrupts.
typedef enum {
  kInterruptDivideByZero = 0,
  kInterruptSingleStep = 1,
  kInterruptNMI = 2,
  kInterruptBreakpoint = 3,
  kInterruptOverflow = 4,

  // Not actually used in real 8086, but thrown by this emulator when an
  // instruction's prefix exceeds MAX_NUM_PREFIX_BYTES.
  kInterruptInvalidOpcode = 6,
} CPUInterrupt;

// Data size for memory and register operations
typedef enum { kByte = 1, kWord = 2 } CPUDataWidth;

// Runtime configuration
typedef struct {
  // Required - hooks to read and write memory.
  uint8_t (*read_memory)(uint16_t address, CPUDataWidth width);
  void (*write_memory)(uint16_t address, CPUDataWidth width, uint8_t value);
  // Required - handle interrupts.
  void (*handle_interrupt)(uint8_t interrupt_number);
} CPUConfig;

// CPU state
typedef struct {
  // Pointer to the configuration
  CPUConfig* config;

  // Register values
  CPURegisters registers;
  // Flag values
  CPUFlags flags;
} CPUState;

// Maximum number of prefix bytes supported. On the 8086 and 80186, the length
// of prefix bytes was actually unlimited. But well-formed code generated by
// compilers would only have 1 or 2 bytes.
#define MAX_NUM_PREFIX_BYTES 2
// Maximum number of immediate data bytes in an 8086 instruction.
#define MAX_NUM_IMMEDIATE_BYTES 4

// The Mod R/M byte.
typedef union {
  // Raw byte value.
  uint8_t value;

  // The individual fields within the Mod R/M byte.
  struct {
    // Mod field - bits 6 and 7
    uint8_t mod : 2;
    // REG field - bits 3 to 5
    uint8_t reg : 3;
    // R/M field - bits 0 to 2
    uint8_t rm : 3;
  } fields;
} ModRM;

// An encoded instruction.
typedef struct {
  // Prefix bytes.
  uint8_t prefix[MAX_NUM_PREFIX_BYTES];

  // The primary opcode byte.
  uint8_t opcode;

  // The ModR/M byte, which specifies addressing modes. For some instructions,
  // the REG field within this byte acts as an opcode extension.
  ModRM mod_rm;

  // Raw displacement bytes. If displacement_size is 1, only disp_bytes[0] is
  // valid (value is typically sign-extended). If displacement_size is 2,
  // disp_bytes[0] is the low byte, disp_bytes[1] is the high byte.
  uint8_t displacement[2];

  // Raw immediate data bytes.
  uint8_t immediate[MAX_NUM_IMMEDIATE_BYTES];

  // Flags

  // Whether prefix byte is part of this instruction.
  uint8_t prefix_size : 2;
  // Flag indicating if a ModR/M byte is part of this instruction.
  bool has_mod_rm : 1;
  // Number of displacement bytes present: 0, 1, or 2.
  uint8_t displacement_size : 2;
  // Number of immediate data bytes present: 0, 1, 2, or 4.
  uint8_t immediate_size : 3;

  // Total length of the original encoded instruction in bytes.
  uint8_t size;
} EncodedInstruction;

// Opcode lookup table entry.
typedef struct {
  // Opcode.
  uint8_t opcode;

  // Instruction has ModR/M byte
  bool has_modrm : 1;
  // Number of immediate data bytes: 0, 1, 2, or 4
  uint8_t immediate_size : 3;
} OpcodeMetadata;

// Function to initialize the CPU state
void InitCPU(CPUState* cpu);

// Function prototypes
EncodedInstruction FetchNextInstruction(CPUState* cpu);

// Lookup function to get opcode metadata for a given opcode
const OpcodeMetadata* GetOpcodeMetadata(uint8_t opcode);

#endif  // YAX86_H
