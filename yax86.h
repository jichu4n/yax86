// 8086 CPU emulator.
#ifndef YAX86_H
#define YAX86_H

#include <stdbool.h>
#include <stdint.h>

// ============================================================================
// CPU state and interface
// ============================================================================

// CPU registers.
// Note that the order / numeric values of these constants are important here as
// they must match how the registers are encoded in the ModR/M byte.
typedef enum {
  // General-purpose and index registers.

  // Accumulator Register
  kAX = 0,
  // Counter Register
  kCX,
  // Data Register
  kDX,
  // Base Register
  kBX,
  // Stack Pointer Register
  kSP,
  // Base Pointer Register
  kBP,
  // Source Index Register
  kSI,
  // Destination Index Register
  kDI,

  // Segment registers.

  // Extra Segment Register
  kES,
  // Code Segment Register
  kCS,
  // Stack Segment Register
  kSS,
  // Data Segment Register
  kDS,

  // Instruction Pointer Register
  kIP,
} Register;

#define kNumRegisters (kIP + 1)

// CPU flags
typedef union {
  // 16-bit value representing all flags
  uint16_t value;
  // Individual flags
  struct {
    // Carry Flag
    uint16_t CF : 1;
    // Reserved, always 1
    uint16_t reserved_1 : 1;
    // Parity Flag
    uint16_t PF : 1;
    // Reserved, always 0
    uint16_t reserved_2 : 1;
    // Auxiliary Carry Flag
    uint16_t AF : 1;
    // Reserved, always 0
    uint16_t reserved_3 : 1;
    // Zero Flag
    uint16_t ZF : 1;
    // Sign Flag
    uint16_t SF : 1;

    // Trap Flag
    uint16_t TF : 1;
    // Interrupt Enable Flag
    uint16_t IF : 1;
    // Direction Flag
    uint16_t DF : 1;
    // Overflow Flag
    uint16_t OF : 1;

    // Reserved (bits 12â€“15 are unused in 8086)
    uint16_t reserved_4 : 4;
  } fields;
} Flags;
// Compile-time assertion that the compiler is packing Flags::fields correctly.
typedef char
    _assert_sizeof_Flags_is_2[sizeof(((Flags*)0)->fields) == 2 ? 1 : -1];

// Standard interrupts.
typedef enum {
  kInterruptDivideByZero = 0,
  kInterruptSingleStep = 1,
  kInterruptNMI = 2,
  kInterruptBreakpoint = 3,
  kInterruptOverflow = 4,

  // Not actually used in real 8086, but thrown by this emulator when an
  // instruction's prefix exceeds MAX_NUM_PREFIX_BYTES.
  kInterruptInvalidOpcode = 6,
} Interrupt;

// Data size for memory and register operations
typedef enum { kByte = 1, kWord = 2 } CPUDataWidth;

// Runtime configuration
typedef struct {
  // Required - hooks to read and write memory.
  uint8_t (*read_memory)(uint16_t address, CPUDataWidth width);
  void (*write_memory)(uint16_t address, CPUDataWidth width, uint8_t value);
  // Required - handle interrupts.
  void (*handle_interrupt)(uint8_t interrupt_number);
} CPUConfig;

// CPU state
typedef struct {
  // Pointer to the configuration
  CPUConfig* config;

  // Register values
  uint16_t registers[kNumRegisters];
  // Flag values
  Flags flags;
} CPUState;

// Initialize CPU state.
void InitCPU(CPUState* cpu);

// ============================================================================
// Instructions
// ============================================================================

// Maximum number of prefix bytes supported. On the 8086 and 80186, the length
// of prefix bytes was actually unlimited. But well-formed code generated by
// compilers would only have 1 or 2 bytes.
#define kMaxPrefixBytes 2
// Maximum number of displacement bytes in an 8086 instruction.
#define kMaxDisplacementBytes 2
// Maximum number of immediate data bytes in an 8086 instruction.
#define kMaxImmediateBytes 4

// The Mod R/M byte.
typedef union {
  // Raw byte value.
  uint8_t value;

  // The individual fields within the Mod R/M byte.
  struct {
    // Mod field - bits 6 and 7
    uint8_t mod : 2;
    // REG field - bits 3 to 5
    uint8_t reg : 3;
    // R/M field - bits 0 to 2
    uint8_t rm : 3;
  } fields;
} ModRM;
// Compile-time assertion that the compiler is packing ModRM::fields correctly.
typedef char
    _assert_sizeof_ModRM_is_1[sizeof(((ModRM*)0)->fields) == 1 ? 1 : -1];

// An encoded instruction.
typedef struct {
  // Prefix bytes.
  uint8_t prefix[kMaxPrefixBytes];

  // The primary opcode byte.
  uint8_t opcode;

  // The ModR/M byte, which specifies addressing modes. For some instructions,
  // the REG field within this byte acts as an opcode extension.
  ModRM mod_rm;

  // Raw displacement bytes. If displacement_size is 1, only disp_bytes[0] is
  // valid (value is typically sign-extended). If displacement_size is 2,
  // disp_bytes[0] is the low byte, disp_bytes[1] is the high byte.
  uint8_t displacement[kMaxDisplacementBytes];

  // Raw immediate data bytes.
  uint8_t immediate[kMaxImmediateBytes];

  // Flags

  // Whether prefix byte is part of this instruction.
  uint8_t prefix_size : 2;
  // Flag indicating if a ModR/M byte is part of this instruction.
  bool has_mod_rm : 1;
  // Number of displacement bytes present: 0, 1, or 2.
  uint8_t displacement_size : 2;
  // Number of immediate data bytes present: 0, 1, 2, or 4.
  uint8_t immediate_size : 3;

  // Total length of the original encoded instruction in bytes.
  uint8_t size;
} EncodedInstruction;

// Fetch the next instruction from memory.
EncodedInstruction FetchNextInstruction(CPUState* cpu);

#endif  // YAX86_H
