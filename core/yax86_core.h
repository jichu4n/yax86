// ==============================================================================
// YAX86 BIOS MODULE - GENERATED SINGLE HEADER BUNDLE
// ==============================================================================

#ifndef YAX86_BIOS_BUNDLE_H
#define YAX86_BIOS_BUNDLE_H

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// ==============================================================================
// src/bios/public.h start
// ==============================================================================

#line 1 "./src/bios/public.h"
// Public interface for the BIOS module.
#ifndef YAX86_BIOS_PUBLIC_H
#define YAX86_BIOS_PUBLIC_H

#include <stdbool.h>
#include <stdint.h>

// Memory region types.
enum {
  // BIOS ROM memory map entry type - mapped to 0xF0000 to up to 0xFFFFF (64KB).
  kMemoryMapEntryBIOSROM = 0x01,
  // Start address of the BIOS ROM.
  kBIOSROMStartAddress = 0xFE000,
};

// Get size of BIOS ROM data.
uint32_t BIOSGetROMSize(void);

// Read a byte from the BIOS ROM.
uint8_t BIOSReadROMByte(uint32_t offset);

#endif  // YAX86_BIOS_PUBLIC_H


// ==============================================================================
// src/bios/public.h end
// ==============================================================================


#ifdef YAX86_IMPLEMENTATION

// ==============================================================================
// src/bios/bios_rom_data.h start
// ==============================================================================

#line 1 "./src/bios/bios_rom_data.h"
// BIOS ROM data automatically generated by generate-bios-rom-data-files.js
// Source: GLABIOS_0.2.5_8E.rom

#ifndef YAX86_BIOS_ROM_DATA_H
#define YAX86_BIOS_ROM_DATA_H

#include <stdint.h>

enum {
  kBIOSROMDataSize = 8192,
};

#ifndef YAX86_BIOS_BUNDLE
extern const uint8_t kBIOSROMData[kBIOSROMDataSize];
#endif // YAX86_BIOS_BUNDLE

#endif // YAX86_BIOS_ROM_DATA_H


// ==============================================================================
// src/bios/bios_rom_data.h end
// ==============================================================================

// ==============================================================================
// src/bios/bios_rom_data.c start
// ==============================================================================

#line 1 "./src/bios/bios_rom_data.c"
// BIOS ROM data automatically generated by generate-bios-rom-data-files.js
// Source: GLABIOS_0.2.5_8E.rom

#include <stdint.h>

const uint8_t kBIOSROMData[] = {
0x0a,0x47,0x4c,0x61,0x42,0x49,0x4f,0x53,0x20,0x5b,0x03,0x5d,0x20,0x00,0x54,0x68,
0x65,0x20,0x68,0x65,0x72,0x6f,0x20,0x77,0x65,0x20,0x6e,0x65,0x65,0x64,0x20,0x62,
0x75,0x74,0x20,0x64,0x6f,0x6e,0x27,0x74,0x20,0x64,0x65,0x73,0x65,0x72,0x76,0x65,
0x00,0x0d,0x0a,0x28,0x43,0x29,0x20,0x32,0x30,0x32,0x32,0x2d,0x32,0x33,0x20,0x36,
0x34,0x30,0x4b,0x42,0x20,0x52,0x65,0x6c,0x65,0x61,0x73,0x65,0x64,0x20,0x75,0x6e,
0x64,0x65,0x72,0x20,0x47,0x50,0x4c,0x76,0x33,0x0a,0x00,0xfa,0xfc,0xb8,0xa5,0x95,
0x8b,0xd8,0x8e,0xdb,0x8c,0xd9,0x8e,0xc1,0x8c,0xc6,0x8e,0xd6,0x8c,0xd7,0x8b,0xef,
0x8b,0xe5,0x8b,0xd4,0xf7,0xc2,0x5a,0x6a,0xb3,0x21,0x75,0x3a,0x33,0xc0,0x85,0xd2,
0x75,0xde,0xe6,0xa0,0xe6,0x83,0xba,0xd8,0x03,0xee,0x40,0xb2,0xb8,0xee,0x81,0x3e,
0x72,0x04,0x34,0x12,0x75,0x03,0xbd,0x00,0x80,0x48,0xe6,0x43,0xe4,0x40,0xd0,0xe8,
0x24,0x03,0x0b,0xe8,0x8c,0xca,0x8e,0xd2,0xb0,0x99,0xe6,0x63,0xb0,0xad,0xe6,0x61,
0xb0,0x04,0xe6,0x08,0xeb,0x02,0xeb,0x43,0xb0,0x54,0xe6,0x43,0xe6,0x0d,0xb0,0x00,
0xe6,0x08,0xb1,0x03,0xe6,0x0a,0xb0,0x41,0xe6,0x0b,0x40,0xe2,0xfb,0xe4,0x61,0x0c,
0x30,0xe6,0x61,0x91,0x8e,0xd8,0xbe,0x72,0x04,0x8b,0x14,0xbc,0xe1,0xe0,0xe9,0x4e,
0x05,0xe3,0xe0,0x75,0x14,0xe4,0x61,0x0c,0x10,0xe6,0x61,0x24,0xef,0xe6,0x61,0xbc,
0xf5,0xe0,0xe9,0x09,0x05,0xf7,0xe0,0x74,0x05,0xb3,0x13,0xe9,0x76,0x07,0xb8,0xa5,
0x95,0xbc,0x07,0xe1,0xe9,0x28,0x05,0x09,0xe1,0x75,0xee,0xbc,0x11,0xe1,0xe9,0x1e,
0x05,0x13,0xe1,0x75,0xe4,0x87,0x14,0x40,0xa2,0x40,0x04,0xe4,0x62,0x24,0x80,0x74,
0x04,0xb3,0x14,0xeb,0xd6,0xe4,0x61,0x0c,0x30,0xe6,0x61,0xb8,0x30,0x00,0x8e,0xd0,
0xbc,0x00,0x01,0xb2,0x20,0xb0,0x13,0xee,0x42,0xb0,0x08,0xee,0xb7,0x01,0xb0,0x09,
0xee,0x90,0xb0,0xff,0xee,0xb0,0xfe,0xee,0xb0,0x36,0xe6,0x43,0x0e,0x32,0xc0,0xe6,
0x40,0x1f,0xe6,0x40,0x8c,0xc8,0xb1,0x1f,0x33,0xff,0xbe,0xe3,0xfe,0xa5,0xab,0xe2,
0xfc,0xbb,0x00,0xf6,0x8b,0xf3,0xbf,0x55,0xaa,0xb1,0x04,0x8e,0xdb,0xa1,0x00,0x00,
0x3d,0x55,0xaa,0x74,0x18,0x97,0x3b,0xc7,0x74,0x13,0xb0,0x10,0x80,0xc7,0x02,0xe8,
0xcf,0x03,0xe1,0xe7,0x75,0x07,0xbf,0x60,0x00,0x91,0xab,0x96,0xab,0xb8,0x40,0x00,
0x8e,0xd8,0x8e,0xc0,0xb8,0x01,0x01,0xd5,0x10,0x3c,0x0b,0x75,0x05,0x80,0x0e,0x12,
0x00,0x04,0xe4,0x61,0x50,0x24,0xf7,0x50,0xe6,0x61,0xe4,0x62,0x24,0x0f,0x8a,0xe8,
0x58,0x0c,0x08,0xe6,0x61,0xe4,0x62,0xb1,0x04,0xd2,0xe0,0x0a,0xc5,0x50,0xba,0x80,
0x02,0x24,0x30,0x74,0x08,0xb2,0xc0,0x3c,0x30,0x74,0x02,0xb2,0xe0,0x89,0x16,0x15,
0x00,0x58,0xa8,0x02,0x74,0x07,0xe8,0xea,0x1d,0x74,0x02,0x24,0xfd,0xa2,0x10,0x00,
0x92,0x58,0xe6,0x61,0xb8,0x00,0xc0,0xbf,0x00,0xc8,0x52,0xe8,0x15,0x03,0x5a,0xa0,
0x10,0x00,0x83,0xe0,0x30,0xb1,0x04,0xd2,0xc8,0x92,0x75,0x05,0xb3,0x33,0xe9,0x73,
0x06,0xa8,0x30,0x74,0x0f,0x4a,0xb8,0x01,0x00,0x74,0x07,0xb0,0x03,0x4a,0x74,0x02,
0xb0,0x07,0xcd,0x10,0xe8,0xb0,0x16,0x33,0xdb,0xb4,0x03,0xcd,0x10,0x89,0x0e,0xe8,
0x00,0x52,0xba,0x00,0x18,0xb4,0x02,0xcd,0x10,0xbe,0xe0,0xff,0xe8,0xbe,0x14,0xbe,
0xf5,0xff,0xe8,0xb8,0x14,0x5a,0xb4,0x02,0xcd,0x10,0xe9,0xa9,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x50,0xe4,0x62,0xa8,0xc0,0x75,0x02,0x58,0xcf,0xbe,0xb2,0xf7,0xa8,
0x80,0x75,0x03,0xbe,0xb0,0xf7,0x33,0xc0,0xe6,0xa0,0xcd,0x10,0xe8,0x0e,0x14,0xe8,
0xc3,0x14,0xfa,0xf4,0xeb,0xfc,0xbf,0x78,0x00,0xb8,0x14,0x14,0xab,0xab,0xb8,0x01,
0x01,0xab,0xab,0xbb,0x11,0x00,0xba,0x01,0x02,0xec,0xa8,0x0f,0x75,0x03,0x80,0x0f,
0x10,0xb9,0x04,0x00,0x33,0xff,0xba,0xfa,0x03,0x32,0xc0,0xee,0xec,0xec,0x4a,0x4a,
0xa8,0xf0,0x75,0x06,0x92,0xab,0x92,0x80,0x07,0x02,0x81,0xea,0xfe,0x00,0x80,0xf9,
0x03,0x75,0x04,0x81,0xc2,0xf0,0x01,0xe2,0xe0,0xbf,0x08,0x00,0xba,0xbc,0x03,0xb1,
0x03,0xb0,0x0b,0xee,0x42,0x42,0x40,0xee,0x4a,0x4a,0xec,0x34,0x0b,0x75,0x06,0x92,
0xab,0x92,0x80,0x07,0x40,0xfe,0xce,0x80,0xf9,0x03,0x75,0x04,0x81,0xc2,0xbc,0x00,
0xe2,0xdf,0xba,0x61,0x00,0xec,0x24,0x3f,0xee,0x96,0xb8,0x1e,0x00,0xbf,0x1a,0x00,
0xab,0xab,0xbf,0x80,0x00,0xab,0xb0,0x3e,0xab,0xb0,0x1e,0xe8,0x06,0x14,0x96,0x0c,
0xc0,0xee,0x24,0x7f,0xee,0xe4,0x21,0x96,0xb0,0xfd,0xe6,0x21,0xfb,0x90,0xf7,0xc5,
0x00,0x40,0xe1,0xf9,0xfa,0x81,0xf5,0x00,0x40,0xec,0x0c,0xc0,0xee,0x24,0x7f,0xee,
0xe2,0xfe,0xe4,0x60,0x84,0xc0,0x74,0x04,0x81,0xcd,0x00,0x20,0xec,0x0c,0xc0,0xee,
0x96,0xe6,0x21,0x8e,0xc1,0xbf,0x24,0x00,0xb8,0x87,0xe9,0xab,0xe8,0x8c,0x0c,0xe8,
0x8c,0x02,0xe8,0xb0,0x01,0xe8,0x5f,0x12,0xe8,0x77,0x0c,0xe4,0x21,0x24,0xbc,0xe6,
0x21,0xb8,0x00,0xc8,0xbf,0x00,0xfe,0xe8,0x39,0x01,0xfb,0x33,0xc0,0x99,0xcd,0x13,
0x72,0x0d,0xa0,0x10,0x00,0x25,0xc0,0x00,0xb1,0x02,0xd2,0xc0,0x40,0xeb,0x04,0x81,
0xcd,0x00,0x10,0xb3,0x0e,0xbe,0xf4,0xe4,0xe8,0xa9,0x12,0xe8,0x70,0x13,0xe8,0xe1,
0x12,0x98,0xb2,0x80,0xcd,0x13,0x72,0x24,0xb2,0x80,0xe8,0x21,0x03,0x72,0x1d,0xb3,
0x0e,0xbe,0xf8,0xe4,0xe8,0xb4,0x12,0x52,0x92,0xe8,0x52,0x13,0xe8,0xbe,0x12,0x59,
0xe3,0x0d,0xb2,0x80,0xe8,0x4c,0x14,0x42,0xe2,0xfa,0xeb,0x03,0xe8,0xf7,0x12,0xe8,
0x83,0x13,0xb0,0x80,0xe6,0xa0,0xe8,0x26,0x05,0xe4,0x61,0x24,0x7f,0xe6,0x61,0x33,
0xc0,0xa3,0x72,0x00,0x81,0xe5,0xff,0x7f,0x74,0x20,0xbe,0xf5,0xe8,0xe8,0xad,0x12,
0x8b,0xc5,0xe8,0x05,0x13,0xe8,0xce,0x12,0xe8,0xd3,0x04,0xe8,0x74,0x04,0xbe,0xab,
0xe4,0xe8,0x99,0x12,0x91,0xcd,0x16,0xe8,0xbc,0x12,0xb7,0x07,0xb8,0x02,0x07,0xb9,
0x00,0x17,0xba,0x50,0x19,0xcd,0x10,0xe8,0x44,0x04,0xe8,0xa9,0x12,0x99,0xb9,0x03,
0x00,0x51,0xcd,0x19,0x59,0xe2,0xfa,0xcd,0x18,0xbe,0x8e,0xe4,0xe8,0x6e,0x12,0x33,
0xc0,0x8e,0xd8,0xa3,0x72,0x04,0xcd,0x16,0xe9,0xd0,0xfb,0x0d,0x0a,0x00,0x44,0x69,
0x73,0x6b,0x20,0x42,0x6f,0x6f,0x74,0x20,0x46,0x61,0x69,0x6c,0x2e,0x20,0x59,0x6f,
0x75,0x20,0x6d,0x6f,0x6e,0x73,0x74,0x65,0x72,0x2e,0x0a,0x0d,0x0a,0x50,0x72,0x65,
0x73,0x73,0x20,0x74,0x68,0x65,0x20,0x41,0x6e,0x79,0x20,0x4b,0x65,0x79,0x2e,0x2e,
0x2e,0x00,0x43,0x50,0x55,0x00,0x38,0x30,0x38,0x38,0x00,0x46,0x50,0x55,0x00,0x38,
0x30,0x38,0x37,0x00,0x3a,0x00,0x20,0x4d,0x42,0x00,0x52,0x41,0x4d,0x00,0x30,0x30,
0x30,0x20,0x4b,0x42,0x20,0x4f,0x4b,0x00,0x56,0x32,0x30,0x00,0x4c,0x50,0x54,0x00,
0x43,0x4f,0x4d,0x00,0x46,0x44,0x44,0x00,0x48,0x44,0x44,0x00,0x20,0x5b,0x20,0x00,
0x20,0x5d,0x00,0x55,0x1e,0x06,0x8e,0xd8,0xfc,0xbb,0x40,0x00,0x8e,0xc3,0x1e,0xb3,
0x80,0x53,0x33,0xf6,0xad,0x3d,0x55,0xaa,0x75,0x29,0xac,0x3c,0x00,0x7e,0x24,0xe8,
0x2f,0x00,0xe8,0x12,0x14,0x75,0x1c,0x5b,0xb1,0x04,0xd3,0xe8,0x50,0xe4,0x21,0x50,
0x57,0xbf,0x67,0x00,0x26,0x89,0x35,0x26,0x8c,0x5d,0x02,0x26,0xff,0x1d,0xfa,0x5f,
0x58,0xe6,0x21,0x5b,0x58,0x03,0xc3,0x8e,0xd8,0x3b,0xc7,0x72,0xbb,0x07,0x1f,0x5d,
0xc3,0x51,0x56,0x98,0x99,0x8b,0xf2,0x86,0xc4,0x91,0xad,0x02,0xd0,0x02,0xd4,0xe2,
0xf9,0x96,0x5e,0x59,0xc3,0x06,0x1e,0xb8,0x40,0x00,0x8e,0xd8,0xa1,0x15,0x00,0xb1,
0x04,0xd3,0xe8,0x91,0x49,0xba,0x00,0x04,0x8e,0xc2,0xe8,0x81,0x00,0x75,0x07,0x80,
0xc6,0x04,0x8e,0xc2,0xe2,0xf4,0xb1,0x06,0xd3,0xea,0x89,0x16,0x13,0x00,0x8c,0xc2,
0xb3,0x0a,0xbe,0xda,0xe4,0xe8,0xfc,0x10,0xe8,0x52,0x11,0xe8,0x34,0x11,0x33,0xdb,
0x8e,0xc3,0x33,0xc0,0x83,0xc3,0x10,0x83,0xfb,0x64,0x14,0x09,0xe8,0x4d,0x11,0x8b,
0xc3,0x53,0xe8,0x72,0x11,0x5b,0x8c,0xc0,0x05,0x00,0x04,0x3b,0xc2,0x73,0x0d,0x8e,
0xc0,0x33,0xc0,0xb9,0x00,0x20,0x8b,0xf8,0xf3,0xab,0xeb,0xd6,0x1f,0x07,0xc3,0x81,
0xcd,0x00,0x02,0xe8,0x40,0x11,0xb3,0x0c,0xbe,0xfc,0xe8,0xe8,0xb6,0x10,0x4f,0x4f,
0x26,0x33,0x05,0x97,0x8c,0xc3,0xe8,0x55,0x11,0x84,0xd2,0x74,0x08,0xbe,0xb2,0xf7,
0xe8,0xfa,0x10,0xeb,0x04,0x97,0xe8,0x51,0x11,0xe8,0xd6,0x10,0xeb,0xce,0xb0,0x01,
0x33,0xdb,0xbf,0x00,0x20,0x26,0x88,0x07,0xf6,0xd0,0x26,0x88,0x05,0xf6,0xd0,0x26,
0x38,0x07,0x75,0x0f,0xf6,0xd0,0x26,0x38,0x05,0x75,0x08,0xf6,0xd0,0xd0,0xc0,0xd1,
0xef,0x75,0xe2,0xc3,0xb8,0xa5,0x95,0xe8,0x05,0x00,0x75,0xf7,0xb8,0x5a,0x6a,0xb9,
0x00,0x20,0x33,0xff,0xf3,0xab,0xb5,0x20,0x33,0xff,0xf3,0xaf,0x91,0xc3,0xbe,0x55,
0xe6,0xb3,0x04,0xe8,0x4e,0x10,0x85,0xed,0x78,0x05,0xb3,0x09,0xbe,0x5f,0xe6,0xe8,
0x89,0x10,0xe9,0x78,0x10,0x42,0x6f,0x6f,0x74,0x00,0x57,0x41,0x52,0x4d,0x00,0x43,
0x4f,0x4c,0x44,0x00,0xb3,0x0a,0xbe,0x47,0xff,0xe8,0x4f,0x10,0x1e,0x33,0xc0,0x8e,
0xd8,0xc5,0x06,0x40,0x00,0x3d,0x65,0xf0,0x8c,0xd8,0x1f,0x75,0x13,0x8c,0xcb,0x3b,
0xc3,0x75,0x0d,0xe8,0xff,0x09,0xbe,0x27,0xe8,0x72,0x21,0xbe,0x23,0xe8,0xeb,0x1c,
0xb8,0x00,0x1a,0xcd,0x10,0x3c,0x1a,0x75,0x05,0xbe,0x1b,0xe8,0xeb,0x0e,0xb4,0x12,
0xb3,0x10,0xcd,0x10,0x80,0xfb,0x10,0x74,0x03,0xbe,0x1f,0xe8,0xe8,0x3e,0x10,0xe9,
0x1b,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xfb,0xfc,0x33,0xc9,0x8e,0xd9,0x8e,0xc1,0xbf,0x78,0x00,0xb8,0xc7,0xef,
0xab,0x8c,0xc8,0xab,0x91,0xcd,0x13,0x72,0x14,0xb8,0x01,0x02,0xbb,0x00,0x7c,0xb9,
0x01,0x00,0x8a,0xf5,0xcd,0x13,0x72,0x05,0xea,0x00,0x7c,0x00,0x00,0xcf,0xb4,0x08,
0xcd,0x13,0x72,0x14,0x8b,0xd9,0x86,0xfb,0xd0,0xc7,0xd0,0xc7,0x80,0xe7,0x03,0x83,
0xe1,0x3f,0x8a,0xc6,0x40,0x43,0x32,0xf6,0xc3,0xfb,0x51,0xb9,0x03,0x00,0x3b,0xd1,
0x77,0x56,0x57,0x53,0x52,0x1e,0xbf,0x40,0x00,0x8e,0xdf,0x8b,0xfa,0xd1,0xe7,0x8b,
0x15,0xd1,0xef,0x85,0xd2,0x74,0x3d,0x38,0xcc,0x77,0x39,0x74,0x2d,0x80,0xfc,0x01,
0x77,0x56,0x74,0x36,0x8b,0xfa,0x03,0xd1,0x93,0xb0,0x80,0xee,0xd3,0xe3,0xd2,0xeb,
0xb8,0x17,0x04,0x8a,0xcf,0xe3,0x05,0xb8,0x00,0x06,0xd3,0xe8,0x87,0xd7,0xef,0x93,
0x87,0xd7,0xee,0x87,0xd7,0x33,0xc0,0x42,0xee,0x4a,0x83,0xc2,0x05,0x53,0xec,0x86,
0xe0,0x42,0x5b,0xec,0x1f,0x5a,0x5b,0x5f,0x59,0xcf,0x52,0x50,0x83,0xc2,0x04,0xb0,
0x03,0xee,0x42,0x42,0xbb,0x20,0x30,0xe8,0x24,0x00,0x5b,0x8a,0xc3,0x5a,0x75,0x03,
0xee,0xeb,0xe1,0x80,0xcc,0x80,0xeb,0xdc,0x52,0x83,0xc2,0x04,0xb0,0x01,0xee,0x42,
0x42,0xbb,0x01,0x20,0xe8,0x07,0x00,0x5a,0x80,0xe4,0x1e,0xec,0xeb,0xc6,0xe8,0x05,
0x00,0x75,0x1a,0x86,0xfb,0x4a,0x56,0x33,0xc9,0x8a,0x45,0x7c,0x98,0x96,0xec,0x8a,
0xe0,0x32,0xc7,0x84,0xc7,0x74,0x05,0xe2,0xf5,0x4e,0x75,0xf2,0x5e,0xc3,0xb4,0x01,
0x33,0xc9,0x8b,0xfa,0x8a,0xcf,0x8b,0xd7,0x8a,0xc4,0xee,0xee,0x42,0xd0,0xc0,0xe2,
0xf9,0x8a,0xcf,0x8b,0xd7,0x8a,0xdc,0xec,0x38,0xd8,0x75,0x0e,0xec,0x38,0xd8,0x75,
0x09,0x42,0xd0,0xc3,0xe2,0xf1,0xd0,0xe4,0x75,0xda,0xc3,0x56,0x47,0x41,0x00,0x45,
0x47,0x41,0x00,0x43,0x47,0x41,0x00,0x4d,0x6f,0x6e,0x6f,0x00,0x00,0x00,0xfb,0xfc,
0x1e,0x56,0xbe,0x40,0x00,0x8e,0xde,0x80,0xfc,0x02,0x74,0x33,0x77,0x2e,0x7b,0x15,
0xbe,0x1a,0x00,0xfa,0xad,0x3b,0x04,0x75,0x06,0xfb,0x5e,0x1f,0xca,0x02,0x00,0x96,
0xad,0xeb,0xf6,0xfb,0xf4,0xbe,0x1a,0x00,0xfa,0xad,0x3b,0x04,0x74,0xf5,0x96,0xad,
0x83,0xfe,0x3e,0x72,0x03,0xbe,0x1e,0x00,0x89,0x36,0x1a,0x00,0x5e,0x1f,0xcf,0xa0,
0x17,0x00,0xeb,0xf8,0x8c,0xca,0x8e,0xd2,0x93,0xd4,0x10,0x95,0x8b,0xd5,0xbe,0xf1,
0x08,0x33,0xc9,0x8b,0xf9,0x8b,0xc6,0xbc,0x8c,0xe8,0xeb,0x4f,0x8e,0xe8,0x8b,0xcf,
0xe2,0xfe,0xbc,0x97,0xe8,0xeb,0x57,0x99,0xe8,0x2b,0xcf,0xe2,0xfe,0xfe,0xca,0x75,
0xe4,0x86,0xd6,0x85,0xd2,0x74,0xd5,0xb5,0x55,0xbe,0xa5,0x06,0xeb,0xd5,0x50,0xb8,
0x4c,0x05,0x53,0xe8,0x25,0x00,0x5b,0xb8,0xfa,0x00,0xe8,0xb7,0x0e,0xe8,0x2e,0x00,
0x58,0xc3,0xe8,0x00,0x00,0x50,0xb8,0x4c,0x05,0x53,0xe8,0x0e,0x00,0x5b,0xb5,0x20,
0xe2,0xfe,0xe8,0x19,0x00,0xb5,0x20,0xe2,0xfe,0x58,0xc3,0x93,0xb0,0xb6,0xe6,0x43,
0x93,0xe6,0x42,0x8a,0xc4,0xe6,0x42,0xe4,0x61,0x0c,0x03,0xe6,0x61,0xc3,0xe4,0x61,
0x24,0xfc,0xe6,0x61,0xc3,0x0d,0x0a,0x50,0x4f,0x53,0x54,0x20,0x45,0x72,0x72,0x6f,
0x72,0x20,0x00,0x4b,0x42,0x00,0x4b,0x65,0x79,0x00,0x46,0x44,0x43,0x00,0x44,0x4d,
0x41,0x00,0x03,0xe9,0x06,0xe9,0x0a,0xe9,0xf4,0xe4,0x0e,0xe9,0xda,0xe4,0xb9,0x07,
0x00,0xbe,0x10,0xe9,0x2e,0xad,0xd1,0xe5,0x73,0x07,0x9c,0x96,0xe8,0xe4,0x0d,0x96,
0x9d,0xe0,0xf1,0xc3,0x50,0x81,0xe5,0xff,0xbf,0xe4,0x60,0x3c,0xaa,0x75,0x04,0x81,
0xcd,0x00,0x40,0xe4,0x61,0x0c,0xc0,0xe6,0x61,0xb0,0x20,0xe6,0x20,0x58,0xcf,0x06,
0xb8,0x40,0x00,0x8e,0xc0,0x26,0xa1,0x80,0x00,0xbf,0x1a,0x00,0xab,0xab,0x07,0xc3,
0x00,0x03,0x1e,0x07,0x1f,0x0c,0x7f,0x0e,0x0a,0x1c,0x77,0x47,0x84,0x49,0x73,0x4b,
0x74,0x4d,0x75,0x4f,0x76,0x51,0x72,0x37,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0xe4,0x60,0x8a,0xe0,0xe4,0x61,0x50,0x0c,
0x80,0xe6,0x61,0x58,0xe6,0x61,0xb0,0x20,0xe6,0x20,0xfb,0xfc,0x53,0x51,0x52,0x57,
0x56,0x1e,0x06,0xba,0x40,0x00,0x8a,0xc4,0x3c,0xff,0x74,0x6d,0x8e,0xda,0x8c,0xca,
0x8e,0xc2,0x8b,0x16,0x17,0x00,0x3c,0x44,0x77,0x21,0x3c,0x3b,0x72,0x1d,0xb0,0x00,
0xf6,0xc2,0x0f,0x74,0x16,0x80,0xc4,0x2d,0xf6,0xc2,0x08,0x75,0x0b,0x80,0xec,0x0a,
0xf6,0xc2,0x04,0x75,0x03,0x80,0xec,0x0a,0xe9,0x96,0x00,0xf6,0xc2,0x04,0x74,0x14,
0x3c,0x46,0x75,0x0c,0xe8,0x68,0xff,0xc6,0x06,0x71,0x00,0x80,0xcd,0x1b,0xeb,0x27,
0x3c,0x45,0x74,0x16,0xf6,0xc2,0x20,0x74,0x25,0x3c,0x53,0x77,0x21,0x3c,0x47,0x72,
0x1d,0xd0,0xe0,0xf6,0xc2,0x03,0x74,0x1e,0xeb,0x1b,0xbb,0x18,0x00,0x80,0x0f,0x08,
0xf4,0x90,0xf6,0x07,0x08,0x75,0xf9,0xeb,0x73,0xe8,0xa9,0xfe,0xeb,0x6e,0xd0,0xe0,
0xf6,0xc2,0x0b,0x75,0x01,0x40,0xbb,0x8e,0xeb,0x2e,0xd7,0x84,0xc0,0x79,0x03,0xe9,
0xf9,0x00,0x84,0xe4,0x78,0x56,0xf6,0xc2,0x40,0x74,0x0f,0x50,0x0c,0x20,0x3c,0x61,
0x72,0x03,0x3c,0x7b,0xf5,0x58,0x72,0x02,0x34,0x20,0xf6,0xc2,0x08,0x75,0x46,0x3d,
0x00,0x37,0x74,0x0d,0x3d,0x00,0x4c,0x74,0x33,0xf6,0xc2,0x04,0x74,0x07,0xe9,0xb4,
0x00,0xcd,0x05,0xeb,0x27,0xf6,0xc6,0x08,0x74,0x07,0x80,0x26,0x18,0x00,0xf7,0xeb,
0x1b,0x8b,0x3e,0x1c,0x00,0x8d,0x75,0x02,0x83,0xfe,0x3e,0x72,0x03,0xbe,0x1e,0x00,
0x3b,0x36,0x1a,0x00,0x74,0x93,0x89,0x05,0x89,0x36,0x1c,0x00,0x07,0x1f,0x5e,0x5f,
0x5a,0x59,0x5b,0x58,0xcf,0x80,0xfc,0x39,0x74,0xbf,0x8b,0xd8,0xb0,0x00,0x80,0xfc,
0x0d,0x77,0x0a,0x80,0xfc,0x02,0x72,0x05,0x80,0xc4,0x76,0xeb,0xc4,0x80,0xeb,0x30,
0x72,0x12,0x80,0xfb,0x09,0x77,0x0d,0x93,0x8a,0x26,0x19,0x00,0xd5,0x0a,0xa2,0x19,
0x00,0x93,0xeb,0xc8,0xbf,0x0c,0xec,0xb9,0x0b,0x00,0x86,0xe0,0xf2,0xae,0x86,0xe0,
0x75,0x87,0xeb,0xb8,0x93,0xb9,0x0c,0x00,0xbe,0x60,0xe9,0x2e,0xad,0x38,0xfc,0xe0,
0xfa,0x75,0x0c,0x80,0xf9,0x06,0x7f,0x04,0xb4,0x00,0x86,0xc4,0xe9,0x76,0xff,0x93,
0x80,0xfc,0x27,0x72,0x05,0x80,0xfc,0x29,0x76,0x92,0x80,0xfc,0x10,0x72,0x09,0x80,
0xfc,0x32,0x77,0x04,0x24,0x1f,0xeb,0xe4,0x80,0xfc,0x02,0x72,0xdf,0x80,0xfc,0x35,
0x77,0xda,0xe9,0x77,0xff,0xf6,0xc2,0x08,0x74,0xba,0x80,0xfc,0x53,0x75,0xcd,0xe8,
0x8c,0xfd,0xc7,0x06,0x72,0x00,0x34,0x12,0xe9,0x30,0xf5,0xbb,0x18,0x00,0xbf,0x04,
0xec,0x8a,0xc4,0x24,0x7f,0xb1,0x01,0xae,0x74,0x07,0xd0,0xe1,0x75,0xf9,0xe9,0xf1,
0xfe,0xfa,0x8a,0xc1,0xa8,0xf0,0x74,0x18,0x84,0xe4,0x79,0x06,0xf6,0xd0,0x20,0x07,
0xeb,0x0b,0x08,0x07,0x30,0x47,0xff,0xa8,0x80,0xb0,0x00,0x75,0x2e,0xe9,0x2c,0xff,
0xa8,0x0c,0x74,0x08,0xd0,0xe8,0xd0,0xe8,0x30,0x07,0x8a,0xc1,0x4b,0x84,0xe4,0x78,
0x04,0x08,0x07,0xeb,0xe8,0xf6,0xd0,0x20,0x07,0x80,0xf9,0x08,0x75,0xdf,0xa0,0x19,
0x00,0x84,0xc0,0x74,0xd8,0xb4,0x00,0x88,0x26,0x19,0x00,0xe9,0xe3,0xfe,0x00,0x00,
0x1b,0x1b,0x21,0x31,0x40,0x32,0x23,0x33,0x24,0x34,0x25,0x35,0x5e,0x36,0x26,0x37,
0x2a,0x38,0x28,0x39,0x29,0x30,0x5f,0x2d,0x2b,0x3d,0x08,0x08,0x00,0x09,0x51,0x71,
0x57,0x77,0x45,0x65,0x52,0x72,0x54,0x74,0x59,0x79,0x55,0x75,0x49,0x69,0x4f,0x6f,
0x50,0x70,0x7b,0x5b,0x7d,0x5d,0x0d,0x0d,0x9d,0x9d,0x41,0x61,0x53,0x73,0x44,0x64,
0x46,0x66,0x47,0x67,0x48,0x68,0x4a,0x6a,0x4b,0x6b,0x4c,0x6c,0x3a,0x3b,0x22,0x27,
0x7e,0x60,0xaa,0xaa,0x7c,0x5c,0x5a,0x7a,0x58,0x78,0x43,0x63,0x56,0x76,0x42,0x62,
0x4e,0x6e,0x4d,0x6d,0x3c,0x2c,0x3e,0x2e,0x3f,0x2f,0xb6,0xb6,0x00,0x2a,0xb8,0xb8,
0x20,0x20,0xba,0xba,0x36,0x2a,0x1d,0x38,0x46,0x45,0x3a,0x52,0x0f,0x1c,0x27,0x28,
0x29,0x2b,0x33,0x34,0x35,0x37,0x00,0x00,0xc5,0xc5,0xc6,0xc6,0x37,0x00,0x38,0x00,
0x39,0x00,0x2d,0x2d,0x34,0x00,0x35,0x00,0x36,0x00,0x2b,0x2b,0x31,0x00,0x32,0x00,
0x33,0x00,0x30,0xd2,0x2e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfb,0xfc,0x1e,0x57,0x52,0x51,0x53,
0x50,0xbf,0x40,0x00,0x8e,0xdf,0xbf,0x41,0x00,0x80,0xfc,0x01,0x72,0x29,0x74,0x74,
0x80,0xfa,0x03,0x77,0x08,0xc6,0x05,0x00,0x80,0xfc,0x06,0x72,0x74,0xc6,0x05,0x01,
0xb0,0x02,0xe8,0x0b,0x03,0xa2,0x40,0x00,0x58,0x8a,0x25,0x5b,0x59,0x5a,0x5f,0x1f,
0x80,0xfc,0x01,0xf5,0xca,0x02,0x00,0xba,0xf2,0x03,0xfa,0xa0,0x3f,0x00,0x8a,0xe8,
0x24,0x0f,0x74,0x0e,0xd0,0xe8,0xa8,0x04,0x74,0x02,0xb0,0x03,0xb1,0x04,0xd2,0xe5,
0x0a,0xc5,0x0c,0x08,0xee,0x33,0xc9,0x88,0x4d,0xfd,0x88,0x0d,0x0c,0x04,0xee,0xfb,
0xe8,0x1e,0x02,0x72,0x04,0x3c,0xc0,0x74,0x02,0xb4,0x20,0x88,0x25,0x75,0xb1,0xb0,
0x03,0xe8,0xcc,0x01,0x72,0xaa,0xb0,0x00,0xe8,0xc2,0x01,0x72,0xa3,0xb0,0x01,0xe8,
0xbb,0x01,0xeb,0x9c,0x58,0x8a,0x05,0x8a,0xe0,0xeb,0xa0,0x80,0x0d,0x09,0xf9,0xeb,
0x64,0xe8,0x0b,0x01,0x72,0x8a,0x50,0x52,0x92,0x8a,0xc6,0xb6,0x4a,0x80,0x4d,0xfe,
0x80,0xa8,0x01,0x75,0x0c,0x80,0x65,0xfe,0x7f,0xb6,0x42,0x3c,0x04,0x74,0x02,0xb6,
0x46,0x92,0x51,0xe6,0x0c,0x8c,0xc2,0xb1,0x04,0xd3,0xc2,0x86,0xc4,0xe6,0x0b,0x32,
0xc0,0x91,0xb0,0x03,0xe8,0x69,0x02,0x91,0xd1,0xe8,0xd3,0xe0,0x48,0x91,0x8a,0xc2,
0x24,0x0f,0x80,0xe2,0xf0,0x03,0xd3,0x14,0x00,0x8b,0xda,0x03,0xd9,0x72,0xac,0xfa,
0xe6,0x81,0x92,0xe6,0x04,0x86,0xc4,0xe6,0x04,0x91,0xe6,0x05,0x86,0xc4,0xe6,0x05,
0xfb,0xb0,0x02,0xe6,0x0a,0x59,0x5a,0x58,0x72,0x88,0xb0,0xc5,0x80,0xfc,0x03,0x74,
0x09,0xb0,0x4d,0x80,0xfc,0x05,0x74,0x02,0xb0,0xe6,0x50,0xe8,0x32,0x01,0x58,0x72,
0x6f,0x8a,0xc6,0x92,0x25,0x03,0x01,0xd0,0xe4,0xd0,0xe4,0x0a,0xc4,0xe8,0x20,0x01,
0x72,0x5e,0x80,0xfe,0x05,0x74,0x5d,0x8a,0xc5,0xe8,0x14,0x01,0x72,0x52,0x8a,0xc2,
0xe8,0x0d,0x01,0x72,0x4b,0x8a,0xc1,0xe8,0x06,0x01,0x72,0x44,0xb0,0x03,0xe8,0xfc,
0x00,0x72,0x3d,0xb0,0x04,0xe8,0xf5,0x00,0x72,0x36,0xb0,0x05,0xe8,0xee,0x00,0x72,
0x2f,0xb0,0x06,0xe8,0xe7,0x00,0x72,0x28,0xe8,0x5e,0x01,0x72,0x23,0x8a,0x65,0x06,
0x8a,0xf2,0x8a,0xd5,0x3b,0x55,0x04,0x74,0x0e,0xb0,0x04,0xe8,0xc2,0x01,0x3a,0x75,
0x05,0x75,0x02,0xd0,0xe0,0x02,0xe0,0x8a,0xc4,0x2a,0xc1,0x59,0x50,0xe9,0xa0,0xfe,
0xb0,0x00,0xeb,0xf7,0xb0,0x03,0xe8,0xb4,0x00,0x72,0xf5,0xb0,0x04,0xe8,0xad,0x00,
0x72,0xee,0xb0,0x07,0xe8,0xa6,0x00,0x72,0xe7,0xb0,0x08,0xb1,0x01,0xeb,0xb4,0x50,
0xe8,0x2b,0x00,0x72,0x26,0xb0,0x0f,0xe8,0x96,0x00,0x72,0x1c,0x8a,0xc2,0xe8,0x8f,
0x00,0x72,0x15,0x8a,0xc5,0xe8,0x88,0x00,0x72,0x0e,0xe8,0xc4,0x00,0x72,0x09,0x34,
0x60,0x24,0x60,0x74,0x03,0xf8,0x58,0xc3,0x80,0x0d,0x40,0xf9,0xeb,0xf8,0x51,0x52,
0x8a,0xca,0x80,0xe1,0x03,0xb8,0x10,0x01,0xd3,0xe0,0xfa,0x8a,0x6d,0xfe,0x84,0xec,
0x75,0x20,0x0a,0xc1,0x0c,0x0c,0xba,0xf2,0x03,0xee,0x8a,0xc5,0x24,0xf0,0x0a,0xc4,
0xb4,0xff,0xa3,0x3f,0x00,0xfb,0xa8,0x80,0x74,0x11,0xb0,0x0a,0xe8,0x31,0x01,0xe8,
0x0e,0x09,0xb0,0x02,0xe8,0x29,0x01,0xa2,0x40,0x00,0xfb,0x5a,0xb0,0x01,0xd2,0xe0,
0x84,0x45,0xfd,0x75,0x1f,0x8a,0xe8,0xb0,0x07,0xe8,0x24,0x00,0x72,0x16,0x8a,0xc1,
0xe8,0x1d,0x00,0x72,0x0f,0xe8,0x59,0x00,0x72,0x0a,0x34,0x60,0x24,0x60,0xf9,0x74,
0x03,0x08,0x6d,0xfd,0x59,0xc3,0x53,0x33,0xdb,0x8a,0xf8,0xeb,0x08,0xe8,0xf0,0x00,
0x53,0x8a,0xf8,0xb3,0x01,0x51,0x52,0xba,0xf4,0x03,0xb9,0x05,0x00,0x8a,0x26,0x6c,
0x00,0xec,0x84,0xc0,0x79,0x19,0x42,0x84,0xdb,0x74,0x09,0xa8,0x40,0x75,0x10,0x8a,
0xc7,0xee,0xeb,0x05,0xa8,0x40,0x74,0x07,0xec,0x32,0xe4,0x5a,0x59,0x5b,0xc3,0xa0,
0x6c,0x00,0x38,0xe0,0x74,0xdb,0x8a,0xe0,0xe0,0xd7,0xb4,0x80,0x08,0x25,0xf9,0xeb,
0xea,0xe8,0x87,0x00,0x72,0x32,0xb0,0x08,0xe8,0xb5,0xff,0x72,0x2b,0x06,0x51,0x57,
0x52,0xba,0xf4,0x03,0xb8,0x40,0x00,0x8e,0xc0,0x47,0xb9,0x07,0x00,0xe8,0x96,0xff,
0x72,0x12,0xaa,0xb0,0x0a,0x48,0x75,0xfd,0xec,0x24,0x10,0xe0,0xf0,0xf3,0xaa,0xa0,
0x42,0x00,0xa8,0xc0,0x5a,0x5f,0x59,0x07,0xc3,0xe8,0x4f,0x00,0xe8,0xcc,0xff,0x76,
0x1d,0x56,0xa8,0x40,0xb0,0x20,0x74,0x10,0x8a,0x65,0x02,0x84,0xe4,0x74,0x09,0xbe,
0x3f,0xef,0x2e,0xac,0xd0,0xe4,0x77,0xfa,0x8a,0xe0,0x5e,0x08,0x25,0xf9,0xc3,0x04,
0x20,0x10,0x08,0x20,0x04,0x03,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfb,0x50,0x1e,0xb8,0x40,0x00,0x8e,0xd8,0x80,
0x0e,0x3e,0x00,0x80,0xb0,0x20,0xe6,0x20,0x1f,0x58,0xcf,0xfb,0x50,0x51,0xb9,0x25,
0x00,0xa1,0x6c,0x00,0xf6,0x45,0xfd,0x80,0x75,0x0f,0xf4,0x3b,0x06,0x6c,0x00,0x74,
0xf3,0xe2,0xee,0x80,0x0d,0x80,0xf9,0xeb,0x04,0x80,0x65,0xfd,0x7f,0x59,0x58,0xc3,
0x1e,0x53,0x33,0xdb,0x8e,0xdb,0xc5,0x1e,0x78,0x00,0xd7,0x5b,0x1f,0xc3,0x51,0xbf,
0x41,0x00,0xe8,0x89,0xfe,0x72,0x1a,0x85,0xed,0x78,0x12,0xe2,0xfe,0xbe,0xc3,0xef,
0x2e,0xac,0x8a,0xe8,0x51,0xe8,0x47,0xfe,0x59,0xe3,0x02,0x73,0xf3,0xb5,0x40,0xe2,
0xfe,0x59,0xc3,0x26,0x02,0x13,0x00,0xcf,0x02,0x25,0x02,0x08,0x2a,0xff,0x50,0xf6,
0x19,0x04,0xfb,0x83,0xfa,0x02,0x77,0x4a,0x52,0x57,0x51,0x50,0x1e,0xb9,0x40,0x00,
0x8e,0xd9,0x8b,0xfa,0x8a,0x4d,0x78,0xd1,0xe7,0x8b,0x55,0x08,0x1f,0x85,0xd2,0x74,
0x2b,0xfe,0xcc,0x74,0x2e,0x7f,0x1d,0xee,0x42,0x33,0xff,0xec,0xa8,0x80,0x75,0x09,
0x4f,0x75,0xf8,0xe2,0xf4,0x0c,0x01,0xeb,0x0f,0xb0,0x0d,0x42,0x52,0xee,0x5a,0xb0,
0x0c,0xee,0x4a,0x4a,0x42,0xec,0x24,0xf8,0x34,0x48,0x8a,0xe8,0x58,0x8a,0xe5,0x59,
0x5f,0x5a,0xcf,0xb0,0x08,0x42,0x42,0xee,0xb5,0x08,0xe2,0xfe,0x0c,0x04,0xee,0x4a,
0xeb,0xe3,0xe8,0xe1,0x06,0x8b,0x0e,0xe8,0x00,0xeb,0x03,0xb9,0x00,0x20,0x50,0xb4,
0x01,0xcd,0x10,0x58,0xc3,0xe4,0xf0,0x9f,0xf1,0xb5,0xf1,0xfb,0xf1,0x9e,0xf1,0x0c,
0xf2,0x34,0xf2,0x33,0xf2,0x47,0xf3,0xe8,0xf3,0xe8,0xf3,0xd2,0xf4,0xfd,0xf4,0x24,
0xf5,0x76,0xf5,0xe5,0xf5,0xfb,0x80,0xfc,0x0f,0x77,0x19,0x06,0x1e,0x57,0xfc,0xbf,
0x40,0x00,0x8e,0xdf,0x8b,0xf8,0x86,0xe0,0xd0,0xe0,0x98,0x97,0x2e,0xff,0x95,0x45,
0xf0,0x5f,0x1f,0x07,0xcf,0xa0,0x49,0x00,0x3c,0x07,0xf5,0x74,0x02,0xa8,0x04,0xc3,
0x50,0x1e,0xb8,0x40,0x00,0x8e,0xd8,0xa0,0x49,0x00,0x3c,0x02,0x74,0x02,0x3c,0x03,
0x1f,0x58,0xc3,0x00,0x38,0x28,0x2d,0x0a,0x1f,0x06,0x19,0x1c,0x02,0x07,0x06,0x07,
0x00,0x00,0x00,0x00,0x71,0x50,0x5a,0x0a,0x1f,0x06,0x19,0x1c,0x02,0x07,0x06,0x07,
0x00,0x00,0x00,0x00,0x38,0x28,0x2d,0x0a,0x7f,0x06,0x64,0x70,0x02,0x01,0x06,0x07,
0x00,0x00,0x00,0x00,0x61,0x50,0x52,0x0f,0x19,0x06,0x19,0x19,0x02,0x0d,0x0b,0x0c,
0x00,0x00,0x00,0x00,0x53,0x52,0x55,0x51,0x56,0xbf,0x49,0x00,0x3c,0x07,0x72,0x02,
0x8a,0x05,0x93,0x33,0xc0,0xb9,0x0f,0x00,0x1e,0x07,0xf3,0xab,0xa0,0x10,0x00,0x34,
0x30,0x24,0x30,0xb0,0x00,0xbe,0x10,0x00,0xb7,0x50,0xb5,0x10,0x8a,0xe5,0xbf,0x20,
0x07,0x75,0x0e,0x40,0xbd,0x00,0xb0,0xba,0xb8,0x03,0xb3,0x07,0xbe,0x30,0x00,0xeb,
0x26,0xb5,0x40,0xba,0xd8,0x03,0xbd,0x00,0xb8,0xf6,0xc3,0x04,0x74,0x0e,0xbe,0x20,
0x00,0xb4,0x40,0x33,0xff,0xf6,0xc3,0x02,0x75,0x0d,0xeb,0x09,0xf6,0xc3,0x02,0x75,
0x06,0xb4,0x08,0x33,0xf6,0xd0,0xef,0x89,0x1e,0x49,0x00,0x8e,0xc5,0x89,0x2e,0xea,
0x00,0xee,0x88,0x26,0x4d,0x00,0x80,0xea,0x04,0x89,0x16,0x63,0x00,0x8b,0xeb,0x97,
0x33,0xff,0xd1,0xe9,0xf3,0xab,0x1e,0x8b,0xc1,0xa2,0x62,0x00,0x8e,0xd8,0xc5,0x1e,
0x74,0x00,0x8b,0x78,0x0a,0xb1,0x10,0x8a,0x20,0xef,0x40,0x46,0xe2,0xf9,0x95,0x3c,
0x06,0xb4,0x3f,0x74,0x02,0xb4,0x30,0xbb,0x0f,0xf6,0xd7,0x1f,0x80,0xc2,0x04,0xa3,
0x65,0x00,0xef,0x97,0x86,0xe0,0xa3,0x60,0x00,0x5e,0x59,0x5d,0x5a,0x5b,0xc3,0x52,
0x97,0x89,0x0e,0x60,0x00,0xb0,0x0a,0x8a,0xe5,0x8b,0x16,0x63,0x00,0xef,0x40,0x8a,
0xe1,0xef,0x97,0x5a,0xc3,0x50,0x8a,0xc7,0x3c,0x07,0x77,0x30,0x98,0x97,0xd1,0xe7,
0x89,0x95,0x50,0x00,0x38,0x3e,0x62,0x00,0x75,0x22,0x53,0x52,0xa0,0x4a,0x00,0xf6,
0xe6,0x32,0xf6,0x03,0xc2,0x8b,0x1e,0x4e,0x00,0xd1,0xeb,0x03,0xd8,0xb0,0x0e,0x8a,
0xe7,0x8b,0x16,0x63,0x00,0xef,0x40,0x8a,0xe3,0xef,0x5a,0x5b,0x58,0xc3,0x32,0xff,
0xf6,0x06,0x49,0x00,0x04,0x75,0x04,0x8a,0x3e,0x62,0x00,0x50,0x8a,0xc7,0x98,0x97,
0xd1,0xe7,0x8b,0x95,0x50,0x00,0x8b,0x0e,0x60,0x00,0x58,0xc3,0x50,0x53,0x52,0xa2,
0x62,0x00,0x98,0x97,0xa1,0x4c,0x00,0xf7,0xe7,0xa3,0x4e,0x00,0xd1,0xe8,0x8a,0xd8,
0xb0,0x0c,0x8b,0x16,0x63,0x00,0xef,0x40,0x8a,0xe3,0xef,0xd1,0xe7,0x8b,0x95,0x50,
0x00,0xeb,0x99,0xfd,0x50,0x53,0x56,0x55,0x8b,0x36,0xea,0x00,0x8e,0xc6,0x80,0xfc,
0x06,0x9f,0x8b,0xe8,0x8b,0xfa,0x75,0x02,0x8b,0xd1,0xa0,0x4a,0x00,0x38,0xc2,0x72,
0x03,0x8a,0xd0,0x4a,0xf6,0xe6,0x8a,0xf0,0xe8,0x2a,0xfe,0x8a,0xc6,0xb6,0x00,0x1e,
0x75,0x5e,0x03,0xd0,0xd1,0xe2,0x03,0x16,0x4e,0x00,0x8b,0xf2,0x87,0xfa,0x2b,0xd1,
0x8b,0x0e,0x4a,0x00,0x8c,0xc0,0x8e,0xd8,0x8b,0xc5,0xd0,0xe1,0xf6,0xe1,0x95,0x81,
0xc2,0x01,0x01,0x9e,0x8a,0xe7,0x9c,0x8b,0xd9,0x8a,0xca,0x2b,0xd9,0x2b,0xd9,0x9d,
0x74,0x04,0xf7,0xdb,0xf7,0xdd,0x84,0xc0,0x74,0x14,0x2a,0xf0,0x74,0x0e,0x03,0xf5,
0x8a,0xca,0xf3,0xa5,0x03,0xfb,0x03,0xf3,0xfe,0xce,0x75,0xf4,0x8a,0xf0,0xb0,0x20,
0x8a,0xca,0xf3,0xab,0x03,0xfb,0xfe,0xce,0x75,0xf6,0x1f,0x5d,0x5e,0x5b,0x58,0xc3,
0xd1,0xe0,0xd1,0xe0,0x03,0xd0,0x87,0xd7,0x81,0xc2,0x01,0x01,0x2b,0xd1,0x95,0x8a,
0xd8,0xbd,0x50,0x00,0xb9,0x02,0x00,0xd2,0xe6,0xd2,0xe3,0x80,0x3e,0x49,0x00,0x06,
0x74,0x08,0xd1,0xe7,0xd0,0xe2,0x9e,0x74,0x0a,0x47,0x9e,0x74,0x06,0x81,0xc7,0xf0,
0x00,0xf7,0xdd,0x84,0xc0,0x74,0x33,0x8b,0xf7,0x8b,0xc5,0xf6,0xeb,0x03,0xf0,0x8c,
0xc0,0x8e,0xd8,0x53,0x2a,0xf3,0x8b,0xc6,0x8b,0xdf,0x8a,0xca,0xf3,0xa4,0xbe,0x00,
0x20,0x8b,0xfe,0x03,0xf0,0x03,0xfb,0x8a,0xca,0xf3,0xa4,0x03,0xc5,0x03,0xdd,0x8b,
0xf0,0x8b,0xfb,0xfe,0xce,0x75,0xe3,0x5b,0x8a,0xf3,0x8a,0xc7,0x8b,0xf7,0x8a,0xca,
0xf3,0xaa,0xbf,0x00,0x20,0x03,0xfe,0x8a,0xca,0xf3,0xaa,0x03,0xf5,0x8b,0xfe,0xfe,
0xce,0x75,0xeb,0x1f,0xe9,0x74,0xff,0x8b,0x3e,0xea,0x00,0x8e,0xc7,0xe8,0x9d,0x02,
0xa0,0x49,0x00,0x3c,0x07,0x75,0x04,0x26,0x8b,0x05,0xc3,0xd0,0xe8,0x3c,0x01,0x76,
0xf6,0x53,0x51,0x52,0x56,0x83,0xec,0x08,0xe8,0x52,0x01,0x8b,0xf7,0x8b,0xfc,0x06,
0x1f,0x16,0x07,0xb9,0x04,0x00,0xba,0x00,0x20,0x3c,0x03,0x74,0x5d,0xd1,0xe6,0x8b,
0x04,0x86,0xc4,0x8b,0xd8,0xd1,0xe0,0x0b,0xd8,0xb4,0x08,0xd1,0xe3,0x12,0xc0,0xd1,
0xe3,0xfe,0xcc,0x75,0xf6,0xaa,0x33,0xf2,0x85,0xf2,0x75,0xe3,0x83,0xc6,0x50,0xe2,
0xde,0x8b,0xfc,0xbe,0x6e,0xfa,0x8c,0xcb,0x8e,0xdb,0x33,0xc0,0xbb,0x80,0x00,0x56,
0x57,0xb1,0x04,0xf3,0xa7,0x5f,0x5e,0x74,0x19,0x83,0xc6,0x08,0xfe,0xc0,0x74,0x12,
0x4b,0x75,0xec,0x99,0x8e,0xda,0xc5,0x36,0x7c,0x00,0x8c,0xda,0x0b,0xd6,0x75,0xdc,
0x33,0xc0,0x83,0xc4,0x08,0x5e,0x5a,0x59,0x5b,0xc3,0xa4,0x4e,0x33,0xf2,0xa4,0x33,
0xf2,0x83,0xc6,0x4f,0xe2,0xf4,0xeb,0xb9,0x51,0x50,0x8b,0x3e,0xea,0x00,0x8e,0xc7,
0xe8,0xfa,0x01,0xa0,0x49,0x00,0x3c,0x07,0x75,0x12,0x58,0x80,0xfc,0x09,0x74,0x06,
0xaa,0x47,0xe2,0xfc,0x59,0xc3,0x8a,0xe3,0xf3,0xab,0x59,0xc3,0xd0,0xe8,0x3c,0x01,
0x76,0xe8,0x58,0x50,0x53,0x52,0x56,0x1e,0x8a,0x3e,0x49,0x00,0xe8,0x9e,0x00,0xbe,
0x6e,0xfa,0x8c,0xca,0x8e,0xda,0x84,0xc0,0x79,0x0a,0x24,0x7f,0x33,0xd2,0x8e,0xda,
0xc5,0x36,0x7c,0x00,0x98,0xd1,0xe0,0xd1,0xe0,0xd1,0xe0,0x03,0xf0,0x80,0xff,0x06,
0x74,0x56,0x8a,0xd3,0x83,0xe2,0x03,0x0a,0xf2,0xd0,0xe2,0xd0,0xe2,0x75,0xf8,0x8a,
0xd6,0xd1,0xe7,0x56,0x57,0x51,0xb9,0x08,0x00,0xac,0x53,0x51,0x33,0xdb,0xb1,0x08,
0xd0,0xe0,0x9f,0xd1,0xd3,0x9e,0xd1,0xd3,0xe2,0xf6,0x93,0x86,0xc4,0x59,0x5b,0x23,
0xc2,0x84,0xdb,0x79,0x03,0x26,0x33,0x05,0x26,0x89,0x05,0x81,0xf7,0x00,0x20,0xf7,
0xc7,0x00,0x20,0x75,0x03,0x83,0xc7,0x50,0xe2,0xcf,0x59,0x5f,0x5e,0x47,0x47,0xe2,
0xc2,0x1f,0x5e,0x5a,0x5b,0x58,0x59,0xc3,0x56,0x57,0xb7,0x04,0xad,0x84,0xdb,0x79,
0x08,0x26,0x32,0x05,0x26,0x32,0xa5,0x00,0x20,0xaa,0x26,0x88,0xa5,0xff,0x1f,0x83,
0xc7,0x4f,0xfe,0xcf,0x75,0xe6,0x5f,0x5e,0x47,0xe2,0xdd,0xeb,0xd4,0x8b,0xf8,0xa0,
0x4a,0x00,0x8b,0x16,0x50,0x00,0xf6,0xe6,0xd1,0xe0,0xd1,0xe0,0x92,0x98,0x03,0xc2,
0x97,0xc3,0x50,0xa0,0x66,0x00,0x84,0xff,0x75,0x07,0x24,0xe0,0x80,0xe3,0x1f,0xeb,
0x0b,0x24,0xdf,0x80,0xe3,0x01,0xd0,0xcb,0xd0,0xcb,0xd0,0xcb,0x0a,0xc3,0xa2,0x66,
0x00,0x52,0x8b,0x16,0x63,0x00,0x80,0xc2,0x05,0xee,0x5a,0x58,0xc3,0x50,0x51,0x8b,
0x3e,0xea,0x00,0x8e,0xc7,0xe8,0x2f,0x00,0x8a,0xe8,0x22,0xc4,0xd2,0xe0,0x84,0xed,
0x78,0x0d,0xd2,0xe4,0xf6,0xd4,0x26,0x22,0x25,0x0a,0xc4,0xaa,0x59,0x58,0xc3,0x26,
0x30,0x05,0xeb,0xf8,0x51,0x8b,0x3e,0xea,0x00,0x8e,0xc7,0xe8,0x09,0x00,0x26,0x8a,
0x05,0xd2,0xe8,0x22,0xc4,0x59,0xc3,0x53,0x52,0x8b,0xf9,0xd1,0xef,0xd1,0xef,0xb4,
0x03,0x8a,0xdc,0x8a,0xe9,0xb1,0x01,0x80,0x3e,0x49,0x00,0x06,0x72,0x07,0xd0,0xec,
0xd0,0xd3,0x49,0xd1,0xef,0x22,0xeb,0x2a,0xdd,0xd2,0xe3,0x8a,0xcb,0xd1,0xea,0x86,
0xd6,0x73,0x04,0x81,0xc7,0x00,0x20,0xd1,0xea,0xd1,0xea,0x03,0xfa,0xd1,0xea,0xd1,
0xea,0x03,0xfa,0x5a,0x5b,0xc3,0x50,0x53,0x51,0x52,0xe8,0x71,0xfc,0x3c,0x0d,0x76,
0x40,0xb9,0x01,0x00,0xe8,0x61,0xfe,0x8a,0x0e,0x4a,0x00,0x49,0x38,0xca,0x72,0x02,
0xb2,0xff,0x42,0x80,0xfe,0x18,0x76,0x21,0x32,0xe4,0xfe,0xce,0xe8,0xe6,0xfa,0x75,
0x03,0xe8,0xa3,0xfd,0x53,0x93,0xb8,0x01,0x06,0x33,0xc9,0x52,0x8a,0x16,0x4a,0x00,
0xb6,0x18,0x4a,0xfc,0xe8,0x7d,0xfc,0x5a,0x5b,0xe8,0xf9,0xfb,0x5a,0x59,0x5b,0x58,
0xc3,0x74,0x13,0x3c,0x0a,0x74,0x13,0x3c,0x08,0x74,0x13,0x3c,0x07,0x75,0xb2,0x5a,
0x59,0x5b,0x58,0xe9,0xd8,0xf2,0x32,0xd2,0xeb,0xdf,0xfe,0xc6,0xeb,0xb5,0x84,0xd2,
0x74,0xda,0x4a,0xeb,0xae,0xa1,0x49,0x00,0x8a,0x3e,0x62,0x00,0xc3,0x50,0x52,0x8a,
0xc7,0x98,0x97,0xa1,0x4c,0x00,0xf7,0xe7,0xd1,0xe7,0x8b,0x95,0x50,0x00,0x97,0xa0,
0x4a,0x00,0xf6,0xe6,0x92,0x98,0x03,0xc2,0xd1,0xe0,0x03,0xf8,0x5a,0x58,0xc3,0x2c,
0x28,0x2d,0x29,0x2a,0x2e,0x1e,0x29,0xe8,0x4a,0xf0,0xb3,0x0a,0xbe,0xc2,0xe4,0xe8,
0x72,0x00,0xf6,0x06,0x12,0x00,0x04,0x74,0x03,0xbe,0xe8,0xe4,0xe8,0xbe,0x00,0xe8,
0xa0,0x00,0xb3,0x0a,0xbe,0xcb,0xe4,0xe8,0x81,0x00,0xf6,0x06,0x10,0x00,0x02,0x75,
0x03,0xbe,0x4d,0xff,0xe8,0xa6,0x00,0xe8,0x83,0x00,0xb3,0x0e,0xbe,0xec,0xe4,0xe8,
0x42,0x00,0xa0,0x11,0x00,0x25,0xc0,0x00,0xb1,0x02,0xd2,0xc0,0x91,0xbe,0x08,0x00,
0xe8,0x15,0x00,0xb3,0x0e,0xbe,0xf0,0xe4,0xe8,0x50,0x00,0xa0,0x11,0x00,0x83,0xe0,
0x0e,0xb1,0x01,0xd2,0xc8,0x91,0x33,0xf6,0xe3,0x0e,0xad,0xe8,0xcc,0x00,0xe8,0x9e,
0x00,0xe2,0xf7,0xbe,0x01,0xe5,0xeb,0x4d,0xbe,0x4d,0xff,0xe8,0x5f,0x00,0xeb,0x42,
0xe8,0x83,0x00,0x58,0x50,0xb0,0x06,0x53,0x8a,0xe3,0xb9,0x09,0x00,0xbb,0x03,0x00,
0xe8,0x38,0x00,0xe8,0x56,0x00,0x56,0xbe,0xfc,0xe4,0xe8,0x40,0x00,0x8a,0xdc,0x4e,
0xb1,0x13,0x51,0xe8,0x25,0x00,0x59,0x5e,0x5b,0x58,0xc3,0x50,0xb4,0x0f,0xcd,0x10,
0x3c,0x01,0x7e,0xcc,0xb0,0x20,0xe8,0x33,0x00,0xb0,0x26,0xeb,0xca,0xe8,0x02,0x00,
0xeb,0x44,0xbe,0x00,0xe5,0xb9,0x02,0x00,0xbb,0x03,0x00,0x50,0xe8,0xa6,0xf9,0x73,
0x06,0x80,0xe3,0x0f,0x80,0xcb,0x07,0xb8,0x20,0x09,0xcd,0x10,0x58,0x50,0xb4,0x0e,
0x2e,0xac,0x84,0xc0,0x74,0x04,0xcd,0x10,0xeb,0xf6,0x58,0xc3,0x50,0x53,0x51,0x52,
0x50,0x32,0xff,0xb4,0x03,0xcd,0x10,0x58,0x8a,0xd0,0xb4,0x02,0xcd,0x10,0x5a,0x59,
0x5b,0x58,0xc3,0xe8,0xd7,0xff,0x56,0xbe,0x8b,0xe4,0xe8,0xd0,0xff,0x5e,0xc3,0x50,
0xb8,0x20,0x0e,0xcd,0x10,0x58,0xc3,0xbb,0x0a,0x00,0x52,0x33,0xd2,0xf7,0xf3,0x85,
0xc0,0x74,0x03,0xe8,0xf4,0xff,0x92,0x35,0x30,0x0e,0xcd,0x10,0x5a,0xc3,0x50,0x8b,
0xc3,0xe8,0x06,0x00,0xb0,0x3a,0xe8,0x1c,0x00,0x58,0x50,0x8a,0xc4,0xe8,0x01,0x00,
0x58,0x50,0xd0,0xe8,0xd0,0xe8,0xd0,0xe8,0xd0,0xe8,0xe8,0x01,0x00,0x58,0x24,0x0f,
0x3c,0x0a,0x1c,0x69,0x2f,0x50,0x53,0x33,0xdb,0xb4,0x0e,0xcd,0x10,0x5b,0x58,0xc3,
0xb4,0x7d,0xf6,0xe4,0x53,0xbb,0x52,0x09,0x93,0x51,0x52,0xf7,0xe3,0x93,0xe8,0x14,
0x00,0x8b,0xc8,0xe8,0x0f,0x00,0x2b,0xc8,0x2b,0xd9,0x8b,0xc8,0x83,0xda,0x00,0x73,
0xf2,0x5a,0x59,0x5b,0xc3,0xb0,0x00,0x9c,0xfa,0xe6,0x43,0xe4,0x40,0x8a,0xe0,0xe4,
0x40,0x9d,0x86,0xc4,0xc3,0xe4,0x61,0x0c,0x30,0xe6,0x61,0x34,0x30,0xe6,0x61,0xc3,
0x49,0x4f,0x20,0x50,0x41,0x52,0x49,0x54,0x59,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xfb,0x1e,0xb8,0x40,0x00,0x8e,0xd8,0xa1,0x13,0x00,0x1f,0xcf,0xfb,0x1e,0xb8,
0x40,0x00,0x8e,0xd8,0xa1,0x10,0x00,0x1f,0xcf,0xfb,0xb4,0x86,0x80,0xfc,0x01,0xf5,
0xca,0x02,0x00,0x51,0x52,0x52,0xe8,0xb5,0xee,0x5a,0x72,0x54,0x51,0x50,0x53,0x50,
0x53,0x51,0xb8,0x20,0x09,0xbb,0x03,0x00,0xb9,0x01,0x00,0xcd,0x10,0x59,0x5b,0x58,
0x92,0x24,0x03,0x04,0x43,0xe8,0xdd,0xfe,0x92,0xf6,0xe1,0xf7,0xe3,0xb9,0x00,0x08,
0xf7,0xf1,0xb3,0x0a,0xbe,0xd4,0xe4,0xe8,0xfa,0xfd,0xe8,0x8a,0xfe,0xe8,0x4d,0xfe,
0x58,0xe8,0x2e,0xfe,0xb3,0x0a,0xbe,0xc3,0xf8,0xe8,0x0f,0xfe,0xe8,0x78,0xfe,0xe8,
0x6d,0xfe,0x58,0xe8,0x74,0xfe,0xe8,0x66,0xfe,0x58,0xe8,0x6d,0xfe,0xe8,0x0d,0xfe,
0x5a,0x59,0xc3,0x43,0x48,0x53,0x00,0xbe,0x00,0xe0,0xe8,0x20,0xfe,0x8b,0xc5,0x83,
0xe5,0xfc,0x83,0xe0,0x03,0x96,0xd1,0xe6,0x2e,0x8b,0xb4,0x2f,0xf9,0xe8,0x0d,0xfe,
0xbe,0x31,0xe0,0xe8,0x2d,0xfe,0xc3,0x52,0x65,0x61,0x64,0x79,0x20,0x74,0x6f,0x20,
0x62,0x65,0x6c,0x69,0x65,0x76,0x65,0x20,0x79,0x6f,0x75,0x00,0x41,0x62,0x6f,0x72,
0x74,0x2c,0x20,0x52,0x65,0x74,0x72,0x79,0x2c,0x20,0x53,0x75,0x63,0x63,0x65,0x65,
0x64,0x00,0x57,0x68,0x65,0x6e,0x20,0x6c,0x69,0x66,0x65,0x20,0x67,0x69,0x76,0x65,
0x73,0x20,0x79,0x6f,0x75,0x20,0x6c,0x65,0x6d,0x6f,0x6e,0x61,0x64,0x65,0x00,0x0e,
0xe0,0xe7,0xf8,0xfc,0xf8,0x12,0xf9,0x50,0x56,0x9c,0x81,0xff,0x00,0xc8,0x76,0x32,
0x50,0xb3,0x0e,0xbe,0x8b,0xf9,0xe8,0x4b,0xfd,0x8c,0xd8,0xe8,0xfc,0xfd,0xe8,0x81,
0xfd,0x58,0x9d,0x9c,0x75,0x20,0x50,0xb3,0x0e,0xbe,0x8f,0xf9,0xe8,0x5c,0xfd,0x58,
0x86,0xe0,0xd0,0xe8,0xd0,0xe8,0xe8,0xbe,0xfd,0xbe,0x9c,0xf9,0xe8,0x7e,0xfd,0xe8,
0x5b,0xfd,0x9d,0x5e,0x58,0xc3,0xb3,0x0c,0xbe,0xfc,0xe8,0xe8,0x3d,0xfd,0xbe,0x94,
0xf9,0xe8,0x69,0xfd,0x8a,0xc2,0xe8,0xc8,0xfd,0xeb,0xe4,0x52,0x4f,0x4d,0x00,0x53,
0x69,0x7a,0x65,0x00,0x43,0x68,0x6b,0x73,0x75,0x6d,0x20,0x00,0x20,0x4b,0x42,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0x81,0xa5,0x81,0xbd,0x99,0x81,0x7e,0x7e,0xdb,
0xff,0xff,0xc3,0xe7,0x7e,0x00,0x36,0x7f,0x7f,0x7f,0x3e,0x1c,0x08,0x00,0x08,0x1c,
0x3e,0x7f,0x3e,0x1c,0x08,0x00,0x18,0x3c,0x18,0x66,0xff,0x66,0x18,0x3c,0x08,0x1c,
0x3e,0x7f,0x7f,0x3e,0x08,0x1c,0x00,0x00,0x18,0x3c,0x3c,0x18,0x00,0x00,0xff,0xff,
0xe7,0xc3,0xc3,0xe7,0xff,0xff,0x00,0x3c,0x66,0x42,0x42,0x66,0x3c,0x00,0xff,0xc3,
0x99,0xbd,0xbd,0x99,0xc3,0xff,0x3f,0x0d,0x1c,0x3e,0x63,0x63,0x3e,0x00,0x3e,0x63,
0x63,0x3e,0x1c,0x7f,0x1c,0x00,0x0e,0x0f,0x0d,0x0d,0x1c,0x7f,0x1c,0x00,0x0f,0x3b,
0x37,0x3b,0x33,0x37,0x77,0x70,0x18,0xdb,0x3c,0xe7,0x3c,0xdb,0x18,0x00,0x60,0x78,
0x7e,0x7f,0x7e,0x78,0x60,0x00,0x03,0x0f,0x3f,0x7f,0x3f,0x0f,0x03,0x00,0x18,0x3c,
0x7e,0x18,0x18,0x7e,0x3c,0x18,0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x00,0x3f,0x6d,
0x6d,0x3d,0x0d,0x0d,0x0d,0x00,0x3f,0x70,0x3e,0x63,0x63,0x3e,0x07,0x7e,0x00,0x00,
0x00,0x00,0xff,0xff,0xff,0x00,0x3c,0x7e,0x18,0x18,0x7e,0x3c,0x18,0x7e,0x18,0x3c,
0x7e,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,0x18,0x0c,
0x06,0x7f,0x06,0x0c,0x18,0x00,0x0c,0x18,0x30,0x7f,0x30,0x18,0x0c,0x00,0x00,0x00,
0x00,0x60,0x60,0x7f,0x00,0x00,0x00,0x24,0x66,0xff,0x66,0x24,0x00,0x00,0x08,0x1c,
0x1c,0x3e,0x3e,0x7f,0x7f,0x00,0x7f,0x7f,0x3e,0x3e,0x1c,0x1c,0x08,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x00,0x33,0x66,
0xcc,0x00,0x00,0x00,0x00,0x00,0x36,0x36,0x7f,0x36,0x36,0x7f,0x36,0x36,0x18,0x7e,
0x58,0x38,0x1c,0x1a,0x7e,0x18,0xe3,0xa6,0xec,0x18,0x37,0x65,0xc7,0x00,0x3c,0x66,
0x3c,0x38,0x6d,0x66,0x3d,0x00,0x06,0x0c,0x18,0x00,0x00,0x00,0x00,0x00,0x1c,0x30,
0x60,0x60,0x60,0x30,0x1c,0x00,0x38,0x0c,0x06,0x06,0x06,0x0c,0x38,0x00,0x63,0x36,
0x1c,0x7f,0x1c,0x36,0x63,0x00,0x18,0x18,0x18,0x7e,0x18,0x18,0x18,0x00,0x00,0x00,
0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x18,0x18,0x00,0x02,0x06,0x0c,0x18,0x30,0x60,0x40,0x00,0x3e,0x63,
0x63,0x6b,0x63,0x63,0x3e,0x00,0x1c,0x3c,0x0c,0x0c,0x0c,0x0c,0x0c,0x00,0x3e,0x63,
0x03,0x0e,0x38,0x60,0x7f,0x00,0x7c,0x06,0x06,0x3c,0x06,0x06,0x7c,0x00,0x0e,0x1e,
0x36,0x66,0x7f,0x06,0x06,0x00,0x7e,0x60,0x7c,0x06,0x06,0x06,0x7c,0x00,0x1e,0x30,
0x60,0x7e,0x63,0x63,0x3e,0x00,0x7e,0x66,0x0c,0x18,0x30,0x30,0x30,0x00,0x3e,0x63,
0x36,0x1c,0x36,0x63,0x3e,0x00,0x3e,0x63,0x63,0x3f,0x03,0x06,0x7c,0x00,0x00,0x00,
0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x30,0x0c,0x18,
0x30,0x60,0x30,0x18,0x0c,0x00,0x00,0x00,0x7e,0x00,0x7e,0x00,0x00,0x00,0x30,0x18,
0x0c,0x06,0x0c,0x18,0x30,0x00,0x3e,0x63,0x06,0x0c,0x0c,0x00,0x0c,0x00,0x3e,0x63,
0x6f,0x69,0x6f,0x60,0x3f,0x00,0x3c,0x66,0x66,0x7e,0x66,0x66,0x66,0x00,0x7e,0x63,
0x63,0x7e,0x63,0x63,0x7e,0x00,0x1e,0x33,0x60,0x60,0x60,0x33,0x1e,0x00,0x7c,0x66,
0x63,0x63,0x63,0x66,0x7c,0x00,0x7e,0x60,0x60,0x7c,0x60,0x60,0x7e,0x00,0x7e,0x60,
0x60,0x7c,0x60,0x60,0x60,0x00,0x1e,0x33,0x63,0x60,0x67,0x33,0x1e,0x00,0x63,0x63,
0x63,0x7f,0x63,0x63,0x63,0x00,0x3c,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x06,0x06,
0x06,0x06,0x66,0x66,0x3c,0x00,0x63,0x66,0x6c,0x78,0x6c,0x66,0x63,0x00,0x30,0x30,
0x30,0x30,0x30,0x30,0x3f,0x00,0x63,0x77,0x7f,0x6b,0x63,0x63,0x63,0x00,0x63,0x73,
0x7b,0x6f,0x67,0x63,0x63,0x00,0x3e,0x63,0x63,0x63,0x63,0x63,0x3e,0x00,0x7e,0x63,
0x63,0x7e,0x60,0x60,0x60,0x00,0x3e,0x63,0x63,0x63,0x7b,0x6e,0x3c,0x07,0x7e,0x63,
0x63,0x7e,0x6c,0x66,0x63,0x00,0x3e,0x63,0x30,0x1c,0x06,0x63,0x3e,0x00,0x7e,0x18,
0x18,0x18,0x18,0x18,0x18,0x00,0x63,0x63,0x63,0x63,0x63,0x63,0x3e,0x00,0x63,0x63,
0x63,0x63,0x36,0x1c,0x08,0x00,0x63,0x63,0x63,0x6b,0x6b,0x7f,0x36,0x00,0x63,0x63,
0x36,0x1c,0x36,0x63,0x63,0x00,0x63,0x63,0x63,0x3e,0x0c,0x0c,0x0c,0x00,0x7f,0x06,
0x0c,0x18,0x30,0x60,0x7f,0x00,0x3e,0x30,0x30,0x30,0x30,0x30,0x3e,0x00,0x40,0x60,
0x30,0x18,0x0c,0x06,0x02,0x00,0x3e,0x06,0x06,0x06,0x06,0x06,0x3e,0x00,0x1c,0x36,
0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x30,0x18,
0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x06,0x3e,0x66,0x3f,0x00,0x60,0x60,
0x7c,0x66,0x66,0x66,0x7c,0x00,0x00,0x00,0x3e,0x63,0x60,0x60,0x3f,0x00,0x06,0x06,
0x3e,0x66,0x66,0x66,0x3e,0x00,0x00,0x00,0x3c,0x66,0x7c,0x60,0x3e,0x00,0x1e,0x30,
0x30,0x7c,0x30,0x30,0x30,0x00,0x00,0x00,0x3f,0x63,0x63,0x3f,0x03,0x7e,0x60,0x60,
0x6c,0x76,0x66,0x66,0x66,0x00,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x00,0x06,0x00,
0x06,0x06,0x06,0x06,0x66,0x3c,0x60,0x60,0x66,0x6c,0x78,0x6c,0x66,0x00,0x18,0x18,
0x18,0x18,0x18,0x18,0x0c,0x00,0x00,0x00,0x76,0x7f,0x6b,0x6b,0x63,0x00,0x00,0x00,
0x6c,0x76,0x66,0x66,0x66,0x00,0x00,0x00,0x3e,0x63,0x63,0x63,0x3e,0x00,0x00,0x00,
0x7c,0x66,0x66,0x7c,0x60,0x60,0x00,0x00,0x3e,0x66,0x66,0x3e,0x06,0x06,0x00,0x00,
0x36,0x3b,0x30,0x30,0x30,0x00,0x00,0x00,0x3e,0x70,0x3c,0x0e,0x7c,0x00,0x18,0x18,
0x7e,0x18,0x18,0x18,0x0e,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x3b,0x00,0x00,0x00,
0x66,0x66,0x66,0x3c,0x18,0x00,0x00,0x00,0x63,0x63,0x6b,0x7f,0x36,0x00,0x00,0x00,
0x63,0x36,0x1c,0x36,0x63,0x00,0x00,0x00,0x66,0x66,0x66,0x3e,0x06,0x7c,0x00,0x00,
0x7e,0x0c,0x18,0x30,0x7e,0x00,0x0e,0x18,0x18,0x78,0x18,0x18,0x0e,0x00,0x18,0x18,
0x18,0x00,0x18,0x18,0x18,0x00,0x70,0x18,0x18,0x0e,0x18,0x18,0x70,0x00,0x3b,0x6e,
0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x3c,0x66,0xc3,0xc3,0xff,0x00,0x00,0xfb,0x80,
0xec,0x01,0x77,0x18,0x1e,0x56,0xbe,0x40,0x00,0x8e,0xde,0xbe,0x6c,0x00,0xfa,0x74,
0x0c,0xad,0x92,0xad,0x91,0x33,0xc0,0x86,0x04,0xfb,0x5e,0x1f,0xcf,0x89,0x14,0x89,
0x4c,0x02,0x88,0x64,0x04,0xeb,0xf2,0xb0,0xf0,0x20,0x06,0x3f,0x00,0x34,0xfc,0xba,
0xf2,0x03,0xee,0xeb,0x20,0x50,0x52,0x1e,0x57,0xb8,0x40,0x00,0x8e,0xd8,0x99,0xbf,
0x6c,0x00,0x83,0x05,0x01,0x11,0x55,0x02,0x83,0x7d,0x02,0x18,0x73,0x13,0xfb,0xfe,
0x0e,0x40,0x00,0x74,0xd2,0xcd,0x1c,0xfa,0xb0,0x20,0xe6,0x20,0x5f,0x1f,0x5a,0x58,
0xcf,0x80,0x3d,0xb0,0x72,0xe8,0x89,0x15,0x89,0x55,0x02,0xfe,0x45,0x04,0xeb,0xde,
0x00,0x00,0x00,0x23,0xff,0x23,0xff,0xc3,0xe2,0x23,0xff,0x23,0xff,0x54,0xff,0x23,
0xff,0x23,0xff,0xa5,0xfe,0x34,0xe9,0x23,0xff,0x23,0xff,0x23,0xff,0x23,0xff,0x57,
0xef,0x23,0xff,0x65,0xf0,0x4d,0xf8,0x41,0xf8,0x59,0xec,0x39,0xe7,0x59,0xf8,0x2e,
0xe8,0xd2,0xef,0x79,0xe4,0xf2,0xe6,0x6e,0xfe,0x53,0xff,0x53,0xff,0xa4,0xf0,0xc7,
0xef,0x00,0x00,0x50,0x1e,0xb0,0x0b,0xe6,0x20,0xb8,0x40,0x00,0x8e,0xd8,0xe4,0x20,
0x48,0x7c,0x0d,0x40,0x8a,0xe0,0xe4,0x21,0x0a,0xc4,0xe6,0x21,0xb0,0x20,0xe6,0x20,
0x88,0x26,0x6b,0x00,0x1f,0x58,0xcf,0x56,0x69,0x64,0x65,0x6f,0x00,0x4e,0x6f,0x6e,
0x65,0x00,0x00,0xcf,0xfc,0x50,0x57,0x06,0xbf,0x50,0x00,0x8e,0xc7,0x33,0xff,0xb0,
0x01,0xae,0x74,0x42,0xfb,0x4f,0xaa,0x53,0x51,0x52,0xb4,0x0f,0xcd,0x10,0x8a,0xdc,
0x4b,0xb4,0x03,0xcd,0x10,0x52,0xe8,0x31,0x00,0x72,0x1f,0x99,0xb4,0x02,0xcd,0x10,
0xb4,0x08,0xcd,0x10,0xe8,0x2c,0x00,0x72,0x11,0x38,0xd3,0x75,0x07,0xb2,0xff,0xe8,
0x18,0x00,0x72,0x06,0x42,0x80,0xfe,0x19,0x75,0xe2,0x1a,0xc0,0x4f,0xaa,0x5a,0xb4,
0x02,0xcd,0x10,0x5a,0x59,0x5b,0x07,0x5f,0x58,0xcf,0xb0,0x0d,0xe8,0x04,0x00,0x72,
0x11,0xb0,0x0a,0x52,0xb4,0x00,0x99,0x84,0xc0,0x75,0x02,0xb0,0x20,0xcd,0x17,0xd0,
0xec,0x5a,0xc3,0x97,0xdb,0xe3,0x50,0x8b,0xdc,0x36,0xdd,0x3f,0x90,0x58,0x84,0xc0,
0x75,0x0c,0x50,0x36,0xd9,0x3f,0x90,0x58,0x35,0x3f,0x10,0x83,0xe0,0x3f,0x97,0xc3,
0x56,0x65,0x72,0x3a,0x20,0x30,0x2e,0x32,0x2e,0x35,0x2d,0x38,0x45,0x20,0x00,0x00,
0xea,0x5b,0xe0,0x00,0xf0,0x30,0x37,0x2f,0x33,0x31,0x2f,0x32,0x33,0x00,0xfe,0xed,
};


// ==============================================================================
// src/bios/bios_rom_data.c end
// ==============================================================================

// ==============================================================================
// src/bios/bios.c start
// ==============================================================================

#line 1 "./src/bios/bios.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "bios_rom_data.h"
#include "public.h"
#endif  // YAX86_IMPLEMENTATION

uint32_t BIOSGetROMSize(void) {
  return kBIOSROMDataSize;
}

uint8_t BIOSReadROMByte(uint32_t offset) {
  if (offset >= kBIOSROMDataSize) {
    return 0xFF;
  }
  return kBIOSROMData[offset];
}


// ==============================================================================
// src/bios/bios.c end
// ==============================================================================


#endif  // YAX86_IMPLEMENTATION

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  // YAX86_BIOS_BUNDLE_H

// ==============================================================================
// YAX86 CPU MODULE - GENERATED SINGLE HEADER BUNDLE
// ==============================================================================

#ifndef YAX86_CPU_BUNDLE_H
#define YAX86_CPU_BUNDLE_H

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// ==============================================================================
// src/cpu/public.h start
// ==============================================================================

#line 1 "./src/cpu/public.h"
// Public interface for the CPU emulator module.
#ifndef YAX86_CPU_PUBLIC_H
#define YAX86_CPU_PUBLIC_H

#include <stdbool.h>
#include <stdint.h>

// ============================================================================
// CPU state
// ============================================================================

// CPU registers.
// Note that the order / numeric values of these constants are important here as
// they must match how the registers are encoded in the ModR/M byte.
typedef enum RegisterIndex {
  // General-purpose and index registers.

  // Accumulator Register
  kAX = 0,
  // Counter Register
  kCX = 1,
  // Data Register
  kDX = 2,
  // Base Register
  kBX = 3,
  // Stack Pointer Register
  kSP = 4,
  // Base Pointer Register
  kBP = 5,
  // Source Index Register
  kSI = 6,
  // Destination Index Register
  kDI = 7,

  // Segment registers.

  // Extra Segment Register
  kES = 8,
  // Code Segment Register
  kCS = 9,
  // Stack Segment Register
  kSS = 10,
  // Data Segment Register
  kDS = 11,

  // Instruction Pointer Register
  kIP,
} RegisterIndex;

enum {
  // Number of registers.
  kNumRegisters = kIP + 1,
};

// CPU flag masks.
typedef enum Flag {
  // Carry Flag
  kCF = (1 << 0),
  // Parity Flag
  kPF = (1 << 2),
  // Auxiliary Carry Flag
  kAF = (1 << 4),
  // Zero Flag
  kZF = (1 << 6),
  // Sign Flag
  kSF = (1 << 7),
  // Trap Flag
  kTF = (1 << 8),
  // Interrupt Enable Flag
  kIF = (1 << 9),
  // Direction Flag
  kDF = (1 << 10),
  // Overflow Flag
  kOF = (1 << 11),
} Flag;

enum {
  // CPU flags value on reset.
  kInitialFlags = (1 << 1),  // Reserved_1 is always 1.
};

// Standard interrupts.
typedef enum InterruptNumber {
  kInterruptDivideError = 0,
  kInterruptSingleStep = 1,
  kInterruptNMI = 2,
  kInterruptBreakpoint = 3,
  kInterruptOverflow = 4,
} InterruptNumer;

// Result status from executing an instruction or opcode.
typedef enum ExecuteStatus {
  // Successfully executed the instruction or opcode.
  kExecuteSuccess = 0,
  // Invalid instruction opcode.
  kExecuteInvalidOpcode,
  // Invalid instruction operands.
  kExecuteInvalidInstruction,
  // The interrupt was not handled by the interrupt handler callback, and should
  // be handled by the VM instead.
  kExecuteUnhandledInterrupt,
  // The CPU should be halted.
  kExecuteHalt,
} ExecuteStatus;

struct CPUState;
struct Instruction;

// Caller-provided runtime configuration.
typedef struct CPUConfig {
  // Custom data passed through to callbacks.
  void* context;

  // Callback to read a byte from memory.
  //
  // On the 8086, accessing an invalid memory address will yield garbage data
  // rather than causing a page fault. This callback interface mirrors that
  // behavior.
  //
  // For simplicity, we use a single 8-bit interface for memory access, similar
  // to the real-life 8088.
  uint8_t (*read_memory_byte)(struct CPUState* cpu, uint32_t address);

  // Callback to write a byte to memory.
  //
  // On the 8086, accessing an invalid memory address will yield garbage data
  // rather than causing a page fault. This callback interface mirrors that
  // behavior.
  //
  // For simplicity, we use a single 8-bit interface for memory access, similar
  // to the real-life 8088.
  void (*write_memory_byte)(
      struct CPUState* cpu, uint32_t address, uint8_t value);

  // Callback to handle an interrupt.
  //   - Return kExecuteSuccess if the interrupt was handled and execution
  //     should continue.
  //   - Return kExecuteUnhandledInterrupt if the interrupt was not handled and
  //     should be handled by the VM instead.
  //   - Return any other value to terminate the execution loop.
  ExecuteStatus (*handle_interrupt)(
      struct CPUState* cpu, uint8_t interrupt_number);

  // Callback invoked before executing an instruction. This can be used to
  // inspect or modify the instruction before it is executed, inject pending
  // interrupt or delay, or terminate the execution loop.
  //   - Return kExecuteSuccess to continue execution.
  //   - Return any other value to terminate the execution loop.
  ExecuteStatus (*on_before_execute_instruction)(
      struct CPUState* cpu, struct Instruction* instruction);

  // Callback invoked after executing an instruction. This can be used to
  // inspect the instruction after it is executed, inject pending interrupt or
  // delay, or terminate the execution loop.
  //   - Return kExecuteSuccess to continue execution.
  //   - Return any other value to terminate the execution loop.
  ExecuteStatus (*on_after_execute_instruction)(
      struct CPUState* cpu, const struct Instruction* instruction);

  // Callback to read a byte from an I/O port.
  //
  // On the 8086, accessing an invalid I/O port will most likely yield garbage
  // data. This callback interface mirrors that behavior.
  //
  // For simplicity, we use a single 8-bit interface for memory access, similar
  // to the real-life 8088.
  uint8_t (*read_port)(struct CPUState* cpu, uint16_t port);

  // Callback to write a byte to an I/O port.
  //
  // On the 8086, accessing an invalid I/O port will most likely yield garbage
  // data. This callback interface mirrors that behavior.
  //
  // For simplicity, we use a single 8-bit interface for memory access, similar
  // to the real-life 8088.
  void (*write_port)(struct CPUState* cpu, uint16_t port, uint8_t value);
} CPUConfig;

// State of the emulated CPU.
typedef struct CPUState {
  // Pointer to caller-provided runtime configuration
  CPUConfig* config;

  // Register values
  uint16_t registers[kNumRegisters];
  // Flag values
  uint16_t flags;

  // Whether there is an active interrupt.
  bool has_pending_interrupt;
  // The interrupt number of the pending interrupt.
  uint8_t pending_interrupt_number;

  // Whether the CPU is in halted state. When true, CPUTick() will not fetch
  // or execute any instructions until an external event (e.g., an interrupt)
  // clears this state.
  bool is_halted;
} CPUState;

// Initialize CPU state.
void CPUInit(CPUState* cpu, CPUConfig* config);

// Get the value of a CPU flag.
static inline bool CPUGetFlag(const CPUState* cpu, Flag flag) {
  return (cpu->flags & flag) != 0;
}
// Set a CPU flag.
static inline void CPUSetFlag(CPUState* cpu, Flag flag, bool value) {
  if (value) {
    cpu->flags |= flag;
  } else {
    cpu->flags &= ~flag;
  }
}

// Set pending interrupt to be executed at the end of the current instruction.
static inline void CPUSetPendingInterrupt(
    CPUState* cpu, uint8_t interrupt_number) {
  cpu->has_pending_interrupt = true;
  cpu->pending_interrupt_number = interrupt_number;
}

// Clear pending interrupt.
static inline void CPUClearPendingInterrupt(CPUState* cpu) {
  cpu->has_pending_interrupt = false;
  cpu->pending_interrupt_number = 0;
}

// ============================================================================
// Instructions
// ============================================================================

enum {
  // Maximum number of prefix bytes supported. On the 8086 and 80186, the length
  // of prefix bytes was actually unlimited. But well-formed code generated by
  // compilers would only have 1 or 2 bytes.
  kMaxPrefixBytes = 2,
  // Maximum number of displacement bytes in an 8086 instruction.
  kMaxDisplacementBytes = 2,
  // Maximum number of immediate data bytes in an 8086 instruction.
  kMaxImmediateBytes = 4,
};

// Instruction prefixes.
typedef enum {
  kPrefixES = 0x26,     // ES segment override
  kPrefixCS = 0x2E,     // CS segment override
  kPrefixSS = 0x36,     // SS segment override
  kPrefixDS = 0x3E,     // DS segment override
  kPrefixLOCK = 0xF0,   // LOCK
  kPrefixREPNZ = 0xF2,  // REPNE/REPNZ
  kPrefixREP = 0xF3,    // REP/REPE/REPZ
} InstructionPrefix;

// The Mod R/M byte.
typedef struct ModRM {
  // Mod field - bits 6 and 7
  uint8_t mod : 2;
  // REG field - bits 3 to 5
  uint8_t reg : 3;
  // R/M field - bits 0 to 2
  uint8_t rm : 3;
} ModRM;

// An encoded instruction.
typedef struct Instruction {
  // Prefix bytes.
  uint8_t prefix[kMaxPrefixBytes];

  // The primary opcode byte.
  uint8_t opcode;

  // The ModR/M byte, which specifies addressing modes. For some instructions,
  // the REG field within this byte acts as an opcode extension.
  ModRM mod_rm;

  // Raw displacement bytes. If displacement_size is 1, only disp_bytes[0] is
  // valid (value is typically sign-extended). If displacement_size is 2,
  // disp_bytes[0] is the low byte, disp_bytes[1] is the high byte.
  uint8_t displacement[kMaxDisplacementBytes];

  // Raw immediate data bytes.
  uint8_t immediate[kMaxImmediateBytes];

  // Flags

  // Whether prefix byte is part of this instruction.
  uint8_t prefix_size : 2;
  // Flag indicating if a ModR/M byte is part of this instruction.
  bool has_mod_rm : 1;
  // Number of displacement bytes present: 0, 1, or 2.
  uint8_t displacement_size : 2;
  // Number of immediate data bytes present: 0, 1, 2, or 4.
  uint8_t immediate_size : 3;

  // Total length of the original encoded instruction in bytes.
  uint8_t size;
} Instruction;

// ============================================================================
// Execution
// ============================================================================

// Result status from fetching the next instruction.
typedef enum CPUFetchNextInstructionStatus {
  kFetchSuccess = 0,
  // Prefix exceeds maximum allowed size.
  kFetchPrefixTooLong = -1,
} CPUFetchNextInstructionStatus;

// Fetch the next instruction from CS:IP.
CPUFetchNextInstructionStatus CPUFetchNextInstruction(
    CPUState* cpu, Instruction* instruction);

// Execute a single fetched instruction.
ExecuteStatus CPUExecuteInstruction(CPUState* cpu, Instruction* instruction);

// Run a single instruction cycle, including fetching and executing the next
// instruction at CS:IP, and handling interrupts.
ExecuteStatus CPUTick(CPUState* cpu);

#endif  // YAX86_CPU_PUBLIC_H


// ==============================================================================
// src/cpu/public.h end
// ==============================================================================


#ifdef YAX86_IMPLEMENTATION

// ==============================================================================
// src/util/common.h start
// ==============================================================================

#line 1 "./src/util/common.h"
#ifndef YAX86_UTIL_COMMON_H
#define YAX86_UTIL_COMMON_H

// Macro that expands to `static` when bundled. Use for variables and functions
// that need to be visible to other files within the same module, but not
// publicly to users of the bundled library.
//
// This enables better IDE integration as it allows each source file to be
// compiled independently in unbundled form, but still keeps the symbols private
// when bundled.
#ifdef YAX86_IMPLEMENTATION
// When bundled, static linkage so that the symbol is only visible within the
// implementation file.
#define YAX86_PRIVATE static
#else
// When unbundled, use default linkage.
#define YAX86_PRIVATE
#endif  // YAX86_IMPLEMENTATION

// Macro to mark a function or parameter as unused.
#if defined(__GNUC__) || defined(__clang__)
#define YAX86_UNUSED __attribute__((unused))
#else
#define YAX86_UNUSED
#endif  // defined(__GNUC__) || defined(__clang__)

#endif  // YAX86_UTIL_COMMON_H


// ==============================================================================
// src/util/common.h end
// ==============================================================================

// ==============================================================================
// src/cpu/types.h start
// ==============================================================================

#line 1 "./src/cpu/types.h"
#ifndef YAX86_CPU_TYPES_H
#define YAX86_CPU_TYPES_H

#ifndef YAX86_IMPLEMENTATION
#include "public.h"
#endif  // YAX86_IMPLEMENTATION

// Data width helpers.

// Data widths supported by the 8086 CPU.
typedef enum Width {
  kByte = 0,
  kWord,
} Width;

enum {
  // Number of data width types.
  kNumWidths = kWord + 1,
};

// Bitmask to extract the sign bit of a value.
static const uint32_t kSignBit[kNumWidths] = {
    1 << 7,   // kByte
    1 << 15,  // kWord
};

// Maximum unsigned value for each data width.
static const uint32_t kMaxValue[kNumWidths] = {
    0xFF,   // kByte
    0xFFFF  // kWord
};

// Maximum signed value for each data width.
static const int32_t kMaxSignedValue[kNumWidths] = {
    0x7F,   // kByte
    0x7FFF  // kWord
};

// Minimum signed value for each data width.
static const int32_t kMinSignedValue[kNumWidths] = {
    -0x80,   // kByte
    -0x8000  // kWord
};

// Number of bytes in each data width.
static const uint8_t kNumBytes[kNumWidths] = {
    1,  // kByte
    2,  // kWord
};

// Number of bits in each data width.
static const uint8_t kNumBits[kNumWidths] = {
    8,   // kByte
    16,  // kWord
};

// Operand types.

// The address of a register operand.
typedef struct RegisterAddress {
  // Register index.
  RegisterIndex register_index;
  // Byte offset within the register; only relevant for byte-sized operands.
  // 0 for low byte (AL, CL, DL, BL), 8 for high byte (AH, CH, DH, BH).
  uint8_t byte_offset;
} RegisterAddress;

// The address of a memory operand.
typedef struct MemoryAddress {
  // Segment register.
  RegisterIndex segment_register_index;
  // Effective address offset.
  uint16_t offset;
} MemoryAddress;

// Whether the operand is a register or memory operand.
typedef enum OperandAddressType {
  kOperandAddressTypeRegister = 0,
  kOperandAddressTypeMemory,
} OperandAddressType;

enum {
  // Number of operand address types.
  kNumOperandAddressTypes = kOperandAddressTypeMemory + 1,
};

// Operand address.
typedef struct OperandAddress {
  // Type of operand (register or memory).
  OperandAddressType type;
  // Address of the operand.
  union {
    RegisterAddress register_address;  // For register operands
    MemoryAddress memory_address;      // For memory operands
  } value;
} OperandAddress;

// Operand value.
typedef struct OperandValue {
  // Data width.
  Width width;
  // The value of the operand.
  union {
    uint8_t byte_value;   // For byte operands
    uint16_t word_value;  // For word operands
  } value;
} OperandValue;

// An operand.
typedef struct Operand {
  // Address of the operand.
  OperandAddress address;
  // Value of the operand.
  OperandValue value;
} Operand;

// Instruction types.

struct OpcodeMetadata;

// Context during instruction execution.
typedef struct {
  CPUState* cpu;
  const Instruction* instruction;
  const struct OpcodeMetadata* metadata;
} InstructionContext;

// Handler function for an opcode.
typedef ExecuteStatus (*OpcodeHandler)(const InstructionContext* context);

// An entry in the opcode lookup table.
typedef struct OpcodeMetadata {
  // Opcode.
  uint8_t opcode;

  // Instruction has ModR/M byte
  bool has_modrm : 1;
  // Number of immediate data bytes: 0, 1, 2, or 4
  uint8_t immediate_size : 3;

  // Width of the instruction's operands.
  Width width : 1;

  // Handler function.
  OpcodeHandler handler;
} OpcodeMetadata;

#endif  // YAX86_CPU_TYPES_H


// ==============================================================================
// src/cpu/types.h end
// ==============================================================================

// ==============================================================================
// src/cpu/operands.h start
// ==============================================================================

#line 1 "./src/cpu/operands.h"
#ifndef YAX86_CPU_OPERANDS_H
#define YAX86_CPU_OPERANDS_H

#ifndef YAX86_IMPLEMENTATION
#include "public.h"
#include "types.h"

// Helper function to construct an OperandValue for a byte.
extern OperandValue ByteValue(uint8_t byte_value);

// Helper function to construct OperandValue for a word.
extern OperandValue WordValue(uint16_t word_value);

// Helper function to construct OperandValue given a Width and a value.
extern OperandValue ToOperandValue(Width width, uint32_t raw_value);

// Helper function to zero-extend OperandValue to a 32-bit value. This makes it
// simpler to do direct arithmetic without worrying about overflow.
extern uint32_t FromOperandValue(const OperandValue* value);

// Helper function to sign-extend OperandValue to a 32-bit value. This makes it
// simpler to do direct arithmetic without worrying about overflow.
extern int32_t FromSignedOperandValue(const OperandValue* value);

// Helper function to extract a zero-extended value from an operand.
extern uint32_t FromOperand(const Operand* operand);

// Helper function to extract a sign-extended value from an operand.
extern int32_t FromSignedOperand(const Operand* operand);

// Computes the raw effective address corresponding to a MemoryAddress.
extern uint32_t ToRawAddress(const CPUState* cpu, const MemoryAddress* address);

// Read a byte from memory as a uint8_t.
extern uint8_t ReadRawMemoryByte(CPUState* cpu, uint32_t raw_address);

// Read a word from memory as a uint16_t.
extern uint16_t ReadRawMemoryWord(CPUState* cpu, uint32_t raw_address);

// Read a byte from memory as an OperandValue.
extern OperandValue ReadMemoryOperandByte(
    CPUState* cpu, const OperandAddress* address);

// Read a word from memory as an OperandValue.
extern OperandValue ReadMemoryOperandWord(
    CPUState* cpu, const OperandAddress* address);

// Read a byte from a register as an OperandValue.
extern OperandValue ReadRegisterOperandByte(
    CPUState* cpu, const OperandAddress* address);

// Read a word from a register as an OperandValue.
extern OperandValue ReadRegisterOperandWord(
    CPUState* cpu, const OperandAddress* address);

// Write a byte as uint8_t to memory.
extern void WriteRawMemoryByte(CPUState* cpu, uint32_t address, uint8_t value);

// Write a word as uint16_t to memory.
extern void WriteRawMemoryWord(CPUState* cpu, uint32_t address, uint16_t value);

// Write a byte to memory.
extern void WriteMemoryOperandByte(
    CPUState* cpu, const OperandAddress* address, OperandValue value);

// Write a word to memory.
extern void WriteMemoryOperandWord(
    CPUState* cpu, const OperandAddress* address, OperandValue value);

// Write a byte to a register.
extern void WriteRegisterOperandByte(
    CPUState* cpu, const OperandAddress* address, OperandValue value);

// Write a word to a register.
extern void WriteRegisterOperandWord(
    CPUState* cpu, const OperandAddress* address, OperandValue value);

// Add an 8-bit signed relative offset to a 16-bit unsigned base address.
extern uint16_t AddSignedOffsetByte(uint16_t base, uint8_t raw_offset);

// Add a 16-bit signed relative offset to a 16-bit unsigned base address.
extern uint16_t AddSignedOffsetWord(uint16_t base, uint16_t raw_offset);

// Get the register operand for a byte instruction based on the ModR/M byte's
// reg or R/M field.
extern RegisterAddress GetRegisterAddressByte(CPUState* cpu, uint8_t reg_or_rm);

// Get the register operand for a word instruction based on the ModR/M byte's
// reg or R/M field.
extern RegisterAddress GetRegisterAddressWord(CPUState* cpu, uint8_t reg_or_rm);

// Apply segment override prefixes to a MemoryAddress.
extern void ApplySegmentOverride(
    const Instruction* instruction, MemoryAddress* address);

// Compute the memory address for an instruction.
extern MemoryAddress GetMemoryOperandAddress(
    CPUState* cpu, const Instruction* instruction);

// Get a register or memory operand address based on the ModR/M byte and
// displacement.
extern OperandAddress GetRegisterOrMemoryOperandAddress(
    CPUState* cpu, const Instruction* instruction, Width width);

// Read an 8-bit immediate value.
extern OperandValue ReadImmediateOperandByte(const Instruction* instruction);

// Read a 16-bit immediate value.
extern OperandValue ReadImmediateOperandWord(const Instruction* instruction);

// Table of GetRegisterAddress functions, indexed by Width.
extern RegisterAddress (*const kGetRegisterAddressFn[kNumWidths])(
    CPUState* cpu, uint8_t reg_or_rm);

// Table of Read* functions, indexed by OperandAddressType and Width.
extern OperandValue (*const kReadOperandValueFn[kNumOperandAddressTypes][kNumWidths])(
    CPUState* cpu, const OperandAddress* address);

// Table of Write* functions, indexed by OperandAddressType and Width.
extern void (*const kWriteOperandFn[kNumOperandAddressTypes][kNumWidths])(
    CPUState* cpu, const OperandAddress* address, OperandValue value);

// Table of ReadImmediate* functions, indexed by Width.
extern OperandValue (*const kReadImmediateValueFn[kNumWidths])(
    const Instruction* instruction);

// Read a value from an operand address.
extern OperandValue ReadOperandValue(
    const InstructionContext* ctx, const OperandAddress* address);

// Get a register or memory operand for an instruction based on the ModR/M
// byte and displacement.
extern Operand ReadRegisterOrMemoryOperand(const InstructionContext* ctx);

// Get a register operand for an instruction.
extern Operand ReadRegisterOperandForRegisterIndex(
    const InstructionContext* ctx, RegisterIndex register_index);

// Get a register operand for an instruction from the REG field of the Mod/RM
// byte.
extern Operand ReadRegisterOperand(const InstructionContext* ctx);

// Get a segment register operand for an instruction from the REG field of the
// Mod/RM byte.
extern Operand ReadSegmentRegisterOperand(const InstructionContext* ctx);

// Write a value to a register or memory operand address.
extern void WriteOperandAddress(
    const InstructionContext* ctx, const OperandAddress* address,
    uint32_t raw_value);

// Write a value to a register or memory operand.
extern void WriteOperand(
    const InstructionContext* ctx, const Operand* operand, uint32_t raw_value);

// Read an immediate value from the instruction.
extern OperandValue ReadImmediate(const InstructionContext* ctx);

#endif  // YAX86_IMPLEMENTATION

#endif  // YAX86_CPU_OPERANDS_H


// ==============================================================================
// src/cpu/operands.h end
// ==============================================================================

// ==============================================================================
// src/cpu/operands.c start
// ==============================================================================

#line 1 "./src/cpu/operands.c"
#ifndef YAX86_IMPLEMENTATION
#include "operands.h"

#include "../util/common.h"
#endif  // YAX86_IMPLEMENTATION

// Helper functions to construct OperandValue.
YAX86_PRIVATE OperandValue ByteValue(uint8_t byte_value) {
  OperandValue value = {
      .width = kByte,
      .value = {.byte_value = byte_value},
  };
  return value;
}

// Helper function to construct OperandValue for a word.
YAX86_PRIVATE OperandValue WordValue(uint16_t word_value) {
  OperandValue value = {
      .width = kWord,
      .value = {.word_value = word_value},
  };
  return value;
}

// Helper function to construct OperandValue given a Width and a value.
YAX86_PRIVATE OperandValue ToOperandValue(Width width, uint32_t raw_value) {
  switch (width) {
    case kByte:
      return ByteValue(raw_value & kMaxValue[width]);
    case kWord:
      return WordValue(raw_value & kMaxValue[width]);
  }
  // Should never reach here, but return a default value to avoid warnings.
  return ByteValue(0xFF);
}

// Helper function to zero-extend OperandValue to a 32-bit value. This makes it
// simpler to do direct arithmetic without worrying about overflow.
YAX86_PRIVATE uint32_t FromOperandValue(const OperandValue* value) {
  switch (value->width) {
    case kByte:
      return value->value.byte_value;
    case kWord:
      return value->value.word_value;
  }
  // Should never reach here, but return a default value to avoid warnings.
  return 0xFFFF;
}

// Helper function to sign-extend OperandValue to a 32-bit value. This makes it
// simpler to do direct arithmetic without worrying about overflow.
YAX86_PRIVATE int32_t FromSignedOperandValue(const OperandValue* value) {
  switch (value->width) {
    case kByte:
      return (int32_t)((int8_t)value->value.byte_value);
    case kWord:
      return (int32_t)((int16_t)value->value.word_value);
  }
  // Should never reach here, but return a default value to avoid warnings.
  return 0xFFFF;
}

// Helper function to extract a zero-extended value from an operand.
YAX86_PRIVATE uint32_t FromOperand(const Operand* operand) {
  return FromOperandValue(&operand->value);
}

// Helper function to extract a sign-extended value from an operand.
YAX86_PRIVATE int32_t FromSignedOperand(const Operand* operand) {
  return FromSignedOperandValue(&operand->value);
}

// Computes the raw effective address corresponding to a MemoryAddress.
YAX86_PRIVATE uint32_t
ToRawAddress(const CPUState* cpu, const MemoryAddress* address) {
  uint16_t segment = cpu->registers[address->segment_register_index];
  return (((uint32_t)segment) << 4) + (uint32_t)(address->offset);
}

// Read a byte from memory as a uint8_t.
YAX86_PRIVATE uint8_t ReadRawMemoryByte(CPUState* cpu, uint32_t raw_address) {
  return cpu->config->read_memory_byte
             ? cpu->config->read_memory_byte(cpu, raw_address)
             : 0xFF;
}

// Read a word from memory as a uint16_t.
YAX86_PRIVATE uint16_t ReadRawMemoryWord(CPUState* cpu, uint32_t raw_address) {
  uint8_t low_byte_value = ReadRawMemoryByte(cpu, raw_address);
  uint8_t high_byte_value = ReadRawMemoryByte(cpu, raw_address + 1);
  return (((uint16_t)high_byte_value) << 8) | (uint16_t)low_byte_value;
}

// Read a byte from memory to an OperandValue.
YAX86_PRIVATE OperandValue
ReadMemoryOperandByte(CPUState* cpu, const OperandAddress* address) {
  uint8_t byte_value =
      ReadRawMemoryByte(cpu, ToRawAddress(cpu, &address->value.memory_address));
  return ByteValue(byte_value);
}

// Read a word from memory to an OperandValue.
YAX86_PRIVATE OperandValue
ReadMemoryOperandWord(CPUState* cpu, const OperandAddress* address) {
  uint16_t word_value =
      ReadRawMemoryWord(cpu, ToRawAddress(cpu, &address->value.memory_address));
  return WordValue(word_value);
}

// Read a byte from a register to an OperandValue.
YAX86_PRIVATE OperandValue
ReadRegisterOperandByte(CPUState* cpu, const OperandAddress* address) {
  const RegisterAddress* register_address = &address->value.register_address;
  uint8_t byte_value = cpu->registers[register_address->register_index] >>
                       register_address->byte_offset;
  return ByteValue(byte_value);
}

// Read a word from a register to an OperandValue.
YAX86_PRIVATE OperandValue
ReadRegisterOperandWord(CPUState* cpu, const OperandAddress* address) {
  const RegisterAddress* register_address = &address->value.register_address;
  uint16_t word_value = cpu->registers[register_address->register_index];
  return WordValue(word_value);
}

// Table of Read* functions, indexed by OperandAddressType and Width.
YAX86_PRIVATE
OperandValue (*const kReadOperandValueFn[kNumOperandAddressTypes][kNumWidths])(
    CPUState* cpu, const OperandAddress* address) = {
    // kOperandTypeRegister
    {ReadRegisterOperandByte, ReadRegisterOperandWord},
    // kOperandTypeMemory
    {ReadMemoryOperandByte, ReadMemoryOperandWord},
};

// Write a byte as uint8_t to memory.
YAX86_PRIVATE void WriteRawMemoryByte(
    CPUState* cpu, uint32_t address, uint8_t value) {
  if (!cpu->config->write_memory_byte) {
    return;
  }
  cpu->config->write_memory_byte(cpu, address, value);
}

// Write a word as uint16_t to memory.
YAX86_PRIVATE void WriteRawMemoryWord(
    CPUState* cpu, uint32_t address, uint16_t value) {
  WriteRawMemoryByte(cpu, address, value & 0xFF);
  WriteRawMemoryByte(cpu, address + 1, (value >> 8) & 0xFF);
}

// Write a byte to memory.
YAX86_PRIVATE void WriteMemoryOperandByte(
    CPUState* cpu, const OperandAddress* address, OperandValue value) {
  WriteRawMemoryByte(
      cpu, ToRawAddress(cpu, &address->value.memory_address),
      value.value.byte_value);
}

// Write a word to memory.
YAX86_PRIVATE void WriteMemoryOperandWord(
    CPUState* cpu, const OperandAddress* address, OperandValue value) {
  WriteRawMemoryWord(
      cpu, ToRawAddress(cpu, &address->value.memory_address),
      value.value.word_value);
}

// Write a byte to a register.
YAX86_PRIVATE void WriteRegisterOperandByte(
    CPUState* cpu, const OperandAddress* address, OperandValue value) {
  const RegisterAddress* register_address = &address->value.register_address;
  const uint16_t updated_byte = ((uint16_t)value.value.byte_value)
                                << register_address->byte_offset;
  const uint16_t other_byte =
      cpu->registers[register_address->register_index] &
      (((uint16_t)0xFF) << (8 - register_address->byte_offset));
  cpu->registers[register_address->register_index] = other_byte | updated_byte;
}

// Write a word to a register.
YAX86_PRIVATE void WriteRegisterOperandWord(
    CPUState* cpu, const OperandAddress* address, OperandValue value) {
  const RegisterAddress* register_address = &address->value.register_address;
  cpu->registers[register_address->register_index] = value.value.word_value;
}

// Table of Write* functions, indexed by OperandAddressType and Width.
YAX86_PRIVATE void (*const kWriteOperandFn[kNumOperandAddressTypes]
                                          [kNumWidths])(
    CPUState* cpu, const OperandAddress* address, OperandValue value) = {
    // kOperandTypeRegister
    {WriteRegisterOperandByte, WriteRegisterOperandWord},
    // kOperandTypeMemory
    {WriteMemoryOperandByte, WriteMemoryOperandWord},
};

// Add an 8-bit signed relative offset to a 16-bit unsigned base address.
YAX86_PRIVATE uint16_t AddSignedOffsetByte(uint16_t base, uint8_t raw_offset) {
  // Sign-extend the offset to 32 bits
  int32_t signed_offset = (int32_t)((int8_t)raw_offset);
  // Zero-extend base to 32 bits
  int32_t signed_base = (int32_t)base;
  // Add the two 32-bit signed values then truncate back down to 16-bit unsigned
  return (uint16_t)(signed_base + signed_offset);
}

// Add a 16-bit signed relative offset to a 16-bit unsigned base address.
YAX86_PRIVATE uint16_t AddSignedOffsetWord(uint16_t base, uint16_t raw_offset) {
  // Sign-extend the offset to 32 bits
  int32_t signed_offset = (int32_t)((int16_t)raw_offset);
  // Zero-extend base to 32 bits
  int32_t signed_base = (int32_t)base;
  // Add the two 32-bit signed values then truncate back down to 16-bit unsigned
  return (uint16_t)(signed_base + signed_offset);
}

// Get the register operand for a byte instruction based on the ModR/M byte's
// reg or R/M field.
YAX86_PRIVATE RegisterAddress
GetRegisterAddressByte(CPUState* cpu, uint8_t reg_or_rm) {
  (void)cpu;
  RegisterAddress address;
  if (reg_or_rm < 4) {
    // AL, CL, DL, BL
    address.register_index = (RegisterIndex)reg_or_rm;
    address.byte_offset = 0;
  } else {
    // AH, CH, DH, BH
    address.register_index = (RegisterIndex)(reg_or_rm - 4);
    address.byte_offset = 8;
  }
  return address;
}

// Get the register operand for a word instruction based on the ModR/M byte's
// reg or R/M field.
YAX86_PRIVATE RegisterAddress
GetRegisterAddressWord(CPUState* cpu, uint8_t reg_or_rm) {
  (void)cpu;
  const RegisterAddress address = {
      .register_index = (RegisterIndex)reg_or_rm, .byte_offset = 0};
  return address;
}

// Table of GetRegisterAddress functions, indexed by Width.
YAX86_PRIVATE RegisterAddress (*const kGetRegisterAddressFn[kNumWidths])(
    CPUState* cpu, uint8_t reg_or_rm) = {
  GetRegisterAddressByte,  // kByte
  GetRegisterAddressWord   // kWord
};

// Apply segment override prefixes to a MemoryAddress.
YAX86_PRIVATE void ApplySegmentOverride(
    const Instruction* instruction, MemoryAddress* address) {
  for (int i = 0; i < instruction->prefix_size; ++i) {
    switch (instruction->prefix[i]) {
      case kPrefixES:
        address->segment_register_index = kES;
        break;
      case kPrefixCS:
        address->segment_register_index = kCS;
        break;
      case kPrefixSS:
        address->segment_register_index = kSS;
        break;
      case kPrefixDS:
        address->segment_register_index = kDS;
        break;
      default:
        // Ignore other prefixes
        break;
    }
  }
}

// Compute the memory address for an instruction.
YAX86_PRIVATE MemoryAddress
GetMemoryOperandAddress(CPUState* cpu, const Instruction* instruction) {
  MemoryAddress address;
  uint8_t mod = instruction->mod_rm.mod;
  uint8_t rm = instruction->mod_rm.rm;
  switch (rm) {
    case 0:  // [BX + SI]
      address.offset = cpu->registers[kBX] + cpu->registers[kSI];
      address.segment_register_index = kDS;
      break;
    case 1:  // [BX + DI]
      address.offset = cpu->registers[kBX] + cpu->registers[kDI];
      address.segment_register_index = kDS;
      break;
    case 2:  // [BP + SI]
      address.offset = cpu->registers[kBP] + cpu->registers[kSI];
      address.segment_register_index = kSS;
      break;
    case 3:  // [BP + DI]
      address.offset = cpu->registers[kBP] + cpu->registers[kDI];
      address.segment_register_index = kSS;
      break;
    case 4:  // [SI]
      address.offset = cpu->registers[kSI];
      address.segment_register_index = kDS;
      break;
    case 5:  // [DI]
      address.offset = cpu->registers[kDI];
      address.segment_register_index = kDS;
      break;
    case 6:
      if (mod == 0) {
        // Direct memory address with 16-bit displacement
        address.offset = 0;
        address.segment_register_index = kDS;
      } else {
        // [BP]
        address.offset = cpu->registers[kBP];
        address.segment_register_index = kSS;
      }
      break;
    case 7:  // [BX]
      address.offset = cpu->registers[kBX];
      address.segment_register_index = kDS;
      break;
    default:
      // Not possible as RM field is 3 bits (0-7).
      address.offset = 0xFFFF;
      address.segment_register_index = kDS;  // Invalid RM field
      break;
  }

  // Apply segment override prefixes if present
  ApplySegmentOverride(instruction, &address);

  // Add displacement if present
  switch (instruction->displacement_size) {
    case 1: {
      uint8_t raw_displacement = instruction->displacement[0];
      address.offset = AddSignedOffsetByte(address.offset, raw_displacement);
      break;
    }
    case 2: {
      // Concatenate the two displacement bytes as an unsigned 16-bit integer
      uint16_t raw_displacement =
          ((uint16_t)instruction->displacement[0]) |
          (((uint16_t)instruction->displacement[1]) << 8);
      address.offset = AddSignedOffsetWord(address.offset, raw_displacement);
      break;
    }
    default:
      // No displacement
      break;
  }

  return address;
}

// Get a register or memory operand address based on the ModR/M byte and
// displacement.
YAX86_PRIVATE OperandAddress GetRegisterOrMemoryOperandAddress(
    CPUState* cpu, const Instruction* instruction, Width width) {
  OperandAddress address;
  uint8_t mod = instruction->mod_rm.mod;
  uint8_t rm = instruction->mod_rm.rm;
  if (mod == 3) {
    // Register operand
    address.type = kOperandAddressTypeRegister;
    address.value.register_address = kGetRegisterAddressFn[width](cpu, rm);
  } else {
    // Memory operand
    address.type = kOperandAddressTypeMemory;
    address.value.memory_address = GetMemoryOperandAddress(cpu, instruction);
  }
  return address;
}

// Read an 8-bit immediate value.
YAX86_PRIVATE OperandValue
ReadImmediateOperandByte(const Instruction* instruction) {
  return ByteValue(instruction->immediate[0]);
}

// Read a 16-bit immediate value.
YAX86_PRIVATE OperandValue
ReadImmediateOperandWord(const Instruction* instruction) {
  return WordValue(
      ((uint16_t)instruction->immediate[0]) |
      (((uint16_t)instruction->immediate[1]) << 8));
}

// Table of ReadImmediate* functions, indexed by Width.
YAX86_PRIVATE OperandValue (*const kReadImmediateValueFn[kNumWidths])(
    const Instruction* instruction) = {
  ReadImmediateOperandByte,  // kByte
  ReadImmediateOperandWord   // kWord
};

// Read a value from an operand address.
YAX86_PRIVATE OperandValue
ReadOperandValue(const InstructionContext* ctx, const OperandAddress* address) {
  return kReadOperandValueFn[address->type][ctx->metadata->width](
      ctx->cpu, address);
}

// Get a register or memory operand for an instruction based on the ModR/M
// byte and displacement.
YAX86_PRIVATE Operand
ReadRegisterOrMemoryOperand(const InstructionContext* ctx) {
  Width width = ctx->metadata->width;
  Operand operand;
  operand.address =
      GetRegisterOrMemoryOperandAddress(ctx->cpu, ctx->instruction, width);
  operand.value = ReadOperandValue(ctx, &operand.address);
  return operand;
}

// Get a register operand for an instruction.
YAX86_PRIVATE Operand ReadRegisterOperandForRegisterIndex(
    const InstructionContext* ctx, RegisterIndex register_index) {
  Width width = ctx->metadata->width;
  Operand operand = {
      .address = {
          .type = kOperandAddressTypeRegister,
          .value = {
              .register_address =
                  kGetRegisterAddressFn[width](ctx->cpu, register_index),
          }}};
  operand.value = ReadOperandValue(ctx, &operand.address);
  return operand;
}

// Get a register operand for an instruction from the REG field of the Mod/RM
// byte.
YAX86_PRIVATE Operand ReadRegisterOperand(const InstructionContext* ctx) {
  return ReadRegisterOperandForRegisterIndex(
      ctx, (RegisterIndex)ctx->instruction->mod_rm.reg);
}

// Get a segment register operand for an instruction from the REG field of the
// Mod/RM byte.
YAX86_PRIVATE Operand
ReadSegmentRegisterOperand(const InstructionContext* ctx) {
  return ReadRegisterOperandForRegisterIndex(
      ctx, (RegisterIndex)(ctx->instruction->mod_rm.reg + 8));
}

// Write a value to a register or memory operand address.
YAX86_PRIVATE void WriteOperandAddress(
    const InstructionContext* ctx, const OperandAddress* address,
    uint32_t raw_value) {
  Width width = ctx->metadata->width;
  kWriteOperandFn[address->type][width](
      ctx->cpu, address, ToOperandValue(width, raw_value));
}

// Write a value to a register or memory operand.
YAX86_PRIVATE void WriteOperand(
    const InstructionContext* ctx, const Operand* operand, uint32_t raw_value) {
  WriteOperandAddress(ctx, &operand->address, raw_value);
}

// Read an immediate value from the instruction.
YAX86_PRIVATE OperandValue ReadImmediate(const InstructionContext* ctx) {
  Width width = ctx->metadata->width;
  return kReadImmediateValueFn[width](ctx->instruction);
}


// ==============================================================================
// src/cpu/operands.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions.h start
// ==============================================================================

#line 1 "./src/cpu/instructions.h"
#ifndef YAX86_CPU_INSTRUCTIONS_H
#define YAX86_CPU_INSTRUCTIONS_H

#ifndef YAX86_IMPLEMENTATION
#include "public.h"
#include "types.h"

// ============================================================================
// Helpers - instructions_helpers.h
// ============================================================================

// Set common CPU flags after an instruction. This includes:
// - Zero flag (ZF)
// - Sign flag (SF)
// - Parity Flag (PF)
extern void SetCommonFlagsAfterInstruction(
    const InstructionContext* ctx, uint32_t result);

// Push a value onto the stack.
extern void Push(CPUState* cpu, OperandValue value);
// Pop a value from the stack.
extern OperandValue Pop(CPUState* cpu);

// Dummy instruction for unsupported opcodes.
extern ExecuteStatus ExecuteNoOp(const InstructionContext* ctx);

// ============================================================================
// Opcode table - opcode_table.h
// ============================================================================

// Global opcode metadata lookup table.
extern OpcodeMetadata opcode_table[256];

// ============================================================================
// Move instructions - instructions_mov.h
// ============================================================================

// MOV r/m8, r8
// MOV r/m16, r16
extern ExecuteStatus ExecuteMoveRegisterToRegisterOrMemory(
    const InstructionContext* ctx);
// MOV r8, r/m8
// MOV r16, r/m16
extern ExecuteStatus ExecuteMoveRegisterOrMemoryToRegister(
    const InstructionContext* ctx);
// MOV r/m16, sreg
extern ExecuteStatus ExecuteMoveSegmentRegisterToRegisterOrMemory(
    const InstructionContext* ctx);
// MOV sreg, r/m16
extern ExecuteStatus ExecuteMoveRegisterOrMemoryToSegmentRegister(
    const InstructionContext* ctx);
// MOV AX/CX/DX/BX/SP/BP/SI/DI, imm16
// MOV AH/AL/CH/CL/DH/DL/BH/BL, imm8
extern ExecuteStatus ExecuteMoveImmediateToRegister(
    const InstructionContext* ctx);
// MOV AL, moffs16
// MOV AX, moffs16
extern ExecuteStatus ExecuteMoveMemoryOffsetToALOrAX(
    const InstructionContext* ctx);
// MOV moffs16, AL
// MOV moffs16, AX
extern ExecuteStatus ExecuteMoveALOrAXToMemoryOffset(
    const InstructionContext* ctx);
// MOV r/m8, imm8
// MOV r/m16, imm16
extern ExecuteStatus ExecuteMoveImmediateToRegisterOrMemory(
    const InstructionContext* ctx);
// XCHG AX, AX/CX/DX/BX/SP/BP/SI/DI
extern ExecuteStatus ExecuteExchangeRegister(const InstructionContext* ctx);
// XCHG r/m8, r8
// XCHG r/m16, r16
extern ExecuteStatus ExecuteExchangeRegisterOrMemory(
    const InstructionContext* ctx);
// XLAT
extern ExecuteStatus ExecuteTranslateByte(const InstructionContext* ctx);

// ============================================================================
// LEA instructions - instructions_lea.h
// ============================================================================

// LEA r16, m
extern ExecuteStatus ExecuteLoadEffectiveAddress(const InstructionContext* ctx);
// LES r16, m
extern ExecuteStatus ExecuteLoadESWithPointer(const InstructionContext* ctx);
// LDS r16, m
extern ExecuteStatus ExecuteLoadDSWithPointer(const InstructionContext* ctx);

// ============================================================================
// Addition instructions - instructions_add.h
// ============================================================================

// Common logic for ADD instructions
extern ExecuteStatus ExecuteAdd(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value);
// Common logic for INC instructions
extern ExecuteStatus ExecuteInc(const InstructionContext* ctx, Operand* dest);
// Common logic for ADC instructions
extern ExecuteStatus ExecuteAddWithCarry(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value);

// ADD r/m8, r8
// ADD r/m16, r16
extern ExecuteStatus ExecuteAddRegisterToRegisterOrMemory(
    const InstructionContext* ctx);
// ADD r8, r/m8
// ADD r16, r/m16
extern ExecuteStatus ExecuteAddRegisterOrMemoryToRegister(
    const InstructionContext* ctx);
// ADD AL, imm8
// ADD AX, imm16
extern ExecuteStatus ExecuteAddImmediateToALOrAX(const InstructionContext* ctx);
// ADC r/m8, r8
// ADC r/m16, r16
extern ExecuteStatus ExecuteAddRegisterToRegisterOrMemoryWithCarry(
    const InstructionContext* ctx);
// ADC r8, r/m8
// ADC r16, r/m16
extern ExecuteStatus ExecuteAddRegisterOrMemoryToRegisterWithCarry(
    const InstructionContext* ctx);
// ADC AL, imm8
// ADC AX, imm16
extern ExecuteStatus ExecuteAddImmediateToALOrAXWithCarry(
    const InstructionContext* ctx);
// INC AX/CX/DX/BX/SP/BP/SI/DI
extern ExecuteStatus ExecuteIncRegister(const InstructionContext* ctx);

// ============================================================================
// Subtraction instructions - instructions_sub.c
// ============================================================================

// Set CPU flags after a SUB, SBB, CMP, or NEG instruction.
extern void SetFlagsAfterSub(
    const InstructionContext* ctx, uint32_t op1, uint32_t op2, uint32_t result,
    bool did_borrow);

// Common logic for SUB instructions
extern ExecuteStatus ExecuteSub(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value);
// Common logic for SBB instructions
extern ExecuteStatus ExecuteSubWithBorrow(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value);
// Common logic for DEC instructions
extern ExecuteStatus ExecuteDec(const InstructionContext* ctx, Operand* dest);

// SUB r/m8, r8
// SUB r/m16, r16
extern ExecuteStatus ExecuteSubRegisterFromRegisterOrMemory(
    const InstructionContext* ctx);
// SUB r8, r/m8
// SUB r16, r/m16
extern ExecuteStatus ExecuteSubRegisterOrMemoryFromRegister(
    const InstructionContext* ctx);
// SUB AL, imm8
// SUB AX, imm16
extern ExecuteStatus ExecuteSubImmediateFromALOrAX(
    const InstructionContext* ctx);
// SBB r/m8, r8
// SBB r/m16, r16
extern ExecuteStatus ExecuteSubRegisterFromRegisterOrMemoryWithBorrow(
    const InstructionContext* ctx);
// SBB r8, r/m8
// SBB r16, r/m16
extern ExecuteStatus ExecuteSubRegisterOrMemoryFromRegisterWithBorrow(
    const InstructionContext* ctx);
// SBB AL, imm8
// SBB AX, imm16
extern ExecuteStatus ExecuteSubImmediateFromALOrAXWithBorrow(
    const InstructionContext* ctx);
// DEC AX/CX/DX/BX/SP/BP/SI/DI
extern ExecuteStatus ExecuteDecRegister(const InstructionContext* ctx);

// ============================================================================
// Sign extension instructions - instructions_sign_ext.c
// ============================================================================

// CBW
extern ExecuteStatus ExecuteCbw(const InstructionContext* ctx);
// CWD
extern ExecuteStatus ExecuteCwd(const InstructionContext* ctx);

// ============================================================================
// CMP instructions - instructions_cmp.c
// ============================================================================

// Common logic for CMP instructions. Computes dest - src and sets flags.
extern ExecuteStatus ExecuteCmp(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value);

// CMP r/m8, r8
// CMP r/m16, r16
extern ExecuteStatus ExecuteCmpRegisterToRegisterOrMemory(
    const InstructionContext* ctx);
// CMP r8, r/m8
// CMP r16, r/m16
extern ExecuteStatus ExecuteCmpRegisterOrMemoryToRegister(
    const InstructionContext* ctx);
// CMP AL, imm8
// CMP AX, imm16
extern ExecuteStatus ExecuteCmpImmediateToALOrAX(const InstructionContext* ctx);

// ============================================================================
// Boolean instructions - instructions_bool.c
// ============================================================================

extern void SetFlagsAfterBooleanInstruction(
    const InstructionContext* ctx, uint32_t result);
// Common logic for AND instructions.
extern ExecuteStatus ExecuteBooleanAnd(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value);
// Common logic for OR instructions.
extern ExecuteStatus ExecuteBooleanOr(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value);
// Common logic for XOR instructions.
extern ExecuteStatus ExecuteBooleanXor(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value);
// Common logic for TEST instructions.
extern ExecuteStatus ExecuteTest(
    const InstructionContext* ctx, Operand* dest, OperandValue* src_value);

// AND r/m8, r8
// AND r/m16, r16
extern ExecuteStatus ExecuteBooleanAndRegisterToRegisterOrMemory(
    const InstructionContext* ctx);
// AND r8, r/m8
// AND r16, r/m16
extern ExecuteStatus ExecuteBooleanAndRegisterOrMemoryToRegister(
    const InstructionContext* ctx);
// AND AL, imm8
// AND AX, imm16
extern ExecuteStatus ExecuteBooleanAndImmediateToALOrAX(
    const InstructionContext* ctx);
// OR r/m8, r8
// OR r/m16, r16
extern ExecuteStatus ExecuteBooleanOrRegisterToRegisterOrMemory(
    const InstructionContext* ctx);
// OR r8, r/m8
// OR r16, r/m16
extern ExecuteStatus ExecuteBooleanOrRegisterOrMemoryToRegister(
    const InstructionContext* ctx);
// OR AL, imm8
// OR AX, imm16
extern ExecuteStatus ExecuteBooleanOrImmediateToALOrAX(
    const InstructionContext* ctx);
// XOR r/m8, r8
// XOR r/m16, r16
extern ExecuteStatus ExecuteBooleanXorRegisterToRegisterOrMemory(
    const InstructionContext* ctx);
// XOR r8, r/m8
// XOR r16, r/m16
extern ExecuteStatus ExecuteBooleanXorRegisterOrMemoryToRegister(
    const InstructionContext* ctx);
// XOR AL, imm8
// XOR AX, imm16
extern ExecuteStatus ExecuteBooleanXorImmediateToALOrAX(
    const InstructionContext* ctx);
// TEST r/m8, r8
// TEST r/m16, r16
extern ExecuteStatus ExecuteTestRegisterToRegisterOrMemory(
    const InstructionContext* ctx);
// TEST AL, imm8
// TEST AX, imm16
extern ExecuteStatus ExecuteTestImmediateToALOrAX(
    const InstructionContext* ctx);

// ============================================================================
// Control flow instructions - instructions_ctrl_flow.c
// ============================================================================

// Common logic for far jumps.
extern ExecuteStatus ExecuteFarJump(
    const InstructionContext* ctx, const OperandValue* segment,
    const OperandValue* offset);
// Common logic for far calls.
extern ExecuteStatus ExecuteFarCall(
    const InstructionContext* ctx, const OperandValue* segment,
    const OperandValue* offset);
// Common logic for returning from an interrupt.
extern ExecuteStatus ExecuteReturnFromInterrupt(CPUState* cpu);

// JMP rel8
// JMP rel16
extern ExecuteStatus ExecuteShortOrNearJump(const InstructionContext* ctx);
// JMP ptr16:16
extern ExecuteStatus ExecuteDirectFarJump(const InstructionContext* ctx);
// Unsigned conditional jumps.
extern ExecuteStatus ExecuteUnsignedConditionalJump(
    const InstructionContext* ctx);
// JL/JGNE and JNL/JGE
extern ExecuteStatus ExecuteSignedConditionalJumpJLOrJNL(
    const InstructionContext* ctx);
// JLE/JG and JNLE/JG
extern ExecuteStatus ExecuteSignedConditionalJumpJLEOrJNLE(
    const InstructionContext* ctx);
// LOOP rel8
extern ExecuteStatus ExecuteLoop(const InstructionContext* ctx);
// LOOPZ rel8
// LOOPNZ rel8
extern ExecuteStatus ExecuteLoopZOrNZ(const InstructionContext* ctx);
// JCXZ rel8
extern ExecuteStatus ExecuteJumpIfCXIsZero(const InstructionContext* ctx);
// CALL rel16
extern ExecuteStatus ExecuteDirectNearCall(const InstructionContext* ctx);
// CALL ptr16:16
extern ExecuteStatus ExecuteDirectFarCall(const InstructionContext* ctx);
// RET
extern ExecuteStatus ExecuteNearReturn(const InstructionContext* ctx);
// RET imm16
extern ExecuteStatus ExecuteNearReturnAndPop(const InstructionContext* ctx);
// RETF
extern ExecuteStatus ExecuteFarReturn(const InstructionContext* ctx);
// RETF imm16
extern ExecuteStatus ExecuteFarReturnAndPop(const InstructionContext* ctx);
// IRET
extern ExecuteStatus ExecuteIret(const InstructionContext* ctx);
// INT 3
extern ExecuteStatus ExecuteInt3(const InstructionContext* ctx);
// INTO
extern ExecuteStatus ExecuteInto(const InstructionContext* ctx);
// INT n
extern ExecuteStatus ExecuteIntN(const InstructionContext* ctx);
// HLT
extern ExecuteStatus ExecuteHlt(const InstructionContext* ctx);

// ============================================================================
// Stack instructions - instructions_stack.c
// ============================================================================

// PUSH AX/CX/DX/BX/SP/BP/SI/DI
extern ExecuteStatus ExecutePushRegister(const InstructionContext* ctx);
// POP AX/CX/DX/BX/SP/BP/SI/DI
extern ExecuteStatus ExecutePopRegister(const InstructionContext* ctx);
// PUSH ES/CS/SS/DS
extern ExecuteStatus ExecutePushSegmentRegister(const InstructionContext* ctx);
// POP ES/CS/SS/DS
extern ExecuteStatus ExecutePopSegmentRegister(const InstructionContext* ctx);
// PUSHF
extern ExecuteStatus ExecutePushFlags(const InstructionContext* ctx);
// POPF
extern ExecuteStatus ExecutePopFlags(const InstructionContext* ctx);
// POP r/m16
extern ExecuteStatus ExecutePopRegisterOrMemory(const InstructionContext* ctx);
// LAHF
extern ExecuteStatus ExecuteLoadAHFromFlags(const InstructionContext* ctx);
// SAHF
extern ExecuteStatus ExecuteStoreAHToFlags(const InstructionContext* ctx);

// ============================================================================
// Flag manipulation instructions - instructions_flags.c
// ============================================================================

// CLC, STC, CLI, STI, CLD, STD
extern ExecuteStatus ExecuteClearOrSetFlag(const InstructionContext* ctx);
// CMC
extern ExecuteStatus ExecuteComplementCarryFlag(const InstructionContext* ctx);

// ============================================================================
// IN and OUT instructions - instructions_io.c
// ============================================================================

// IN AL, imm8
// IN AX, imm8
extern ExecuteStatus ExecuteInImmediate(const InstructionContext* ctx);
// IN AL, DX
// IN AX, DX
extern ExecuteStatus ExecuteInDX(const InstructionContext* ctx);
// OUT imm8, AL
// OUT imm8, AX
extern ExecuteStatus ExecuteOutImmediate(const InstructionContext* ctx);
// OUT DX, AL
// OUT DX, AX
extern ExecuteStatus ExecuteOutDX(const InstructionContext* ctx);

// ============================================================================
// String instructions - instructions_string.c
// ============================================================================

// MOVS
extern ExecuteStatus ExecuteMovs(const InstructionContext* ctx);
// STOS
extern ExecuteStatus ExecuteStos(const InstructionContext* ctx);
// LODS
extern ExecuteStatus ExecuteLods(const InstructionContext* ctx);
// SCAS
extern ExecuteStatus ExecuteScas(const InstructionContext* ctx);
// CMPS
extern ExecuteStatus ExecuteCmps(const InstructionContext* ctx);

// ============================================================================
// BCD and ASCII arithmetic instructions - instructions_bcd_ascii.c
// ============================================================================

// AAA
extern ExecuteStatus ExecuteAaa(const InstructionContext* ctx);
// AAS
extern ExecuteStatus ExecuteAas(const InstructionContext* ctx);
// AAM
extern ExecuteStatus ExecuteAam(const InstructionContext* ctx);
// AAD
extern ExecuteStatus ExecuteAad(const InstructionContext* ctx);
// DAA
extern ExecuteStatus ExecuteDaa(const InstructionContext* ctx);
// DAS
extern ExecuteStatus ExecuteDas(const InstructionContext* ctx);

// ============================================================================
// Group 1 instructions - instructions_group_1.c
// ============================================================================

// Group 1 instruction handler.
extern ExecuteStatus ExecuteGroup1Instruction(const InstructionContext* ctx);

// Group 1 instruction handler, but sign-extends the 8-bit immediate value.
extern ExecuteStatus ExecuteGroup1InstructionWithSignExtension(
    const InstructionContext* ctx);

// ============================================================================
// Group 2 instructions - instructions_group_2.c
// ============================================================================

// Group 2 shift / rotate by 1.
extern ExecuteStatus ExecuteGroup2ShiftOrRotateBy1Instruction(
    const InstructionContext* ctx);
// Group 2 shift / rotate by CL.
extern ExecuteStatus ExecuteGroup2ShiftOrRotateByCLInstruction(
    const InstructionContext* ctx);

// ============================================================================
// Group 3 instructions - instructions_group_3.c
// ============================================================================

// Group 3 instruction handler.
extern ExecuteStatus ExecuteGroup3Instruction(const InstructionContext* ctx);

// ============================================================================
// Group 4 instructions - instructions_group_4.c
// ============================================================================

// Group 4 instruction handler.
extern ExecuteStatus ExecuteGroup4Instruction(const InstructionContext* ctx);

// ============================================================================
// Group 5 instructions - instructions_group_5.c
// ============================================================================

// Group 5 instruction handler.
extern ExecuteStatus ExecuteGroup5Instruction(const InstructionContext* ctx);

#endif  // YAX86_IMPLEMENTATION

#endif  // YAX86_CPU_INSTRUCTIONS_H


// ==============================================================================
// src/cpu/instructions.h end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_helpers.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_helpers.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// Set common CPU flags after an instruction. This includes:
// - Zero flag (ZF)
// - Sign flag (SF)
// - Parity Flag (PF)
YAX86_PRIVATE void SetCommonFlagsAfterInstruction(
    const InstructionContext* ctx, uint32_t result) {
  Width width = ctx->metadata->width;
  result &= kMaxValue[width];
  // Zero flag (ZF)
  CPUSetFlag(ctx->cpu, kZF, result == 0);
  // Sign flag (SF)
  CPUSetFlag(ctx->cpu, kSF, result & kSignBit[width]);
  // Parity flag (PF)
  // Set if the number of set bits in the least significant byte is even
  uint8_t parity = result & 0xFF;  // Check only the low byte for parity
  parity ^= parity >> 4;
  parity ^= parity >> 2;
  parity ^= parity >> 1;
  CPUSetFlag(ctx->cpu, kPF, (parity & 1) == 0);
}

YAX86_PRIVATE void Push(CPUState* cpu, OperandValue value) {
  cpu->registers[kSP] -= 2;
  OperandAddress address = {
      .type = kOperandAddressTypeMemory,
      .value = {
          .memory_address = {
              .segment_register_index = kSS,
              .offset = cpu->registers[kSP],
          }}};
  WriteMemoryOperandWord(cpu, &address, value);
}

YAX86_PRIVATE OperandValue Pop(CPUState* cpu) {
  OperandAddress address = {
      .type = kOperandAddressTypeMemory,
      .value = {
          .memory_address = {
              .segment_register_index = kSS,
              .offset = cpu->registers[kSP],
          }}};
  OperandValue value = ReadMemoryOperandWord(cpu, &address);
  cpu->registers[kSP] += 2;
  return value;
}

// Dummy instruction for unsupported opcodes.
YAX86_PRIVATE ExecuteStatus ExecuteNoOp(const InstructionContext* ctx) {
  (void)ctx;
  return kExecuteSuccess;
}


// ==============================================================================
// src/cpu/instructions_helpers.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_mov.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_mov.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// MOV instructions
// ============================================================================

// MOV r/m8, r8
// MOV r/m16, r16
YAX86_PRIVATE ExecuteStatus
ExecuteMoveRegisterToRegisterOrMemory(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  Operand src = ReadRegisterOperand(ctx);
  WriteOperand(ctx, &dest, FromOperand(&src));
  return kExecuteSuccess;
}

// MOV r8, r/m8
// MOV r16, r/m16
YAX86_PRIVATE ExecuteStatus
ExecuteMoveRegisterOrMemoryToRegister(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperand(ctx);
  Operand src = ReadRegisterOrMemoryOperand(ctx);
  WriteOperand(ctx, &dest, FromOperand(&src));
  return kExecuteSuccess;
}

// MOV r/m16, sreg
YAX86_PRIVATE ExecuteStatus
ExecuteMoveSegmentRegisterToRegisterOrMemory(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  Operand src = ReadSegmentRegisterOperand(ctx);
  WriteOperand(ctx, &dest, FromOperand(&src));
  return kExecuteSuccess;
}

// MOV sreg, r/m16
YAX86_PRIVATE ExecuteStatus
ExecuteMoveRegisterOrMemoryToSegmentRegister(const InstructionContext* ctx) {
  Operand dest = ReadSegmentRegisterOperand(ctx);
  Operand src = ReadRegisterOrMemoryOperand(ctx);
  WriteOperand(ctx, &dest, FromOperand(&src));
  return kExecuteSuccess;
}

// MOV AX/CX/DX/BX/SP/BP/SI/DI, imm16
// MOV AH/AL/CH/CL/DH/DL/BH/BL, imm8
YAX86_PRIVATE ExecuteStatus
ExecuteMoveImmediateToRegister(const InstructionContext* ctx) {
  static const uint8_t register_index_opcode_base[kNumWidths] = {
      0xB0,  // kByte
      0xB8,  // kWord
  };
  RegisterIndex register_index =
      (RegisterIndex)(ctx->instruction->opcode -
                      register_index_opcode_base[ctx->metadata->width]);
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, register_index);
  OperandValue src_value = ReadImmediate(ctx);
  WriteOperand(ctx, &dest, FromOperandValue(&src_value));
  return kExecuteSuccess;
}

// MOV AL, moffs16
// MOV AX, moffs16
YAX86_PRIVATE ExecuteStatus
ExecuteMoveMemoryOffsetToALOrAX(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  // Offset is always 16 bits, even though the data width of the operation may
  // be 8 bits.
  OperandValue src_offset_value =
      kReadImmediateValueFn[kWord](ctx->instruction);
  OperandAddress src_address = {
      .type = kOperandAddressTypeMemory,
      .value = {
          .memory_address = {
              .segment_register_index = kDS,
              .offset = (uint16_t)FromOperandValue(&src_offset_value),
          }}};
  OperandValue src_value = ReadOperandValue(ctx, &src_address);
  WriteOperand(ctx, &dest, FromOperandValue(&src_value));
  return kExecuteSuccess;
}

// MOV moffs16, AL
// MOV moffs16, AX
YAX86_PRIVATE ExecuteStatus
ExecuteMoveALOrAXToMemoryOffset(const InstructionContext* ctx) {
  Operand src = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  // Offset is always 16 bits, even though the data width of the operation may
  // be 8 bits.
  OperandValue dest_offset_value =
      kReadImmediateValueFn[kWord](ctx->instruction);
  OperandAddress dest_address = {
      .type = kOperandAddressTypeMemory,
      .value = {
          .memory_address = {
              .segment_register_index = kDS,
              .offset = (uint16_t)FromOperandValue(&dest_offset_value),
          }}};
  WriteOperandAddress(ctx, &dest_address, FromOperand(&src));
  return kExecuteSuccess;
}

// MOV r/m8, imm8
// MOV r/m16, imm16
YAX86_PRIVATE ExecuteStatus
ExecuteMoveImmediateToRegisterOrMemory(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  OperandValue src_value = ReadImmediate(ctx);
  WriteOperand(ctx, &dest, FromOperandValue(&src_value));
  return kExecuteSuccess;
}

// ============================================================================
// XCHG instructions
// ============================================================================

// XCHG AX, AX/CX/DX/BX/SP/BP/SI/DI
YAX86_PRIVATE ExecuteStatus
ExecuteExchangeRegister(const InstructionContext* ctx) {
  RegisterIndex register_index =
      (RegisterIndex)(ctx->instruction->opcode - 0x90);
  if (register_index == kAX) {
    // No-op
    return kExecuteSuccess;
  }
  Operand src = ReadRegisterOperandForRegisterIndex(ctx, register_index);
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  uint32_t temp = FromOperand(&dest);
  WriteOperand(ctx, &dest, FromOperand(&src));
  WriteOperand(ctx, &src, temp);
  return kExecuteSuccess;
}

// XCHG r/m8, r8
// XCHG r/m16, r16
YAX86_PRIVATE ExecuteStatus
ExecuteExchangeRegisterOrMemory(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  Operand src = ReadRegisterOperand(ctx);
  uint32_t temp = FromOperand(&dest);
  WriteOperand(ctx, &dest, FromOperand(&src));
  WriteOperand(ctx, &src, temp);
  return kExecuteSuccess;
}

// ============================================================================
// XLAT
// ============================================================================

// XLAT
YAX86_PRIVATE ExecuteStatus
ExecuteTranslateByte(const InstructionContext* ctx) {
  // Read the AL register
  Operand al = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  OperandAddress src_address = {
      .type = kOperandAddressTypeMemory,
      .value =
          {.memory_address =
               {
                   .segment_register_index = kDS,
                   .offset =
                       (uint16_t)(ctx->cpu->registers[kBX] + FromOperand(&al)),
               }},
  };
  OperandValue src_value = ReadMemoryOperandByte(ctx->cpu, &src_address);
  WriteOperandAddress(ctx, &al.address, FromOperandValue(&src_value));
  return kExecuteSuccess;
}


// ==============================================================================
// src/cpu/instructions_mov.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_lea.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_lea.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// LEA instruction
// ============================================================================

// LEA r16, m
YAX86_PRIVATE ExecuteStatus
ExecuteLoadEffectiveAddress(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperand(ctx);
  MemoryAddress memory_address =
      GetMemoryOperandAddress(ctx->cpu, ctx->instruction);
  uint32_t raw_address = ToRawAddress(ctx->cpu, &memory_address);
  WriteOperandAddress(ctx, &dest.address, raw_address);
  return kExecuteSuccess;
}

// ============================================================================
// LES and LDS instructions
// ============================================================================

// Common logic for LES and LDS instructions.
static ExecuteStatus ExecuteLoadSegmentWithPointer(
    const InstructionContext* ctx, RegisterIndex segment_register_index) {
  Operand destRegister = ReadRegisterOperand(ctx);
  Operand destSegmentRegister =
      ReadRegisterOperandForRegisterIndex(ctx, segment_register_index);

  OperandAddress src_address = {
      .type = kOperandAddressTypeMemory,
      .value = {
          .memory_address = GetMemoryOperandAddress(ctx->cpu, ctx->instruction),
      }};
  OperandValue src_offset_value = ReadMemoryOperandWord(ctx->cpu, &src_address);
  src_address.value.memory_address.offset += 2;
  OperandValue src_segment_value =
      ReadMemoryOperandWord(ctx->cpu, &src_address);

  WriteOperand(ctx, &destRegister, FromOperandValue(&src_offset_value));
  WriteOperand(ctx, &destSegmentRegister, FromOperandValue(&src_segment_value));
  return kExecuteSuccess;
}

// LES r16, m
YAX86_PRIVATE ExecuteStatus
ExecuteLoadESWithPointer(const InstructionContext* ctx) {
  return ExecuteLoadSegmentWithPointer(ctx, kES);
}

// LDS r16, m
YAX86_PRIVATE ExecuteStatus
ExecuteLoadDSWithPointer(const InstructionContext* ctx) {
  return ExecuteLoadSegmentWithPointer(ctx, kDS);
}


// ==============================================================================
// src/cpu/instructions_lea.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_add.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_add.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// ADD, ADC, and INC instructions
// ============================================================================

// Set CPU flags after an INC instruction.
// Other than common flags, the INC instruction sets the following flags:
// - Overflow Flag (OF) - Set when result has wrong sign
// - Auxiliary Carry Flag (AF) - carry from bit 3 to bit 4
static void SetFlagsAfterInc(
    const InstructionContext* ctx, uint32_t op1, uint32_t op2, uint32_t result,
    bool did_carry) {
  SetCommonFlagsAfterInstruction(ctx, result);

  // Overflow Flag (OF) Set when result has wrong sign (both operands have same
  // sign but result has different sign)
  uint32_t sign_bit = kSignBit[ctx->metadata->width];
  bool op1_sign = (op1 & sign_bit) != 0;
  bool op2_sign = (op2 & sign_bit) != 0;
  bool result_sign = (result & sign_bit) != 0;
  CPUSetFlag(ctx->cpu, kOF, (op1_sign == op2_sign) && (result_sign != op1_sign));

  // Auxiliary Carry Flag (AF) - carry from bit 3 to bit 4
  CPUSetFlag(
      ctx->cpu, kAF, ((op1 & 0xF) + (op2 & 0xF) + (did_carry ? 1 : 0)) > 0xF);
}

// Set CPU flags after an ADD or ADC instruction.
// Other than the flags set by the INC instruction, the ADD instruction sets the
// following flags:
// - Carry Flag (CF) - Set when result overflows the maximum width
static void SetFlagsAfterAdd(
    const InstructionContext* ctx, uint32_t op1, uint32_t op2, uint32_t result,
    bool did_carry) {
  SetFlagsAfterInc(ctx, op1, op2, result, did_carry);
  // Carry Flag (CF)
  CPUSetFlag(ctx->cpu, kCF, result > kMaxValue[ctx->metadata->width]);
}

// Common signature of SetFlagsAfterAdd and SetFlagsAfterInc.
typedef void (*SetFlagsAfterAddFn)(
    const InstructionContext* ctx, uint32_t op1, uint32_t op2, uint32_t result,
    bool did_carry);

// Common logic for ADD, ADC, and INC instructions.
static ExecuteStatus ExecuteAddCommon(
    const InstructionContext* ctx, Operand* dest, const OperandValue* src_value,
    bool carry, SetFlagsAfterAddFn set_flags_after_fn) {
  uint32_t raw_dest_value = FromOperand(dest);
  uint32_t raw_src_value = FromOperandValue(src_value);
  bool should_carry = carry && CPUGetFlag(ctx->cpu, kCF);
  uint32_t result = raw_dest_value + raw_src_value + (should_carry ? 1 : 0);
  WriteOperand(ctx, dest, result);
  (*set_flags_after_fn)(
      ctx, raw_dest_value, raw_src_value, result, should_carry);
  return kExecuteSuccess;
}

// Common logic for ADD instructions
YAX86_PRIVATE ExecuteStatus ExecuteAdd(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value) {
  return ExecuteAddCommon(
      ctx, dest, src_value, /* carry */ false, SetFlagsAfterAdd);
}

// ADD r/m8, r8
// ADD r/m16, r16
YAX86_PRIVATE ExecuteStatus
ExecuteAddRegisterToRegisterOrMemory(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  Operand src = ReadRegisterOperand(ctx);
  return ExecuteAdd(ctx, &dest, &src.value);
}

// ADD r8, r/m8
// ADD r16, r/m16
YAX86_PRIVATE ExecuteStatus
ExecuteAddRegisterOrMemoryToRegister(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperand(ctx);
  Operand src = ReadRegisterOrMemoryOperand(ctx);
  return ExecuteAdd(ctx, &dest, &src.value);
}

// ADD AL, imm8
// ADD AX, imm16
YAX86_PRIVATE ExecuteStatus
ExecuteAddImmediateToALOrAX(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  OperandValue src_value = ReadImmediate(ctx);
  return ExecuteAdd(ctx, &dest, &src_value);
}

// Common logic for ADC instructions
YAX86_PRIVATE ExecuteStatus ExecuteAddWithCarry(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value) {
  return ExecuteAddCommon(
      ctx, dest, src_value, /* carry */ true, SetFlagsAfterAdd);
}

// ADC r/m8, r8
// ADC r/m16, r16
YAX86_PRIVATE ExecuteStatus
ExecuteAddRegisterToRegisterOrMemoryWithCarry(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  Operand src = ReadRegisterOperand(ctx);
  return ExecuteAddWithCarry(ctx, &dest, &src.value);
}
// ADC r8, r/m8
// ADC r16, r/m16
YAX86_PRIVATE ExecuteStatus
ExecuteAddRegisterOrMemoryToRegisterWithCarry(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperand(ctx);
  Operand src = ReadRegisterOrMemoryOperand(ctx);
  return ExecuteAddWithCarry(ctx, &dest, &src.value);
}

// ADC AL, imm8
// ADC AX, imm16
YAX86_PRIVATE ExecuteStatus
ExecuteAddImmediateToALOrAXWithCarry(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  OperandValue src_value = ReadImmediate(ctx);
  return ExecuteAddWithCarry(ctx, &dest, &src_value);
}

// Common logic for INC instructions
YAX86_PRIVATE ExecuteStatus
ExecuteInc(const InstructionContext* ctx, Operand* dest) {
  OperandValue src_value = WordValue(1);
  return ExecuteAddCommon(
      ctx, dest, &src_value, /* carry */ false, SetFlagsAfterInc);
}

// INC AX/CX/DX/BX/SP/BP/SI/DI
YAX86_PRIVATE ExecuteStatus ExecuteIncRegister(const InstructionContext* ctx) {
  RegisterIndex register_index =
      (RegisterIndex)(ctx->instruction->opcode - 0x40);
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, register_index);
  return ExecuteInc(ctx, &dest);
}


// ==============================================================================
// src/cpu/instructions_add.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_sub.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_sub.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// SUB, SBB, and DEC instructions
// ============================================================================

// Set CPU flags after a DEC or SUB/SBB operation (base function).
// This function sets ZF, SF, PF, OF, AF. It does NOT affect CF.
// - OF is for the full operation op1 - (op2 + did_borrow).
// - AF is for the full operation op1 - (op2 + did_borrow).
static void SetFlagsAfterDec(
    const InstructionContext* ctx, uint32_t op1, uint32_t op2, uint32_t result,
    bool did_borrow) {
  SetCommonFlagsAfterInstruction(ctx, result);

  uint32_t sign_bit = kSignBit[ctx->metadata->width];
  uint32_t max_val = kMaxValue[ctx->metadata->width];

  // Overflow Flag (OF)
  // OF is set if op1_sign != val_being_subtracted_sign AND result_sign ==
  // val_being_subtracted_sign where val_being_subtracted = (op2 + did_borrow)
  bool op1_sign = (op1 & sign_bit) != 0;
  bool result_sign = (result & sign_bit) != 0;
  uint32_t val_being_subtracted = (op2 & max_val) + (did_borrow ? 1 : 0);
  // Mask val_being_subtracted to current width before checking its sign,
  // in case (op2 & max_val) + 1 caused a temporary overflow beyond max_val if
  // op2 was max_val.
  bool val_being_subtracted_sign =
      ((val_being_subtracted & max_val) & sign_bit) != 0;
  CPUSetFlag(
      ctx->cpu, kOF,
      (op1_sign != val_being_subtracted_sign) &&
          (result_sign == val_being_subtracted_sign));

  // Auxiliary Carry Flag (AF) - borrow from bit 3 to bit 4
  CPUSetFlag(ctx->cpu, kAF, (op1 & 0xF) < ((op2 & 0xF) + (did_borrow ? 1 : 0)));
}

// Set CPU flags after a SUB, SBB, CMP or NEG instruction.
// This calls SetFlagsAfterDec and then sets the Carry Flag (CF).
YAX86_PRIVATE void SetFlagsAfterSub(
    const InstructionContext* ctx, uint32_t op1, uint32_t op2, uint32_t result,
    bool did_borrow) {
  SetFlagsAfterDec(ctx, op1, op2, result, did_borrow);

  // Carry Flag (CF) - Set when a borrow is generated
  // CF is set if op1 < (op2 + did_borrow) (unsigned comparison)
  uint32_t val_being_subtracted =
      (op2 & kMaxValue[ctx->metadata->width]) + (did_borrow ? 1 : 0);
  CPUSetFlag(ctx->cpu, kCF, op1 < val_being_subtracted);
}

// Common signature of SetFlagsAfterSub and SetFlagsAfterDec.
typedef void (*SetFlagsAfterSubFn)(
    const InstructionContext* ctx, uint32_t op1, uint32_t op2, uint32_t result,
    bool did_borrow);

// Common logic for SUB, SBB, and DEC instructions.
static ExecuteStatus ExecuteSubCommon(
    const InstructionContext* ctx, Operand* dest, const OperandValue* src_value,
    bool borrow, SetFlagsAfterSubFn set_flags_after_fn) {
  uint32_t raw_dest_value = FromOperand(dest);
  uint32_t raw_src_value = FromOperandValue(src_value);
  bool should_borrow = borrow && CPUGetFlag(ctx->cpu, kCF);
  uint32_t result = raw_dest_value - raw_src_value - (should_borrow ? 1 : 0);
  WriteOperand(ctx, dest, result);
  (*set_flags_after_fn)(
      ctx, raw_dest_value, raw_src_value, result, should_borrow);
  return kExecuteSuccess;
}

// Common logic for SUB instructions
YAX86_PRIVATE ExecuteStatus ExecuteSub(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value) {
  return ExecuteSubCommon(
      ctx, dest, src_value, /* borrow */ false, SetFlagsAfterSub);
}

// SUB r/m8, r8
// SUB r/m16, r16
YAX86_PRIVATE ExecuteStatus
ExecuteSubRegisterFromRegisterOrMemory(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  Operand src = ReadRegisterOperand(ctx);
  return ExecuteSub(ctx, &dest, &src.value);
}

// SUB r8, r/m8
// SUB r16, r/m16
YAX86_PRIVATE ExecuteStatus
ExecuteSubRegisterOrMemoryFromRegister(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperand(ctx);
  Operand src = ReadRegisterOrMemoryOperand(ctx);
  return ExecuteSub(ctx, &dest, &src.value);
}

// SUB AL, imm8
// SUB AX, imm16
YAX86_PRIVATE ExecuteStatus
ExecuteSubImmediateFromALOrAX(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  OperandValue src_value = ReadImmediate(ctx);
  return ExecuteSub(ctx, &dest, &src_value);
}

// Common logic for SBB instructions
YAX86_PRIVATE ExecuteStatus ExecuteSubWithBorrow(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value) {
  return ExecuteSubCommon(
      ctx, dest, src_value, /* borrow */ true, SetFlagsAfterSub);
}

// SBB r/m8, r8
// SBB r/m16, r16
YAX86_PRIVATE ExecuteStatus ExecuteSubRegisterFromRegisterOrMemoryWithBorrow(
    const InstructionContext* ctx) {
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  Operand src = ReadRegisterOperand(ctx);
  return ExecuteSubWithBorrow(ctx, &dest, &src.value);
}

// SBB r8, r/m8
// SBB r16, r/m16
YAX86_PRIVATE ExecuteStatus ExecuteSubRegisterOrMemoryFromRegisterWithBorrow(
    const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperand(ctx);
  Operand src = ReadRegisterOrMemoryOperand(ctx);
  return ExecuteSubWithBorrow(ctx, &dest, &src.value);
}

// SBB AL, imm8
// SBB AX, imm16
YAX86_PRIVATE ExecuteStatus
ExecuteSubImmediateFromALOrAXWithBorrow(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  OperandValue src_value = ReadImmediate(ctx);
  return ExecuteSubWithBorrow(ctx, &dest, &src_value);
}

// Common logic for DEC instructions
YAX86_PRIVATE ExecuteStatus
ExecuteDec(const InstructionContext* ctx, Operand* dest) {
  OperandValue src_value = WordValue(1);
  return ExecuteSubCommon(
      ctx, dest, &src_value, /* borrow */ false, SetFlagsAfterDec);
}

// DEC AX/CX/DX/BX/SP/BP/SI/DI
YAX86_PRIVATE ExecuteStatus ExecuteDecRegister(const InstructionContext* ctx) {
  RegisterIndex register_index =
      (RegisterIndex)(ctx->instruction->opcode - 0x48);
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, register_index);
  return ExecuteDec(ctx, &dest);
}


// ==============================================================================
// src/cpu/instructions_sub.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_sign_ext.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_sign_ext.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// Sign extension instructions
// ============================================================================

// CBW
YAX86_PRIVATE ExecuteStatus ExecuteCbw(const InstructionContext* ctx) {
  uint8_t al = ctx->cpu->registers[kAX] & 0xFF;
  uint8_t ah = (al & kSignBit[kByte]) ? 0xFF : 0x00;
  ctx->cpu->registers[kAX] = (ah << 8) | al;
  return kExecuteSuccess;
}

// CWD
YAX86_PRIVATE ExecuteStatus ExecuteCwd(const InstructionContext* ctx) {
  ctx->cpu->registers[kDX] =
      (ctx->cpu->registers[kAX] & kSignBit[kWord]) ? 0xFFFF : 0x0000;
  return kExecuteSuccess;
}


// ==============================================================================
// src/cpu/instructions_sign_ext.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_cmp.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_cmp.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// CMP instructions
// ============================================================================

// Common logic for CMP instructions. Computes dest - src and sets flags.
YAX86_PRIVATE ExecuteStatus ExecuteCmp(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value) {
  uint32_t raw_dest_value = FromOperand(dest);
  uint32_t raw_src_value = FromOperandValue(src_value);
  uint32_t result = raw_dest_value - raw_src_value;
  SetFlagsAfterSub(ctx, raw_dest_value, raw_src_value, result, false);
  return kExecuteSuccess;
}

// CMP r/m8, r8
// CMP r/m16, r16
YAX86_PRIVATE ExecuteStatus
ExecuteCmpRegisterToRegisterOrMemory(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  Operand src = ReadRegisterOperand(ctx);
  return ExecuteCmp(ctx, &dest, &src.value);
}

// CMP r8, r/m8
// CMP r16, r/m16
YAX86_PRIVATE ExecuteStatus
ExecuteCmpRegisterOrMemoryToRegister(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperand(ctx);
  Operand src = ReadRegisterOrMemoryOperand(ctx);
  return ExecuteCmp(ctx, &dest, &src.value);
}

// CMP AL, imm8
// CMP AX, imm16
YAX86_PRIVATE ExecuteStatus
ExecuteCmpImmediateToALOrAX(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  OperandValue src_value = ReadImmediate(ctx);
  return ExecuteCmp(ctx, &dest, &src_value);
}


// ==============================================================================
// src/cpu/instructions_cmp.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_bool.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_bool.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// Boolean AND, OR and XOR instructions
// ============================================================================

YAX86_PRIVATE void SetFlagsAfterBooleanInstruction(
    const InstructionContext* ctx, uint32_t result) {
  SetCommonFlagsAfterInstruction(ctx, result);
  // Carry Flag (CF) should be cleared
  CPUSetFlag(ctx->cpu, kCF, false);
  // Overflow Flag (OF) should be cleared
  CPUSetFlag(ctx->cpu, kOF, false);
}

// Common logic for AND instructions.
YAX86_PRIVATE ExecuteStatus ExecuteBooleanAnd(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value) {
  uint32_t result = FromOperand(dest) & FromOperandValue(src_value);
  WriteOperand(ctx, dest, result);
  SetFlagsAfterBooleanInstruction(ctx, result);
  return kExecuteSuccess;
}

// AND r/m8, r8
// AND r/m16, r16
YAX86_PRIVATE ExecuteStatus
ExecuteBooleanAndRegisterToRegisterOrMemory(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  Operand src = ReadRegisterOperand(ctx);
  return ExecuteBooleanAnd(ctx, &dest, &src.value);
}

// AND r8, r/m8
// AND r16, r/m16
YAX86_PRIVATE ExecuteStatus
ExecuteBooleanAndRegisterOrMemoryToRegister(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperand(ctx);
  Operand src = ReadRegisterOrMemoryOperand(ctx);
  return ExecuteBooleanAnd(ctx, &dest, &src.value);
}

// AND AL, imm8
// AND AX, imm16
YAX86_PRIVATE ExecuteStatus
ExecuteBooleanAndImmediateToALOrAX(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  OperandValue src_value = ReadImmediate(ctx);
  return ExecuteBooleanAnd(ctx, &dest, &src_value);
}

// Common logic for OR instructions.
YAX86_PRIVATE ExecuteStatus ExecuteBooleanOr(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value) {
  uint32_t result = FromOperand(dest) | FromOperandValue(src_value);
  WriteOperand(ctx, dest, result);
  SetFlagsAfterBooleanInstruction(ctx, result);
  return kExecuteSuccess;
}

// OR r/m8, r8
// OR r/m16, r16
YAX86_PRIVATE ExecuteStatus
ExecuteBooleanOrRegisterToRegisterOrMemory(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  Operand src = ReadRegisterOperand(ctx);
  return ExecuteBooleanOr(ctx, &dest, &src.value);
}

// OR r8, r/m8
// OR r16, r/m16
YAX86_PRIVATE ExecuteStatus
ExecuteBooleanOrRegisterOrMemoryToRegister(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperand(ctx);
  Operand src = ReadRegisterOrMemoryOperand(ctx);
  return ExecuteBooleanOr(ctx, &dest, &src.value);
}

// OR AL, imm8
// OR AX, imm16
YAX86_PRIVATE ExecuteStatus
ExecuteBooleanOrImmediateToALOrAX(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  OperandValue src_value = ReadImmediate(ctx);
  return ExecuteBooleanOr(ctx, &dest, &src_value);
}

// Common logic for XOR instructions.
YAX86_PRIVATE ExecuteStatus ExecuteBooleanXor(
    const InstructionContext* ctx, Operand* dest,
    const OperandValue* src_value) {
  uint32_t result = FromOperand(dest) ^ FromOperandValue(src_value);
  WriteOperand(ctx, dest, result);
  SetFlagsAfterBooleanInstruction(ctx, result);
  return kExecuteSuccess;
}

// XOR r/m8, r8
// XOR r/m16, r16
YAX86_PRIVATE ExecuteStatus
ExecuteBooleanXorRegisterToRegisterOrMemory(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  Operand src = ReadRegisterOperand(ctx);
  return ExecuteBooleanXor(ctx, &dest, &src.value);
}

// XOR r8, r/m8
// XOR r16, r/m16
YAX86_PRIVATE ExecuteStatus
ExecuteBooleanXorRegisterOrMemoryToRegister(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperand(ctx);
  Operand src = ReadRegisterOrMemoryOperand(ctx);
  return ExecuteBooleanXor(ctx, &dest, &src.value);
}

// XOR AL, imm8
// XOR AX, imm16
YAX86_PRIVATE ExecuteStatus
ExecuteBooleanXorImmediateToALOrAX(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  OperandValue src_value = ReadImmediate(ctx);
  return ExecuteBooleanXor(ctx, &dest, &src_value);
}

// ============================================================================
// TEST instructions
// ============================================================================

// Common logic for TEST instructions.
YAX86_PRIVATE ExecuteStatus ExecuteTest(
    const InstructionContext* ctx, Operand* dest, OperandValue* src_value) {
  uint32_t result = FromOperand(dest) & FromOperandValue(src_value);
  SetFlagsAfterBooleanInstruction(ctx, result);
  return kExecuteSuccess;
}

// TEST r/m8, r8
// TEST r/m16, r16
YAX86_PRIVATE ExecuteStatus
ExecuteTestRegisterToRegisterOrMemory(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  Operand src = ReadRegisterOperand(ctx);
  return ExecuteTest(ctx, &dest, &src.value);
}

// TEST AL, imm8
// TEST AX, imm16
YAX86_PRIVATE ExecuteStatus
ExecuteTestImmediateToALOrAX(const InstructionContext* ctx) {
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  OperandValue src_value = ReadImmediate(ctx);
  return ExecuteTest(ctx, &dest, &src_value);
}


// ==============================================================================
// src/cpu/instructions_bool.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_ctrl_flow.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_ctrl_flow.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// JMP instructions
// ============================================================================

// Jump to a relative signed byte offset.
static ExecuteStatus ExecuteRelativeJumpByte(
    const InstructionContext* ctx, const OperandValue* offset_value) {
  ctx->cpu->registers[kIP] = AddSignedOffsetByte(
      ctx->cpu->registers[kIP], FromOperandValue(offset_value));
  return kExecuteSuccess;
}

// Jump to a relative signed word offset.
static ExecuteStatus ExecuteRelativeJumpWord(
    const InstructionContext* ctx, const OperandValue* offset_value) {
  ctx->cpu->registers[kIP] = AddSignedOffsetWord(
      ctx->cpu->registers[kIP], FromOperandValue(offset_value));
  return kExecuteSuccess;
}

// Table of relative jump instructions, indexed by width.
static ExecuteStatus (*const kRelativeJumpFn[kNumWidths])(
    const InstructionContext* ctx, const OperandValue* offset_value) = {
    ExecuteRelativeJumpByte,  // kByte
    ExecuteRelativeJumpWord,  // kWord
};

// Common logic for JMP instructions.
static ExecuteStatus ExecuteRelativeJump(
    const InstructionContext* ctx, const OperandValue* offset_value) {
  return kRelativeJumpFn[ctx->metadata->width](ctx, offset_value);
}

// JMP rel8
// JMP rel16
YAX86_PRIVATE ExecuteStatus
ExecuteShortOrNearJump(const InstructionContext* ctx) {
  OperandValue offset_value = ReadImmediate(ctx);
  return ExecuteRelativeJump(ctx, &offset_value);
}

// Common logic for far jumps.
YAX86_PRIVATE ExecuteStatus ExecuteFarJump(
    const InstructionContext* ctx, const OperandValue* segment,
    const OperandValue* offset) {
  ctx->cpu->registers[kCS] = FromOperandValue(segment);
  ctx->cpu->registers[kIP] = FromOperandValue(offset);
  return kExecuteSuccess;
}

// JMP ptr16:16
YAX86_PRIVATE ExecuteStatus
ExecuteDirectFarJump(const InstructionContext* ctx) {
  OperandValue new_cs = WordValue(
      ((uint16_t)ctx->instruction->immediate[2]) |
      (((uint16_t)ctx->instruction->immediate[3]) << 8));
  OperandValue new_ip = WordValue(
      ((uint16_t)ctx->instruction->immediate[0]) |
      (((uint16_t)ctx->instruction->immediate[1]) << 8));
  return ExecuteFarJump(ctx, &new_cs, &new_ip);
}

// ============================================================================
// Conditional jumps
// ============================================================================

// Common logic for conditional jumps.
static ExecuteStatus ExecuteConditionalJump(
    const InstructionContext* ctx, bool value, bool success_value) {
  if (value == success_value) {
    OperandValue offset_value = ReadImmediate(ctx);
    return ExecuteRelativeJump(ctx, &offset_value);
  }
  return kExecuteSuccess;
}

// Table of flag register bitmasks for conditional jumps. The index corresponds
// to (opcode - 0x70) / 2.
static const uint16_t kUnsignedConditionalJumpFlagBitmasks[] = {
    kOF,        // 0x70 - JO, 0x71 - JNO
    kCF,        // 0x72 - JC, 0x73 - JNC
    kZF,        // 0x74 - JE, 0x75 - JNE
    kCF | kZF,  // 0x76 - JBE, 0x77 - JNBE
    kSF,        // 0x78 - JS, 0x79 - JNS
    kPF,        // 0x7A - JP, 0x7B - JNP
};

// Unsigned conditional jumps.
YAX86_PRIVATE ExecuteStatus
ExecuteUnsignedConditionalJump(const InstructionContext* ctx) {
  uint16_t flag_mask = kUnsignedConditionalJumpFlagBitmasks
      [(ctx->instruction->opcode - 0x70) / 2];
  bool flag_value = (ctx->cpu->flags & flag_mask) != 0;
  // Even opcode => jump if the flag is set
  // Odd opcode => jump if the flag is not set
  bool success_value = ((ctx->instruction->opcode & 0x1) == 0);
  return ExecuteConditionalJump(ctx, flag_value, success_value);
}

// JL/JGNE and JNL/JGE
YAX86_PRIVATE ExecuteStatus
ExecuteSignedConditionalJumpJLOrJNL(const InstructionContext* ctx) {
  const bool is_greater_or_equal =
      CPUGetFlag(ctx->cpu, kSF) == CPUGetFlag(ctx->cpu, kOF);
  const bool success_value = (ctx->instruction->opcode & 0x1);
  return ExecuteConditionalJump(ctx, is_greater_or_equal, success_value);
}

// JLE/JG and JNLE/JG
YAX86_PRIVATE ExecuteStatus
ExecuteSignedConditionalJumpJLEOrJNLE(const InstructionContext* ctx) {
  const bool is_greater =
      !CPUGetFlag(ctx->cpu, kZF) &&
      (CPUGetFlag(ctx->cpu, kSF) == CPUGetFlag(ctx->cpu, kOF));
  const bool success_value = (ctx->instruction->opcode & 0x1);
  return ExecuteConditionalJump(ctx, is_greater, success_value);
}

// ============================================================================
// Loop instructions
// ============================================================================

// LOOP rel8
YAX86_PRIVATE ExecuteStatus ExecuteLoop(const InstructionContext* ctx) {
  return ExecuteConditionalJump(ctx, --(ctx->cpu->registers[kCX]) != 0, true);
}

// LOOPZ rel8
// LOOPNZ rel8
YAX86_PRIVATE ExecuteStatus ExecuteLoopZOrNZ(const InstructionContext* ctx) {
  bool condition1 = --(ctx->cpu->registers[kCX]) != 0;
  bool condition2 =
      CPUGetFlag(ctx->cpu, kZF) == (bool)(ctx->instruction->opcode - 0xE0);
  return ExecuteConditionalJump(ctx, condition1 && condition2, true);
}

// JCXZ rel8
YAX86_PRIVATE ExecuteStatus
ExecuteJumpIfCXIsZero(const InstructionContext* ctx) {
  return ExecuteConditionalJump(ctx, ctx->cpu->registers[kCX] == 0, true);
}

// ============================================================================
// CALL and RET instructions
// ============================================================================

// Common logic for near calls.
static ExecuteStatus ExecuteNearCall(
    const InstructionContext* ctx, const OperandValue* offset) {
  Push(ctx->cpu, WordValue(ctx->cpu->registers[kIP]));
  return ExecuteRelativeJump(ctx, offset);
}

// CALL rel16
YAX86_PRIVATE ExecuteStatus
ExecuteDirectNearCall(const InstructionContext* ctx) {
  OperandValue offset = ReadImmediate(ctx);
  return ExecuteNearCall(ctx, &offset);
}

// Common logic for far calls.
YAX86_PRIVATE ExecuteStatus ExecuteFarCall(
    const InstructionContext* ctx, const OperandValue* segment,
    const OperandValue* offset) {
  // Push the current CS and IP onto the stack.
  Push(ctx->cpu, WordValue(ctx->cpu->registers[kCS]));
  Push(ctx->cpu, WordValue(ctx->cpu->registers[kIP]));
  return ExecuteFarJump(ctx, segment, offset);
}

// CALL ptr16:16
YAX86_PRIVATE ExecuteStatus
ExecuteDirectFarCall(const InstructionContext* ctx) {
  Push(ctx->cpu, WordValue(ctx->cpu->registers[kCS]));
  Push(ctx->cpu, WordValue(ctx->cpu->registers[kIP]));
  return ExecuteDirectFarJump(ctx);
}

// Common logic for RET instructions.
static ExecuteStatus ExecuteNearReturnCommon(
    const InstructionContext* ctx, uint16_t arg_size) {
  OperandValue new_ip = Pop(ctx->cpu);
  ctx->cpu->registers[kIP] = FromOperandValue(&new_ip);
  ctx->cpu->registers[kSP] += arg_size;
  return kExecuteSuccess;
}

// RET
YAX86_PRIVATE ExecuteStatus ExecuteNearReturn(const InstructionContext* ctx) {
  return ExecuteNearReturnCommon(ctx, 0);
}

// RET imm16
YAX86_PRIVATE ExecuteStatus
ExecuteNearReturnAndPop(const InstructionContext* ctx) {
  OperandValue arg_size_value = ReadImmediate(ctx);
  return ExecuteNearReturnCommon(ctx, FromOperandValue(&arg_size_value));
}

// Common logic for RETF instructions.
static ExecuteStatus ExecuteFarReturnCommon(
    const InstructionContext* ctx, uint16_t arg_size) {
  OperandValue new_ip = Pop(ctx->cpu);
  OperandValue new_cs = Pop(ctx->cpu);
  ctx->cpu->registers[kIP] = FromOperandValue(&new_ip);
  ctx->cpu->registers[kCS] = FromOperandValue(&new_cs);
  ctx->cpu->registers[kSP] += arg_size;
  return kExecuteSuccess;
}

// RETF
YAX86_PRIVATE ExecuteStatus ExecuteFarReturn(const InstructionContext* ctx) {
  return ExecuteFarReturnCommon(ctx, 0);
}

// RETF imm16
YAX86_PRIVATE ExecuteStatus
ExecuteFarReturnAndPop(const InstructionContext* ctx) {
  OperandValue arg_size_value = ReadImmediate(ctx);
  return ExecuteFarReturnCommon(ctx, FromOperandValue(&arg_size_value));
}

// ============================================================================
// Interrupt instructions
// ============================================================================

// Common logic for returning from an interrupt.
YAX86_PRIVATE ExecuteStatus ExecuteReturnFromInterrupt(CPUState* cpu) {
  OperandValue ip_value = Pop(cpu);
  cpu->registers[kIP] = FromOperandValue(&ip_value);
  OperandValue cs_value = Pop(cpu);
  cpu->registers[kCS] = FromOperandValue(&cs_value);
  OperandValue flags_value = Pop(cpu);
  cpu->flags = FromOperandValue(&flags_value);
  return kExecuteSuccess;
}

// IRET
YAX86_PRIVATE ExecuteStatus ExecuteIret(const InstructionContext* ctx) {
  return ExecuteReturnFromInterrupt(ctx->cpu);
}

// INT 3
YAX86_PRIVATE ExecuteStatus ExecuteInt3(const InstructionContext* ctx) {
  CPUSetPendingInterrupt(ctx->cpu, kInterruptBreakpoint);
  return kExecuteSuccess;
}

// INTO
YAX86_PRIVATE ExecuteStatus ExecuteInto(const InstructionContext* ctx) {
  if (CPUGetFlag(ctx->cpu, kOF)) {
    CPUSetPendingInterrupt(ctx->cpu, kInterruptOverflow);
  }
  return kExecuteSuccess;
}

// INT n
YAX86_PRIVATE ExecuteStatus ExecuteIntN(const InstructionContext* ctx) {
  OperandValue interrupt_number_value = ReadImmediate(ctx);
  CPUSetPendingInterrupt(ctx->cpu, FromOperandValue(&interrupt_number_value));
  return kExecuteSuccess;
}

// HLT
YAX86_PRIVATE ExecuteStatus
ExecuteHlt(YAX86_UNUSED const InstructionContext* ctx) {
  ctx->cpu->is_halted = true;
  return kExecuteHalt;
}


// ==============================================================================
// src/cpu/instructions_ctrl_flow.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_stack.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_stack.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// PUSH and POP instructions
// ============================================================================

// PUSH AX/CX/DX/BX/SP/BP/SI/DI
YAX86_PRIVATE ExecuteStatus ExecutePushRegister(const InstructionContext* ctx) {
  RegisterIndex register_index =
      (RegisterIndex)(ctx->instruction->opcode - 0x50);
  Operand src = ReadRegisterOperandForRegisterIndex(ctx, register_index);
  Push(ctx->cpu, src.value);
  return kExecuteSuccess;
}

// POP AX/CX/DX/BX/SP/BP/SI/DI
YAX86_PRIVATE ExecuteStatus ExecutePopRegister(const InstructionContext* ctx) {
  RegisterIndex register_index =
      (RegisterIndex)(ctx->instruction->opcode - 0x58);
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, register_index);
  OperandValue value = Pop(ctx->cpu);
  WriteOperandAddress(ctx, &dest.address, FromOperandValue(&value));
  return kExecuteSuccess;
}

// PUSH ES/CS/SS/DS
YAX86_PRIVATE ExecuteStatus
ExecutePushSegmentRegister(const InstructionContext* ctx) {
  RegisterIndex register_index =
      (RegisterIndex)(((ctx->instruction->opcode >> 3) & 0x03) + 8);
  Operand src = ReadRegisterOperandForRegisterIndex(ctx, register_index);
  Push(ctx->cpu, src.value);
  return kExecuteSuccess;
}

// POP ES/CS/SS/DS
YAX86_PRIVATE ExecuteStatus
ExecutePopSegmentRegister(const InstructionContext* ctx) {
  RegisterIndex register_index =
      (RegisterIndex)(((ctx->instruction->opcode >> 3) & 0x03) + 8);
  // Special case - disallow POP CS
  if (register_index == kCS) {
    return kExecuteInvalidInstruction;
  }
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, register_index);
  OperandValue value = Pop(ctx->cpu);
  WriteOperandAddress(ctx, &dest.address, FromOperandValue(&value));
  return kExecuteSuccess;
}

// PUSHF
YAX86_PRIVATE ExecuteStatus ExecutePushFlags(const InstructionContext* ctx) {
  Push(ctx->cpu, WordValue(ctx->cpu->flags));
  return kExecuteSuccess;
}

// POPF
YAX86_PRIVATE ExecuteStatus ExecutePopFlags(const InstructionContext* ctx) {
  OperandValue value = Pop(ctx->cpu);
  ctx->cpu->flags = FromOperandValue(&value);
  return kExecuteSuccess;
}

// POP r/m16
YAX86_PRIVATE ExecuteStatus
ExecutePopRegisterOrMemory(const InstructionContext* ctx) {
  if (ctx->instruction->mod_rm.reg != 0) {
    return kExecuteInvalidInstruction;
  }
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  OperandValue value = Pop(ctx->cpu);
  WriteOperandAddress(ctx, &dest.address, FromOperandValue(&value));
  return kExecuteSuccess;
}

// ============================================================================
// LAHF and SAHF
// ============================================================================

// Returns the AH register address.
static const OperandAddress* GetAHRegisterAddress(void) {
  static OperandAddress ah = {
      .type = kOperandAddressTypeRegister,
      .value = {
          .register_address = {
              .register_index = kAX,
              .byte_offset = 8,
          }}};
  return &ah;
}

// LAHF
YAX86_PRIVATE ExecuteStatus
ExecuteLoadAHFromFlags(const InstructionContext* ctx) {
  WriteRegisterOperandByte(
      ctx->cpu, GetAHRegisterAddress(), ByteValue(ctx->cpu->flags & 0x00FF));
  return kExecuteSuccess;
}

// SAHF
YAX86_PRIVATE ExecuteStatus
ExecuteStoreAHToFlags(const InstructionContext* ctx) {
  OperandValue value =
      ReadRegisterOperandByte(ctx->cpu, GetAHRegisterAddress());
  // Clear the lower byte of flags and set it to the value in AH
  ctx->cpu->flags = (ctx->cpu->flags & 0xFF00) | value.value.byte_value;
  return kExecuteSuccess;
}


// ==============================================================================
// src/cpu/instructions_stack.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_flags.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_flags.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// CLC, STC, CLI, STI, CLD, STD instructions
// ============================================================================

// Table of flags corresponding to the CLC, STC, CLI, STI, CLD, and STD
// instructions, indexed by (opcode - 0xF8) / 2.
static const Flag kFlagsForClearAndSetInstructions[] = {
    kCF,  // CLC, STC
    kIF,  // CLI, STI
    kDF,  // CLD, STD
};

YAX86_PRIVATE ExecuteStatus
ExecuteClearOrSetFlag(const InstructionContext* ctx) {
  uint8_t opcode_index = ctx->instruction->opcode - 0xF8;
  Flag flag = kFlagsForClearAndSetInstructions[opcode_index / 2];
  bool value = (opcode_index & 0x1) != 0;
  CPUSetFlag(ctx->cpu, flag, value);
  return kExecuteSuccess;
}

// ============================================================================
// CMC instruction
// ============================================================================

// CMC
YAX86_PRIVATE ExecuteStatus
ExecuteComplementCarryFlag(const InstructionContext* ctx) {
  CPUSetFlag(ctx->cpu, kCF, !CPUGetFlag(ctx->cpu, kCF));
  return kExecuteSuccess;
}


// ==============================================================================
// src/cpu/instructions_flags.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_io.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_io.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// IN and OUT instructions
// ============================================================================

// Read a byte from an I/O port.
static OperandValue ReadByteFromPort(CPUState* cpu, uint16_t port) {
  return ByteValue(
      cpu->config->read_port ? cpu->config->read_port(cpu, port) : 0xFF);
}

// Read a word from an I/O port as a uint16_t.
static OperandValue ReadWordFromPort(CPUState* cpu, uint16_t port) {
  uint8_t low = ReadByteFromPort(cpu, port).value.byte_value;
  uint8_t high = ReadByteFromPort(cpu, port).value.byte_value;
  return WordValue((high << 8) | low);
}

// Table of functions to read from an I/O port, indexed by data width.
static OperandValue (*const kReadFromPortFns[])(CPUState*, uint16_t) = {
    ReadByteFromPort,  // kByte
    ReadWordFromPort,  // kWord
};

// Common logic for IN instructions.
static ExecuteStatus ExecuteIn(const InstructionContext* ctx, uint16_t port) {
  OperandValue value = kReadFromPortFns[ctx->metadata->width](ctx->cpu, port);
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  WriteOperand(ctx, &dest, FromOperandValue(&value));
  return kExecuteSuccess;
}

// IN AL, imm8
// IN AX, imm8
YAX86_PRIVATE ExecuteStatus ExecuteInImmediate(const InstructionContext* ctx) {
  OperandValue port = ReadImmediateOperandByte(ctx->instruction);
  return ExecuteIn(ctx, FromOperandValue(&port));
}

// IN AL, DX
// IN AX, DX
YAX86_PRIVATE ExecuteStatus ExecuteInDX(const InstructionContext* ctx) {
  return ExecuteIn(ctx, ctx->cpu->registers[kDX]);
}

// Write a byte to an I/O port.
static void WriteByteToPort(CPUState* cpu, uint16_t port, OperandValue value) {
  if (!cpu->config->write_port) {
    return;
  }
  cpu->config->write_port(cpu, port, FromOperandValue(&value));
}

// Write a word to an I/O port.
static void WriteWordToPort(CPUState* cpu, uint16_t port, OperandValue value) {
  uint32_t raw_value = FromOperandValue(&value);
  WriteByteToPort(cpu, port, ByteValue(raw_value & 0xFF));
  WriteByteToPort(cpu, port, ByteValue((raw_value >> 8) & 0xFF));
}

// Table of functions to write to an I/O port, indexed by data width.
static void (*const kWriteToPortFns[])(CPUState*, uint16_t, OperandValue) = {
    WriteByteToPort,  // kByte
    WriteWordToPort,  // kWord
};

// Common logic for OUT instructions.
static ExecuteStatus ExecuteOut(const InstructionContext* ctx, uint16_t port) {
  Operand src = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  kWriteToPortFns[ctx->metadata->width](ctx->cpu, port, src.value);
  return kExecuteSuccess;
}

// OUT imm8, AL
// OUT imm8, AX
YAX86_PRIVATE ExecuteStatus ExecuteOutImmediate(const InstructionContext* ctx) {
  OperandValue port = ReadImmediateOperandByte(ctx->instruction);
  return ExecuteOut(ctx, FromOperandValue(&port));
}

// OUT DX, AL
// OUT DX, AX
YAX86_PRIVATE ExecuteStatus ExecuteOutDX(const InstructionContext* ctx) {
  return ExecuteOut(ctx, ctx->cpu->registers[kDX]);
}


// ==============================================================================
// src/cpu/instructions_io.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_string.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_string.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// String instructions
// ============================================================================

// Get the repetition prefix of a string instruction, if any.
static uint8_t GetRepetitionPrefix(const InstructionContext* ctx) {
  uint8_t prefix = 0;
  for (int i = 0; i < ctx->instruction->prefix_size; ++i) {
    switch (ctx->instruction->prefix[i]) {
      case kPrefixREP:
      case kPrefixREPNZ:
        prefix = ctx->instruction->prefix[i];
        break;
      default:
        continue;
    }
  }
  return prefix;
}

// Get the source operand for string instructions. Typically DS:SI but can be
// overridden by a segment override prefix.
static Operand GetStringSourceOperand(const InstructionContext* ctx) {
  OperandAddress address = {
      .type = kOperandAddressTypeMemory,
      .value =
          {
              .memory_address =
                  {
                      .segment_register_index = kDS,
                      .offset = ctx->cpu->registers[kSI],
                  },
          },
  };
  ApplySegmentOverride(ctx->instruction, &address.value.memory_address);
  Operand operand = {
      .address = address,
      .value = ReadOperandValue(ctx, &address),
  };
  return operand;
}

// Get the destination operand address for string instructions. Always ES:DI.
static OperandAddress GetStringDestinationOperandAddress(
    const InstructionContext* ctx) {
  OperandAddress address = {
      .type = kOperandAddressTypeMemory,
      .value =
          {
              .memory_address =
                  {
                      .segment_register_index = kES,
                      .offset = ctx->cpu->registers[kDI],
                  },
          },
  };
  return address;
}

// Get the destination operand for string instructions. Always ES:DI.
static Operand GetStringDestinationOperand(const InstructionContext* ctx) {
  OperandAddress address = GetStringDestinationOperandAddress(ctx);
  Operand operand = {
      .address = address,
      .value = ReadOperandValue(ctx, &address),
  };
  return operand;
}

// Update the source address register (SI) after a string operation.
static void UpdateStringSourceAddress(const InstructionContext* ctx) {
  if (CPUGetFlag(ctx->cpu, kDF)) {
    ctx->cpu->registers[kSI] -= kNumBytes[ctx->metadata->width];
  } else {
    ctx->cpu->registers[kSI] += kNumBytes[ctx->metadata->width];
  }
}

// Update the destination address register (DI) after a string operation.
static void UpdateStringDestinationAddress(const InstructionContext* ctx) {
  if (CPUGetFlag(ctx->cpu, kDF)) {
    ctx->cpu->registers[kDI] -= kNumBytes[ctx->metadata->width];
  } else {
    ctx->cpu->registers[kDI] += kNumBytes[ctx->metadata->width];
  }
}

// Execute a string instruction with optional REP prefix.
static ExecuteStatus ExecuteStringInstructionWithREPPrefix(
    const InstructionContext* ctx,
    ExecuteStatus (*fn)(const InstructionContext*)) {
  uint8_t prefix = GetRepetitionPrefix(ctx);
  if (prefix != kPrefixREP) {
    return fn(ctx);
  }
  while (ctx->cpu->registers[kCX]) {
    ExecuteStatus status = fn(ctx);
    if (status != kExecuteSuccess) {
      return status;
    }
    --ctx->cpu->registers[kCX];
  }
  return kExecuteSuccess;
}

// Single MOVS iteration.
static ExecuteStatus ExecuteMovsIteration(const InstructionContext* ctx) {
  Operand src = GetStringSourceOperand(ctx);
  OperandAddress dest_address = GetStringDestinationOperandAddress(ctx);
  WriteOperandAddress(ctx, &dest_address, FromOperand(&src));
  UpdateStringSourceAddress(ctx);
  UpdateStringDestinationAddress(ctx);
  return kExecuteSuccess;
}

// MOVS
YAX86_PRIVATE ExecuteStatus ExecuteMovs(const InstructionContext* ctx) {
  return ExecuteStringInstructionWithREPPrefix(ctx, ExecuteMovsIteration);
}

// Single STOS iteration.
static ExecuteStatus ExecuteStosIteration(const InstructionContext* ctx) {
  Operand src = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  OperandAddress dest_address = GetStringDestinationOperandAddress(ctx);
  WriteOperandAddress(ctx, &dest_address, FromOperand(&src));
  UpdateStringDestinationAddress(ctx);
  return kExecuteSuccess;
}

// STOS
YAX86_PRIVATE ExecuteStatus ExecuteStos(const InstructionContext* ctx) {
  return ExecuteStringInstructionWithREPPrefix(ctx, ExecuteStosIteration);
}

// Single LODS iteration.
static ExecuteStatus ExecuteLodsIteration(const InstructionContext* ctx) {
  Operand src = GetStringSourceOperand(ctx);
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  WriteOperand(ctx, &dest, FromOperand(&src));
  UpdateStringSourceAddress(ctx);
  return kExecuteSuccess;
}

// LODS
YAX86_PRIVATE ExecuteStatus ExecuteLods(const InstructionContext* ctx) {
  return ExecuteStringInstructionWithREPPrefix(ctx, ExecuteLodsIteration);
}

// Execute a string instruction with optional REPZ/REPE or REPNZ/REPNE prefix.
static ExecuteStatus ExecuteStringInstructionWithREPZOrRepNZPrefix(
    const InstructionContext* ctx,
    ExecuteStatus (*fn)(const InstructionContext*)) {
  uint8_t prefix = GetRepetitionPrefix(ctx);
  if (prefix != kPrefixREP && prefix != kPrefixREPNZ) {
    return fn(ctx);
  }
  bool terminate_zf_value = prefix == kPrefixREPNZ;
  while (ctx->cpu->registers[kCX]) {
    ExecuteStatus status = fn(ctx);
    if (status != kExecuteSuccess) {
      return status;
    }
    --ctx->cpu->registers[kCX];
    if (CPUGetFlag(ctx->cpu, kZF) == terminate_zf_value) {
      break;
    }
  }
  return kExecuteSuccess;
}

// Single SCAS iteration.
static ExecuteStatus ExecuteScasIteration(const InstructionContext* ctx) {
  Operand src = GetStringDestinationOperand(ctx);
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  ExecuteCmp(ctx, &dest, &src.value);
  UpdateStringDestinationAddress(ctx);
  return kExecuteSuccess;
}

// SCAS
YAX86_PRIVATE ExecuteStatus ExecuteScas(const InstructionContext* ctx) {
  return ExecuteStringInstructionWithREPZOrRepNZPrefix(
      ctx, ExecuteScasIteration);
}

// Single CMPS iteration.
static ExecuteStatus ExecuteCmpsIteration(const InstructionContext* ctx) {
  Operand dest = GetStringSourceOperand(ctx);
  Operand src = GetStringDestinationOperand(ctx);
  ExecuteCmp(ctx, &dest, &src.value);
  UpdateStringSourceAddress(ctx);
  UpdateStringDestinationAddress(ctx);
  return kExecuteSuccess;
}

// CMPS
YAX86_PRIVATE ExecuteStatus ExecuteCmps(const InstructionContext* ctx) {
  return ExecuteStringInstructionWithREPZOrRepNZPrefix(
      ctx, ExecuteCmpsIteration);
}


// ==============================================================================
// src/cpu/instructions_string.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_bcd_ascii.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_bcd_ascii.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// BCD and ASCII arithmetic instructions
// ============================================================================

// AAA
YAX86_PRIVATE ExecuteStatus ExecuteAaa(const InstructionContext* ctx) {
  uint8_t al = ctx->cpu->registers[kAX] & 0xFF;
  uint8_t ah = (ctx->cpu->registers[kAX] >> 8) & 0xFF;
  uint8_t al_low = al & 0x0F;
  if (al_low > 9 || CPUGetFlag(ctx->cpu, kAF)) {
    al += 6;
    ++ah;
    CPUSetFlag(ctx->cpu, kAF, true);
    CPUSetFlag(ctx->cpu, kCF, true);
  } else {
    CPUSetFlag(ctx->cpu, kAF, false);
    CPUSetFlag(ctx->cpu, kCF, false);
  }
  al &= 0x0F;
  ctx->cpu->registers[kAX] = (ah << 8) | al;
  return kExecuteSuccess;
}

// AAS
YAX86_PRIVATE ExecuteStatus ExecuteAas(const InstructionContext* ctx) {
  uint8_t al = ctx->cpu->registers[kAX] & 0xFF;
  uint8_t ah = (ctx->cpu->registers[kAX] >> 8) & 0xFF;
  uint8_t al_low = al & 0x0F;
  if (al_low > 9 || CPUGetFlag(ctx->cpu, kAF)) {
    al -= 6;
    --ah;
    CPUSetFlag(ctx->cpu, kAF, true);
    CPUSetFlag(ctx->cpu, kCF, true);
  } else {
    CPUSetFlag(ctx->cpu, kAF, false);
    CPUSetFlag(ctx->cpu, kCF, false);
  }
  al &= 0x0F;
  ctx->cpu->registers[kAX] = (ah << 8) | al;
  return kExecuteSuccess;
}

// AAM
YAX86_PRIVATE ExecuteStatus ExecuteAam(const InstructionContext* ctx) {
  uint8_t al = ctx->cpu->registers[kAX] & 0xFF;
  OperandValue base = ReadImmediate(ctx);
  uint16_t base_value = FromOperandValue(&base);
  if (base_value == 0) {
    return kExecuteInvalidInstruction;
  }
  uint8_t ah = al / base_value;
  al %= base_value;
  ctx->cpu->registers[kAX] = (ah << 8) | al;
  SetCommonFlagsAfterInstruction(ctx, al);
  return kExecuteSuccess;
}

// AAD
YAX86_PRIVATE ExecuteStatus ExecuteAad(const InstructionContext* ctx) {
  uint8_t al = ctx->cpu->registers[kAX] & 0xFF;
  uint8_t ah = (ctx->cpu->registers[kAX] >> 8) & 0xFF;
  OperandValue base = ReadImmediate(ctx);
  uint8_t base_value = FromOperandValue(&base);
  al += ah * base_value;
  ah = 0;
  ctx->cpu->registers[kAX] = (ah << 8) | al;
  SetCommonFlagsAfterInstruction(ctx, al);
  return kExecuteSuccess;
}

// DAA
YAX86_PRIVATE ExecuteStatus ExecuteDaa(const InstructionContext* ctx) {
  uint8_t al = ctx->cpu->registers[kAX] & 0xFF;
  uint8_t ah = (ctx->cpu->registers[kAX] >> 8) & 0xFF;
  uint8_t al_low = al & 0x0F;
  if (al_low > 9 || CPUGetFlag(ctx->cpu, kAF)) {
    al += 6;
    CPUSetFlag(ctx->cpu, kAF, true);
  } else {
    CPUSetFlag(ctx->cpu, kAF, false);
  }
  uint8_t al_high = (al >> 4) & 0x0F;
  if (al_high > 9 || CPUGetFlag(ctx->cpu, kCF)) {
    al += 0x60;
    CPUSetFlag(ctx->cpu, kCF, true);
  } else {
    CPUSetFlag(ctx->cpu, kCF, false);
  }
  ctx->cpu->registers[kAX] = (ah << 8) | al;
  SetCommonFlagsAfterInstruction(ctx, al);
  return kExecuteSuccess;
}

// DAS
YAX86_PRIVATE ExecuteStatus ExecuteDas(const InstructionContext* ctx) {
  uint8_t al = ctx->cpu->registers[kAX] & 0xFF;
  uint8_t ah = (ctx->cpu->registers[kAX] >> 8) & 0xFF;
  uint8_t al_low = al & 0x0F;
  if (al_low > 9 || CPUGetFlag(ctx->cpu, kAF)) {
    al -= 6;
    CPUSetFlag(ctx->cpu, kAF, true);
  } else {
    CPUSetFlag(ctx->cpu, kAF, false);
  }
  uint8_t al_high = (al >> 4) & 0x0F;
  if (al_high > 9 || CPUGetFlag(ctx->cpu, kCF)) {
    al -= 0x60;
    CPUSetFlag(ctx->cpu, kCF, true);
  } else {
    CPUSetFlag(ctx->cpu, kCF, false);
  }
  ctx->cpu->registers[kAX] = (ah << 8) | al;
  SetCommonFlagsAfterInstruction(ctx, al);
  return kExecuteSuccess;
}


// ==============================================================================
// src/cpu/instructions_bcd_ascii.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_group_1.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_group_1.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// Group 1 - ADD, OR, ADC, SBB, AND, SUB, XOR, CMP
// ============================================================================

typedef ExecuteStatus (*Group1ExecuteInstructionFn)(
    const InstructionContext* ctx, Operand* dest, const OperandValue* src);

// Group 1 instruction implementations, indexed by the corresponding REG field
// value in the ModRM byte.
static const Group1ExecuteInstructionFn kGroup1ExecuteInstructionFns[] = {
    ExecuteAdd,            // 0 - ADD
    ExecuteBooleanOr,      // 1 - OR
    ExecuteAddWithCarry,   // 2 - ADC
    ExecuteSubWithBorrow,  // 3 - SBB
    ExecuteBooleanAnd,     // 4 - AND
    ExecuteSub,            // 5 - SUB
    ExecuteBooleanXor,     // 6 - XOR
    ExecuteCmp,            // 7 - CMP
};

// Group 1 instruction handler.
YAX86_PRIVATE ExecuteStatus
ExecuteGroup1Instruction(const InstructionContext* ctx) {
  const Group1ExecuteInstructionFn fn =
      kGroup1ExecuteInstructionFns[ctx->instruction->mod_rm.reg];
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  OperandValue src_value = ReadImmediate(ctx);
  return fn(ctx, &dest, &src_value);
}

// Group 1 instruction handler, but sign-extends the 8-bit immediate value.
YAX86_PRIVATE ExecuteStatus
ExecuteGroup1InstructionWithSignExtension(const InstructionContext* ctx) {
  const Group1ExecuteInstructionFn fn =
      kGroup1ExecuteInstructionFns[ctx->instruction->mod_rm.reg];
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  OperandValue src_value =
      ReadImmediateOperandByte(ctx->instruction);  // immediate is always 8-bit
  OperandValue src_value_extended =
      WordValue((uint16_t)((int16_t)((int8_t)src_value.value.byte_value)));
  // Sign-extend the immediate value to the destination width.
  return fn(ctx, &dest, &src_value_extended);
}


// ==============================================================================
// src/cpu/instructions_group_1.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_group_2.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_group_2.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// Group 2 - ROL, ROR, RCL, RCR, SHL, SHR, SAL, SAR
// ============================================================================

typedef ExecuteStatus (*Group2ExecuteInstructionFn)(
    const InstructionContext* ctx, Operand* op, uint8_t count);

// SHL r/m8, 1
// SHL r/m16, 1
// SHL r/m8, CL
// SHL r/m16, CL
static ExecuteStatus ExecuteGroup2Shl(
    const InstructionContext* ctx, Operand* op, uint8_t count) {
  // Return early if count is 0, so as to not affect flags.
  if (count == 0) {
    return kExecuteSuccess;
  }
  uint32_t value = FromOperand(op);
  uint32_t result = (value << count) & kMaxValue[ctx->metadata->width];
  WriteOperand(ctx, op, result);
  bool last_msb =
      ((value << (count - 1)) & kSignBit[ctx->metadata->width]) != 0;
  CPUSetFlag(ctx->cpu, kCF, last_msb);
  if (count == 1) {
    bool current_msb = ((result & kSignBit[ctx->metadata->width]) != 0);
    CPUSetFlag(ctx->cpu, kOF, last_msb != current_msb);
  }
  SetCommonFlagsAfterInstruction(ctx, result);
  return kExecuteSuccess;
}

// SHR r/m8, 1
// SHR r/m16, 1
// SHR r/m8, CL
// SHR r/m16, CL
static ExecuteStatus ExecuteGroup2Shr(
    const InstructionContext* ctx, Operand* op, uint8_t count) {
  // Return early if count is 0, so as to not affect flags.
  if (count == 0) {
    return kExecuteSuccess;
  }
  uint32_t value = FromOperand(op);
  uint32_t result = value >> count;
  WriteOperand(ctx, op, result);
  bool last_lsb = ((value >> (count - 1)) & 1) != 0;
  CPUSetFlag(ctx->cpu, kCF, last_lsb);
  if (count == 1) {
    bool original_msb = ((value & kSignBit[ctx->metadata->width]) != 0);
    CPUSetFlag(ctx->cpu, kOF, original_msb);
  }
  SetCommonFlagsAfterInstruction(ctx, result);
  return kExecuteSuccess;
}

// SAR r/m8, 1
// SAR r/m16, 1
// SAR r/m8, CL
// SAR r/m16, CL
static ExecuteStatus ExecuteGroup2Sar(
    const InstructionContext* ctx, Operand* op, uint8_t count) {
  // Return early if count is 0, so as to not affect flags.
  if (count == 0) {
    return kExecuteSuccess;
  }
  int32_t value = FromSignedOperand(op);
  int32_t result = value >> count;
  WriteOperand(ctx, op, result);
  bool last_lsb = ((value >> (count - 1)) & 1) != 0;
  CPUSetFlag(ctx->cpu, kCF, last_lsb);
  if (count == 1) {
    CPUSetFlag(ctx->cpu, kOF, false);
  }
  SetCommonFlagsAfterInstruction(ctx, result);
  return kExecuteSuccess;
}

// ROL r/m8, 1
// ROL r/m16, 1
// ROL r/m8, CL
// ROL r/m16, CL
static ExecuteStatus ExecuteGroup2Rol(
    const InstructionContext* ctx, Operand* op, uint8_t count) {
  // Return early if count is 0, so as to not affect flags.
  if (count == 0) {
    return kExecuteSuccess;
  }
  // The 8086 computes the modulus of the count after the zero check, which is
  // different than the 80286 and later processors.
  uint8_t effective_count = count % kNumBits[ctx->metadata->width];
  uint32_t value = FromOperand(op);
  uint32_t result =
      (value << effective_count) |
      (value >> (kNumBits[ctx->metadata->width] - effective_count));
  WriteOperand(ctx, op, result);
  bool last_msb = (result & 1) != 0;
  CPUSetFlag(ctx->cpu, kCF, last_msb);
  if (count == 1) {
    bool current_msb = ((result & kSignBit[ctx->metadata->width]) != 0);
    CPUSetFlag(ctx->cpu, kOF, last_msb != current_msb);
  }
  return kExecuteSuccess;
}

// ROR r/m8, 1
// ROR r/m16, 1
// ROR r/m8, CL
// ROR r/m16, CL
static ExecuteStatus ExecuteGroup2Ror(
    const InstructionContext* ctx, Operand* op, uint8_t count) {
  // Return early if count is 0, so as to not affect flags.
  if (count == 0) {
    return kExecuteSuccess;
  }
  // The 8086 computes the modulus of the count after the zero check, which is
  // different than the 80286 and later processors.
  uint8_t effective_count = count % kNumBits[ctx->metadata->width];
  uint32_t value = FromOperand(op);
  uint32_t result =
      (value >> effective_count) |
      (value << (kNumBits[ctx->metadata->width] - effective_count));
  WriteOperand(ctx, op, result);
  bool last_lsb = (result & kSignBit[ctx->metadata->width]) != 0;
  CPUSetFlag(ctx->cpu, kCF, last_lsb);
  if (count == 1) {
    bool original_msb = ((value & kSignBit[ctx->metadata->width]) != 0);
    CPUSetFlag(ctx->cpu, kOF, last_lsb != original_msb);
  }
  return kExecuteSuccess;
}

// RCL r/m8, 1
// RCL r/m16, 1
// RCL r/m8, CL
// RCL r/m16, CL
static ExecuteStatus ExecuteGroup2Rcl(
    const InstructionContext* ctx, Operand* op, uint8_t count) {
  uint8_t effective_count = count % (kNumBits[ctx->metadata->width] + 1);
  if (effective_count == 0) {
    return kExecuteSuccess;
  }
  uint32_t cf_value = CPUGetFlag(ctx->cpu, kCF) ? (1 << (effective_count - 1)) : 0;
  uint32_t value = FromOperand(op);
  uint32_t result =
      (value << effective_count) | cf_value |
      (value >> (kNumBits[ctx->metadata->width] - (effective_count - 1)));
  WriteOperand(ctx, op, result);
  bool last_msb =
      ((value << (effective_count - 1)) & kSignBit[ctx->metadata->width]) != 0;
  CPUSetFlag(ctx->cpu, kCF, last_msb);
  if (count == 1) {
    bool current_msb = ((result & kSignBit[ctx->metadata->width]) != 0);
    CPUSetFlag(ctx->cpu, kOF, last_msb != current_msb);
  }
  return kExecuteSuccess;
}

// RCR r/m8, 1
// RCR r/m16, 1
// RCR r/m8, CL
// RCR r/m16, CL
static ExecuteStatus ExecuteGroup2Rcr(
    const InstructionContext* ctx, Operand* op, uint8_t count) {
  uint8_t effective_count = count % (kNumBits[ctx->metadata->width] + 1);
  if (effective_count == 0) {
    return kExecuteSuccess;
  }
  uint32_t cf_value =
      CPUGetFlag(ctx->cpu, kCF)
          ? (kSignBit[ctx->metadata->width] >> (effective_count - 1))
          : 0;
  uint32_t value = FromOperand(op);
  uint32_t result =
      (value >> effective_count) | cf_value |
      (value << (kNumBits[ctx->metadata->width] - (effective_count - 1)));
  WriteOperand(ctx, op, result);
  bool last_lsb = ((value >> (effective_count - 1)) & 1) != 0;
  CPUSetFlag(ctx->cpu, kCF, last_lsb);
  if (count == 1) {
    bool original_msb = ((value & kSignBit[ctx->metadata->width]) != 0);
    bool current_msb = ((result & kSignBit[ctx->metadata->width]) != 0);
    CPUSetFlag(ctx->cpu, kOF, current_msb != original_msb);
  }
  return kExecuteSuccess;
}

static const Group2ExecuteInstructionFn kGroup2ExecuteInstructionFns[] = {
    ExecuteGroup2Rol,  // 0 - ROL
    ExecuteGroup2Ror,  // 1 - ROR
    ExecuteGroup2Rcl,  // 2 - RCL
    ExecuteGroup2Rcr,  // 3 - RCR
    ExecuteGroup2Shl,  // 4 - SHL
    ExecuteGroup2Shr,  // 5 - SHR
    ExecuteGroup2Shl,  // 6 - SAL (same as SHL)
    ExecuteGroup2Sar,  // 7 - SAR
};

// Group 2 shift / rotate by 1.
YAX86_PRIVATE ExecuteStatus
ExecuteGroup2ShiftOrRotateBy1Instruction(const InstructionContext* ctx) {
  const Group2ExecuteInstructionFn fn =
      kGroup2ExecuteInstructionFns[ctx->instruction->mod_rm.reg];
  Operand op = ReadRegisterOrMemoryOperand(ctx);
  return fn(ctx, &op, 1);
}

// Group 2 shift / rotate by CL.
YAX86_PRIVATE ExecuteStatus
ExecuteGroup2ShiftOrRotateByCLInstruction(const InstructionContext* ctx) {
  const Group2ExecuteInstructionFn fn =
      kGroup2ExecuteInstructionFns[ctx->instruction->mod_rm.reg];
  Operand op = ReadRegisterOrMemoryOperand(ctx);
  return fn(ctx, &op, ctx->cpu->registers[kCX] & 0xFF);
}


// ==============================================================================
// src/cpu/instructions_group_2.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_group_3.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_group_3.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// Group 3 - TEST, NOT, NEG, MUL, IMUL, DIV, IDIV
// ============================================================================

typedef ExecuteStatus (*Group3ExecuteInstructionFn)(
    const InstructionContext* ctx, Operand* op);

// TEST r/m8, imm8
// TEST r/m16, imm16
static ExecuteStatus ExecuteGroup3Test(
    const InstructionContext* ctx, Operand* op) {
  OperandValue src_value = ReadImmediate(ctx);
  return ExecuteTest(ctx, op, &src_value);
}

// NOT r/m8
// NOT r/m16
static ExecuteStatus ExecuteNot(const InstructionContext* ctx, Operand* op) {
  WriteOperand(ctx, op, ~FromOperand(op));
  return kExecuteSuccess;
}

// NEG r/m8
// NEG r/m16
static ExecuteStatus ExecuteNeg(const InstructionContext* ctx, Operand* op) {
  int32_t op_value = FromSignedOperand(op);
  int32_t result_value = -op_value;
  WriteOperand(ctx, op, result_value);
  SetFlagsAfterSub(ctx, 0, op_value, result_value, false);
  return kExecuteSuccess;
}

// Table of where to store the higher half of the result for
// MUL, IMUL, DIV, and IDIV instructions, indexed by the data width.
static const OperandAddress kMulDivResultHighHalfAddress[kNumWidths] = {
    {.type = kOperandAddressTypeRegister,
     .value =
         {
             .register_address =
                 {
                     .register_index = kAX,
                     .byte_offset = 8,
                 },
         }},
    {.type = kOperandAddressTypeRegister,
     .value = {
         .register_address =
             {
                 .register_index = kDX,
             },
     }}};

// Number of bits to shift to extract the high part of the result of MUL, IMUL,
// DIV, and IDIV instructions, indexed by the data width.
static const uint8_t kMulDivResultHighHalfShiftWidth[kNumWidths] = {
    8,   // kByte
    16,  // kWord
};

// Common logic for MUL and IMUL instructions.
static ExecuteStatus ExecuteMulCommon(
    const InstructionContext* ctx, Operand* dest, uint32_t result,
    bool overflow) {
  Width width = ctx->metadata->width;

  uint32_t result_low_half = result & kMaxValue[width];
  WriteOperand(ctx, dest, result_low_half);

  uint32_t result_high_half =
      (result >> kMulDivResultHighHalfShiftWidth[width]) & kMaxValue[width];
  WriteOperandAddress(
      ctx, &kMulDivResultHighHalfAddress[width], result_high_half);

  CPUSetFlag(ctx->cpu, kCF, overflow);
  CPUSetFlag(ctx->cpu, kOF, overflow);

  return kExecuteSuccess;
}

// MUL r/m8
// MUL r/m16
static ExecuteStatus ExecuteMul(const InstructionContext* ctx, Operand* op) {
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  uint32_t result = FromOperand(&dest) * FromOperand(op);
  return ExecuteMulCommon(
      ctx, &dest, result, result > kMaxValue[ctx->metadata->width]);
}

// IMUL r/m8
// IMUL r/m16
static ExecuteStatus ExecuteImul(const InstructionContext* ctx, Operand* op) {
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);
  int32_t result = FromSignedOperand(&dest) * FromSignedOperand(op);
  return ExecuteMulCommon(
      ctx, &dest, result,
      result > kMaxSignedValue[ctx->metadata->width] ||
          result < kMinSignedValue[ctx->metadata->width]);
}

static ExecuteStatus WriteDivResult(
    const InstructionContext* ctx, Operand* dest, uint32_t quotient,
    uint32_t remainder) {
  WriteOperand(ctx, dest, quotient);
  WriteOperandAddress(
      ctx, &kMulDivResultHighHalfAddress[ctx->metadata->width], remainder);
  return kExecuteSuccess;
}

// DIV r/m8
// DIV r/m16
static ExecuteStatus ExecuteDiv(const InstructionContext* ctx, Operand* op) {
  uint32_t divisor = FromOperand(op);
  if (divisor == 0) {
    CPUSetPendingInterrupt(ctx->cpu, kInterruptDivideError);
    return kExecuteSuccess;
  }

  Width width = ctx->metadata->width;
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);

  OperandValue dest_high_half =
      ReadOperandValue(ctx, &kMulDivResultHighHalfAddress[width]);
  uint32_t dividend =
      FromOperand(&dest) | (FromOperandValue(&dest_high_half)
                            << kMulDivResultHighHalfShiftWidth[width]);
  uint32_t quotient = dividend / divisor;
  if (quotient > kMaxValue[ctx->metadata->width]) {
    CPUSetPendingInterrupt(ctx->cpu, kInterruptDivideError);
    return kExecuteSuccess;
  }
  return WriteDivResult(ctx, &dest, quotient, dividend % divisor);
}

// IDIV r/m8
// IDIV r/m16
static ExecuteStatus ExecuteIdiv(const InstructionContext* ctx, Operand* op) {
  int32_t divisor = FromSignedOperand(op);
  if (divisor == 0) {
    CPUSetPendingInterrupt(ctx->cpu, kInterruptDivideError);
    return kExecuteSuccess;
  }

  Width width = ctx->metadata->width;
  Operand dest = ReadRegisterOperandForRegisterIndex(ctx, kAX);

  OperandValue dest_high_half =
      ReadOperandValue(ctx, &kMulDivResultHighHalfAddress[width]);
  int32_t dividend =
      FromOperand(&dest) | (FromSignedOperandValue(&dest_high_half)
                            << kMulDivResultHighHalfShiftWidth[width]);
  int32_t quotient = dividend / divisor;
  if (quotient > kMaxSignedValue[ctx->metadata->width] ||
      quotient < kMinSignedValue[ctx->metadata->width]) {
    CPUSetPendingInterrupt(ctx->cpu, kInterruptDivideError);
    return kExecuteSuccess;
  }
  return WriteDivResult(ctx, &dest, quotient, dividend % divisor);
}

// Group 3 instruction implementations, indexed by the corresponding REG field
// value in the ModRM byte and data width.
static const Group3ExecuteInstructionFn kGroup3ExecuteInstructionFns[] = {
    ExecuteGroup3Test,  // 0 - TEST
    0,                  // 1 - Reserved
    ExecuteNot,         // 2 - NOT
    ExecuteNeg,         // 3 - NEG
    ExecuteMul,         // 4 - MUL
    ExecuteImul,        // 5 - IMUL
    ExecuteDiv,         // 6 - DIV
    ExecuteIdiv,        // 7 - IDIV
};

// Group 3 instruction handler.
YAX86_PRIVATE ExecuteStatus
ExecuteGroup3Instruction(const InstructionContext* ctx) {
  const Group3ExecuteInstructionFn fn =
      kGroup3ExecuteInstructionFns[ctx->instruction->mod_rm.reg];
  if (fn == 0) {
    return kExecuteInvalidOpcode;
  }
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  return fn(ctx, &dest);
}


// ==============================================================================
// src/cpu/instructions_group_3.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_group_4.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_group_4.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// Group 4 - INC, DEC
// ============================================================================

typedef ExecuteStatus (*Group4ExecuteInstructionFn)(
    const InstructionContext* ctx, Operand* dest);

// Group 4 instruction implementations, indexed by the corresponding REG field
// value in the ModRM byte.
static const Group4ExecuteInstructionFn kGroup4ExecuteInstructionFns[] = {
    ExecuteInc,  // 0 - INC
    ExecuteDec,  // 1 - DEC
};

// Group 4 instruction handler.
YAX86_PRIVATE ExecuteStatus
ExecuteGroup4Instruction(const InstructionContext* ctx) {
  const Group4ExecuteInstructionFn fn =
      kGroup4ExecuteInstructionFns[ctx->instruction->mod_rm.reg];
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  return fn(ctx, &dest);
}


// ==============================================================================
// src/cpu/instructions_group_4.c end
// ==============================================================================

// ==============================================================================
// src/cpu/instructions_group_5.c start
// ==============================================================================

#line 1 "./src/cpu/instructions_group_5.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// Group 5 - INC, DEC, CALL, JMP, PUSH
// ============================================================================

// Helper to get the segment register value for far JMP and CALL instructions.
static Operand GetSegmentRegisterOperandForIndirectFarJumpOrCall(
    const InstructionContext* ctx, const Operand* offset) {
  OperandAddress segment_address = offset->address;
  segment_address.value.memory_address.offset += 2;  // Skip the offset
  OperandValue segment_value =
      ReadMemoryOperandWord(ctx->cpu, &segment_address);
  Operand operand = {
      .address = segment_address,
      .value = segment_value,
  };
  return operand;
}

// JMP ptr16
static ExecuteStatus ExecuteIndirectNearJump(
    const InstructionContext* ctx, Operand* dest) {
  ctx->cpu->registers[kIP] = FromOperandValue(&dest->value);
  return kExecuteSuccess;
}

// CALL ptr16
static ExecuteStatus ExecuteIndirectNearCall(
    const InstructionContext* ctx, Operand* dest) {
  Push(ctx->cpu, WordValue(ctx->cpu->registers[kIP]));
  return ExecuteIndirectNearJump(ctx, dest);
}

// CALL ptr16:16
static ExecuteStatus ExecuteIndirectFarCall(
    const InstructionContext* ctx, Operand* dest) {
  Operand segment =
      GetSegmentRegisterOperandForIndirectFarJumpOrCall(ctx, dest);
  return ExecuteFarCall(ctx, &segment.value, &dest->value);
}

// JMP ptr16:16
static ExecuteStatus ExecuteIndirectFarJump(
    const InstructionContext* ctx, Operand* dest) {
  Operand segment =
      GetSegmentRegisterOperandForIndirectFarJumpOrCall(ctx, dest);
  return ExecuteFarJump(ctx, &segment.value, &dest->value);
}

// PUSH r/m16
static ExecuteStatus ExecuteIndirectPush(
    const InstructionContext* ctx, Operand* dest) {
  Push(ctx->cpu, dest->value);
  return kExecuteSuccess;
}

typedef ExecuteStatus (*Group5ExecuteInstructionFn)(
    const InstructionContext* ctx, Operand* dest);

// Group 5 instruction implementations, indexed by the corresponding REG
// field value in the ModRM byte.
static const Group5ExecuteInstructionFn kGroup5ExecuteInstructionFns[] = {
    ExecuteInc,               // 0 - INC r/m8/r/m16
    ExecuteDec,               // 1 - DEC r/m8/r/m16
    ExecuteIndirectNearCall,  // 2 - CALL rel16
    ExecuteIndirectFarCall,   // 3 - CALL ptr16:16
    ExecuteIndirectNearJump,  // 4 - JMP ptr16
    ExecuteIndirectFarJump,   // 5 - JMP ptr16:16
    ExecuteIndirectPush,      // 6 - PUSH r/m16
                              // 7 - Reserved
};

// Group 5 instruction handler.
YAX86_PRIVATE ExecuteStatus
ExecuteGroup5Instruction(const InstructionContext* ctx) {
  const Group5ExecuteInstructionFn fn =
      kGroup5ExecuteInstructionFns[ctx->instruction->mod_rm.reg];
  Operand dest = ReadRegisterOrMemoryOperand(ctx);
  return fn(ctx, &dest);
}


// ==============================================================================
// src/cpu/instructions_group_5.c end
// ==============================================================================

// ==============================================================================
// src/cpu/opcode_table.c start
// ==============================================================================

#line 1 "./src/cpu/opcode_table.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// Opcode table
// ============================================================================

// Global opcode metadata lookup table.
YAX86_PRIVATE OpcodeMetadata opcode_table[256] = {
    // ADD r/m8, r8
    {.opcode = 0x00,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteAddRegisterToRegisterOrMemory},
    // ADD r/m16, r16
    {.opcode = 0x01,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteAddRegisterToRegisterOrMemory},
    // ADD r8, r/m8
    {.opcode = 0x02,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteAddRegisterOrMemoryToRegister},
    // ADD r16, r/m16
    {.opcode = 0x03,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteAddRegisterOrMemoryToRegister},
    // ADD AL, imm8
    {.opcode = 0x04,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteAddImmediateToALOrAX},
    // ADD AX, imm16
    {.opcode = 0x05,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteAddImmediateToALOrAX},
    // PUSH ES
    {.opcode = 0x06,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePushSegmentRegister},
    // POP ES
    {.opcode = 0x07,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePopSegmentRegister},
    // OR r/m8, r8
    {.opcode = 0x08,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteBooleanOrRegisterToRegisterOrMemory},
    // OR r/m16, r16
    {.opcode = 0x09,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteBooleanOrRegisterToRegisterOrMemory},
    // OR r8, r/m8
    {.opcode = 0x0A,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteBooleanOrRegisterOrMemoryToRegister},
    // OR r16, r/m16
    {.opcode = 0x0B,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteBooleanOrRegisterOrMemoryToRegister},
    // OR AL, imm8
    {.opcode = 0x0C,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteBooleanOrImmediateToALOrAX},
    // OR AX, imm16
    {.opcode = 0x0D,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteBooleanOrImmediateToALOrAX},
    // PUSH CS
    {.opcode = 0x0E,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePushSegmentRegister},
    // 0x0F - UNSUPPORTED
    {.opcode = 0x0F, .handler = 0},
    // ADC r/m8, r8
    {.opcode = 0x10,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteAddRegisterToRegisterOrMemoryWithCarry},
    // ADC r/m16, r16
    {.opcode = 0x11,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteAddRegisterToRegisterOrMemoryWithCarry},
    // ADC r8, r/m8
    {.opcode = 0x12,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteAddRegisterOrMemoryToRegisterWithCarry},
    // ADC r16, r/m16
    {.opcode = 0x13,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteAddRegisterOrMemoryToRegisterWithCarry},
    // ADC AL, imm8
    {.opcode = 0x14,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteAddImmediateToALOrAXWithCarry},
    // ADC AX, imm16
    {.opcode = 0x15,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteAddImmediateToALOrAXWithCarry},
    // PUSH SS
    {.opcode = 0x16,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePushSegmentRegister},
    // POP SS
    {.opcode = 0x17,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePopSegmentRegister},
    // SBB r/m8, r8
    {.opcode = 0x18,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteSubRegisterFromRegisterOrMemoryWithBorrow},
    // SBB r/m16, r16
    {.opcode = 0x19,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteSubRegisterFromRegisterOrMemoryWithBorrow},
    // SBB r8, r/m8
    {.opcode = 0x1A,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteSubRegisterOrMemoryFromRegisterWithBorrow},
    // SBB r16, r/m16
    {.opcode = 0x1B,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteSubRegisterOrMemoryFromRegisterWithBorrow},
    // SBB AL, imm8
    {.opcode = 0x1C,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteSubImmediateFromALOrAXWithBorrow},
    // SBB AX, imm16
    {.opcode = 0x1D,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteSubImmediateFromALOrAXWithBorrow},
    // PUSH DS
    {.opcode = 0x1E,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePushSegmentRegister},
    // POP DS
    {.opcode = 0x1F,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePopSegmentRegister},
    // AND r/m8, r8
    {.opcode = 0x20,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteBooleanAndRegisterToRegisterOrMemory},
    // AND r/m16, r16
    {.opcode = 0x21,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteBooleanAndRegisterToRegisterOrMemory},
    // AND r8, r/m8
    {.opcode = 0x22,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteBooleanAndRegisterOrMemoryToRegister},
    // AND r16, r/m16
    {.opcode = 0x23,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteBooleanAndRegisterOrMemoryToRegister},
    // AND AL, imm8
    {.opcode = 0x24,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteBooleanAndImmediateToALOrAX},
    // AND AX, imm16
    {.opcode = 0x25,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteBooleanAndImmediateToALOrAX},
    // ES prefix - 0x26
    {.opcode = 0x26, .handler = 0},
    // DAA
    {.opcode = 0x27,
     .has_modrm = false,
     .immediate_size = 0,
     .handler = ExecuteDaa},
    // SUB r/m8, r8
    {.opcode = 0x28,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteSubRegisterFromRegisterOrMemory},
    // SUB r/m16, r16
    {.opcode = 0x29,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteSubRegisterFromRegisterOrMemory},
    // SUB r8, r/m8
    {.opcode = 0x2A,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteSubRegisterOrMemoryFromRegister},
    // SUB r16, r/m16
    {.opcode = 0x2B,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteSubRegisterOrMemoryFromRegister},
    // SUB AL, imm8
    {.opcode = 0x2C,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteSubImmediateFromALOrAX},
    // SUB AX, imm16
    {.opcode = 0x2D,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteSubImmediateFromALOrAX},
    // CS prefix - 0x2E
    {.opcode = 0x2E, .handler = 0},
    // DAS
    {.opcode = 0x2F,
     .has_modrm = false,
     .immediate_size = 0,
     .handler = ExecuteDas},
    // XOR r/m8, r8
    {.opcode = 0x30,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteBooleanXorRegisterToRegisterOrMemory},
    // XOR r/m16, r16
    {.opcode = 0x31,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteBooleanXorRegisterToRegisterOrMemory},
    // XOR r8, r/m8
    {.opcode = 0x32,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteBooleanXorRegisterOrMemoryToRegister},
    // XOR r16, r/m16
    {.opcode = 0x33,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteBooleanXorRegisterOrMemoryToRegister},
    // XOR AL, imm8
    {.opcode = 0x34,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteBooleanXorImmediateToALOrAX},
    // XOR AX, imm16
    {.opcode = 0x35,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteBooleanXorImmediateToALOrAX},
    // SS prefix - 0x36
    {.opcode = 0x36, .handler = 0},
    // AAA
    {.opcode = 0x37,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteAaa},
    // CMP r/m8, r8
    {.opcode = 0x38,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteCmpRegisterToRegisterOrMemory},
    // CMP r/m16, r16
    {.opcode = 0x39,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteCmpRegisterToRegisterOrMemory},
    // CMP r8, r/m8
    {.opcode = 0x3A,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteCmpRegisterOrMemoryToRegister},
    // CMP r16, r/m16
    {.opcode = 0x3B,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteCmpRegisterOrMemoryToRegister},
    // CMP AL, imm8
    {.opcode = 0x3C,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteCmpImmediateToALOrAX},
    // CMP AX, imm16
    {.opcode = 0x3D,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteCmpImmediateToALOrAX},
    // DS prefix - 0x3E
    {.opcode = 0x3E, .handler = 0},
    // AAS
    {.opcode = 0x3F,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteAas},
    // INC AX
    {.opcode = 0x40,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteIncRegister},
    // INC CX
    {.opcode = 0x41,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteIncRegister},
    // INC DX
    {.opcode = 0x42,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteIncRegister},
    // INC BX
    {.opcode = 0x43,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteIncRegister},
    // INC SP
    {.opcode = 0x44,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteIncRegister},
    // INC BP
    {.opcode = 0x45,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteIncRegister},
    // INC SI
    {.opcode = 0x46,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteIncRegister},
    // INC DI
    {.opcode = 0x47,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteIncRegister},
    // DEC AX
    {.opcode = 0x48,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteDecRegister},
    // DEC CX
    {.opcode = 0x49,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteDecRegister},
    // DEC DX
    {.opcode = 0x4A,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteDecRegister},
    // DEC BX
    {.opcode = 0x4B,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteDecRegister},
    // DEC SP
    {.opcode = 0x4C,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteDecRegister},
    // DEC BP
    {.opcode = 0x4D,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteDecRegister},
    // DEC SI
    {.opcode = 0x4E,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteDecRegister},
    // DEC DI
    {.opcode = 0x4F,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteDecRegister},
    // PUSH AX
    {.opcode = 0x50,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePushRegister},
    // PUSH CX
    {.opcode = 0x51,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePushRegister},
    // PUSH DX
    {.opcode = 0x52,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePushRegister},
    // PUSH BX
    {.opcode = 0x53,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePushRegister},
    // PUSH SP
    {.opcode = 0x54,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePushRegister},
    // PUSH BP
    {.opcode = 0x55,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePushRegister},
    // PUSH SI
    {.opcode = 0x56,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePushRegister},
    // PUSH DI
    {.opcode = 0x57,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePushRegister},
    // POP AX
    {.opcode = 0x58,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePopRegister},
    // POP CX
    {.opcode = 0x59,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePopRegister},
    // POP DX
    {.opcode = 0x5A,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePopRegister},
    // POP BX
    {.opcode = 0x5B,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePopRegister},
    // POP SP
    {.opcode = 0x5C,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePopRegister},
    // POP BP
    {.opcode = 0x5D,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePopRegister},
    // POP SI
    {.opcode = 0x5E,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePopRegister},
    // POP DI
    {.opcode = 0x5F,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePopRegister},
    // 0x60 - 0x6F - UNSUPPORTED
    {.opcode = 0x60, .handler = 0},
    {.opcode = 0x61, .handler = 0},
    {.opcode = 0x62, .handler = 0},
    {.opcode = 0x63, .handler = 0},
    {.opcode = 0x64, .handler = 0},
    {.opcode = 0x65, .handler = 0},
    {.opcode = 0x66, .handler = 0},
    {.opcode = 0x67, .handler = 0},
    {.opcode = 0x68, .handler = 0},
    {.opcode = 0x69, .handler = 0},
    {.opcode = 0x6A, .handler = 0},
    {.opcode = 0x6B, .handler = 0},
    {.opcode = 0x6C, .handler = 0},
    {.opcode = 0x6D, .handler = 0},
    {.opcode = 0x6E, .handler = 0},
    {.opcode = 0x6F, .handler = 0},
    // JO rel8
    {.opcode = 0x70,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteUnsignedConditionalJump},
    // JNO rel8
    {.opcode = 0x71,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteUnsignedConditionalJump},
    // JB/JNAE/JC rel8
    {.opcode = 0x72,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteUnsignedConditionalJump},
    // JNB/JAE/JNC rel8
    {.opcode = 0x73,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteUnsignedConditionalJump},
    // JE/JZ rel8
    {.opcode = 0x74,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteUnsignedConditionalJump},
    // JNE/JNZ rel8
    {.opcode = 0x75,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteUnsignedConditionalJump},
    // JBE/JNA rel8
    {.opcode = 0x76,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteUnsignedConditionalJump},
    // JNBE/JA rel8
    {.opcode = 0x77,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteUnsignedConditionalJump},
    // JS rel8
    {.opcode = 0x78,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteUnsignedConditionalJump},
    // JNS rel8
    {.opcode = 0x79,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteUnsignedConditionalJump},
    // JP/JPE rel8
    {.opcode = 0x7A,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteUnsignedConditionalJump},
    // JNP/JPO rel8
    {.opcode = 0x7B,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteUnsignedConditionalJump},
    // JL/JNGE rel8
    {.opcode = 0x7C,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteSignedConditionalJumpJLOrJNL},
    // JNL/JGE rel8
    {.opcode = 0x7D,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteSignedConditionalJumpJLOrJNL},
    // JLE/JNG rel8
    {.opcode = 0x7E,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteSignedConditionalJumpJLEOrJNLE},
    // JNLE/JG rel8
    {.opcode = 0x7F,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteSignedConditionalJumpJLEOrJNLE},
    // ADD/OR/ADC/SBB/AND/SUB/XOR/CMP r/m8, imm8 (Group 1)
    {.opcode = 0x80,
     .has_modrm = true,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteGroup1Instruction},
    // ADD/OR/ADC/SBB/AND/SUB/XOR/CMP r/m16, imm16 (Group 1)
    {.opcode = 0x81,
     .has_modrm = true,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteGroup1Instruction},
    // ADD/OR/ADC/SBB/AND/SUB/XOR/CMP r/m8, imm8 (Group 1)
    {.opcode = 0x82,
     .has_modrm = true,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteGroup1Instruction},
    // ADD/OR/ADC/SBB/AND/SUB/XOR/CMP r/m16, imm8 (Group 1)
    {.opcode = 0x83,
     .has_modrm = true,
     // This is a special case - the immediate is 8 bits but the destination is
     // 16 bits.
     .immediate_size = 1,
     .width = kWord,
     .handler = ExecuteGroup1InstructionWithSignExtension},
    // TEST r/m8, r8
    {.opcode = 0x84,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteTestRegisterToRegisterOrMemory},
    // TEST r/m16, r16
    {.opcode = 0x85,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteTestRegisterToRegisterOrMemory},
    // XCHG r/m8, r8
    {.opcode = 0x86,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteExchangeRegisterOrMemory},
    // XCHG r/m16, r16
    {.opcode = 0x87,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteExchangeRegisterOrMemory},
    // MOV r/m8, r8
    {.opcode = 0x88,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteMoveRegisterToRegisterOrMemory},
    // MOV r/m16, r16
    {.opcode = 0x89,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteMoveRegisterToRegisterOrMemory},
    // MOV r8, r/m8
    {.opcode = 0x8A,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteMoveRegisterOrMemoryToRegister},
    // MOV r16, r/m16
    {.opcode = 0x8B,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteMoveRegisterOrMemoryToRegister},
    // MOV r/m16, sreg
    {.opcode = 0x8C,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteMoveSegmentRegisterToRegisterOrMemory},
    // LEA r16, m
    {.opcode = 0x8D,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteLoadEffectiveAddress},
    // MOV sreg, r/m16
    {.opcode = 0x8E,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteMoveRegisterOrMemoryToSegmentRegister},
    // POP r/m16
    {.opcode = 0x8F,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePopRegisterOrMemory},
    // XCHG AX, AX (NOP)
    {.opcode = 0x90,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteExchangeRegister},
    // XCHG AX, CX
    {.opcode = 0x91,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteExchangeRegister},
    // XCHG AX, DX
    {.opcode = 0x92,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteExchangeRegister},
    // XCHG AX, BX
    {.opcode = 0x93,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteExchangeRegister},
    // XCHG AX, SP
    {.opcode = 0x94,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteExchangeRegister},
    // XCHG AX, BP
    {.opcode = 0x95,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteExchangeRegister},
    // XCHG AX, SI
    {.opcode = 0x96,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteExchangeRegister},
    // XCHG AX, DI
    {.opcode = 0x97,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteExchangeRegister},
    // CBW
    {.opcode = 0x98,
     .has_modrm = false,
     .immediate_size = 0,
     .handler = ExecuteCbw},
    // CWD
    {.opcode = 0x99,
     .has_modrm = false,
     .immediate_size = 0,
     .handler = ExecuteCwd},
    // CALL ptr16:16 (4 bytes: 2 for offset, 2 for segment)
    {.opcode = 0x9A,
     .has_modrm = false,
     .immediate_size = 4,
     .width = kWord,
     .handler = ExecuteDirectFarCall},
    // WAIT
    {.opcode = 0x9B,
     .has_modrm = false,
     .immediate_size = 0,
     .handler = ExecuteNoOp},
    // PUSHF
    {.opcode = 0x9C,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePushFlags},
    // POPF
    {.opcode = 0x9D,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecutePopFlags},
    // SAHF
    {.opcode = 0x9E,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteStoreAHToFlags},
    // LAHF
    {.opcode = 0x9F,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteLoadAHFromFlags},
    // MOV AL, moffs16
    {.opcode = 0xA0,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kByte,
     .handler = ExecuteMoveMemoryOffsetToALOrAX},
    // MOV AX, moffs16
    {.opcode = 0xA1,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteMoveMemoryOffsetToALOrAX},
    // MOV moffs16, AL
    {.opcode = 0xA2,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kByte,
     .handler = ExecuteMoveALOrAXToMemoryOffset},
    // MOV moffs16, AX
    {.opcode = 0xA3,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteMoveALOrAXToMemoryOffset},
    // MOVSB
    {.opcode = 0xA4,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteMovs},
    // MOVSW
    {.opcode = 0xA5,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteMovs},
    // CMPSB
    {.opcode = 0xA6,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteCmps},
    // CMPSW
    {.opcode = 0xA7,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteCmps},
    // TEST AL, imm8
    {.opcode = 0xA8,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteTestImmediateToALOrAX},
    // TEST AX, imm16
    {.opcode = 0xA9,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteTestImmediateToALOrAX},
    // STOSB
    {.opcode = 0xAA,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteStos},
    // STOSW
    {.opcode = 0xAB,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteStos},
    // LODSB
    {.opcode = 0xAC,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteLods},
    // LODSW
    {.opcode = 0xAD,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteLods},
    // SCASB
    {.opcode = 0xAE,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteScas},
    // SCASW
    {.opcode = 0xAF,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteScas},
    // MOV AL, imm8
    {.opcode = 0xB0,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV CL, imm8
    {.opcode = 0xB1,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV DL, imm8
    {.opcode = 0xB2,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV BL, imm8
    {.opcode = 0xB3,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV AH, imm8
    {.opcode = 0xB4,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV CH, imm8
    {.opcode = 0xB5,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV DH, imm8
    {.opcode = 0xB6,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV BH, imm8
    {.opcode = 0xB7,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV AX, imm16
    {.opcode = 0xB8,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV CX, imm16
    {.opcode = 0xB9,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV DX, imm16
    {.opcode = 0xBA,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV BX, imm16
    {.opcode = 0xBB,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV SP, imm16
    {.opcode = 0xBC,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV BP, imm16
    {.opcode = 0xBD,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV SI, imm16
    {.opcode = 0xBE,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteMoveImmediateToRegister},
    // MOV DI, imm16
    {.opcode = 0xBF,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteMoveImmediateToRegister},
    // 0xC0 - UNSUPPORTED
    {.opcode = 0xC0, .handler = 0},
    // 0xC1 - UNSUPPORTED
    {.opcode = 0xC1, .handler = 0},
    // RET imm16
    {.opcode = 0xC2,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteNearReturnAndPop},
    // RET
    {.opcode = 0xC3,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteNearReturn},
    // LES r16, m32
    {.opcode = 0xC4,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteLoadESWithPointer},
    // LDS r16, m32
    {.opcode = 0xC5,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteLoadDSWithPointer},
    // MOV r/m8, imm8
    {.opcode = 0xC6,
     .has_modrm = true,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteMoveImmediateToRegisterOrMemory},
    // MOV r/m16, imm16
    {.opcode = 0xC7,
     .has_modrm = true,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteMoveImmediateToRegisterOrMemory},
    // 0xC8 - UNSUPPORTED
    {.opcode = 0xC8, .handler = 0},
    // 0xC9 - UNSUPPORTED
    {.opcode = 0xC9, .handler = 0},
    // RETF imm16
    {.opcode = 0xCA,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteFarReturnAndPop},
    // RETF
    {.opcode = 0xCB,
     .has_modrm = false,
     .immediate_size = 0,
     .handler = ExecuteFarReturn},
    // INT 3
    {.opcode = 0xCC,
     .has_modrm = false,
     .immediate_size = 0,
     .handler = ExecuteInt3},
    // INT imm8
    {.opcode = 0xCD,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteIntN},
    // INTO
    {.opcode = 0xCE,
     .has_modrm = false,
     .immediate_size = 0,
     .handler = ExecuteInto},
    // IRET
    {.opcode = 0xCF,
     .has_modrm = false,
     .immediate_size = 0,
     .handler = ExecuteIret},
    // ROL/ROR/RCL/RCR/SHL/SHR/SAR r/m8, 1 (Group 2)
    {.opcode = 0xD0,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteGroup2ShiftOrRotateBy1Instruction},
    // ROL/ROR/RCL/RCR/SHL/SHR/SAR r/m16, 1 (Group 2)
    {.opcode = 0xD1,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteGroup2ShiftOrRotateBy1Instruction},
    // ROL/ROR/RCL/RCR/SHL/SHR/SAR r/m8, CL (Group 2)
    {.opcode = 0xD2,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteGroup2ShiftOrRotateByCLInstruction},
    // ROL/ROR/RCL/RCR/SHL/SHR/SAR r/m16, CL (Group 2)
    {.opcode = 0xD3,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteGroup2ShiftOrRotateByCLInstruction},
    // AAM
    {.opcode = 0xD4,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteAam},
    // AAD
    {.opcode = 0xD5,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteAad},
    // 0xD6 - UNSUPPORTED
    {.opcode = 0xD6, .handler = 0},
    // XLAT/XLATB
    {.opcode = 0xD7,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteTranslateByte},
    // ESC instruction 0xD8 for 8087 numeric coprocessor
    {.opcode = 0xD8,
     .has_modrm = true,
     .immediate_size = 0,
     .handler = ExecuteNoOp},
    // ESC instruction 0xD9 for 8087 numeric coprocessor
    {.opcode = 0xD9,
     .has_modrm = true,
     .immediate_size = 0,
     .handler = ExecuteNoOp},
    // ESC instruction 0xDA for 8087 numeric coprocessor
    {.opcode = 0xDA,
     .has_modrm = true,
     .immediate_size = 0,
     .handler = ExecuteNoOp},
    // ESC instruction 0xDB for 8087 numeric coprocessor
    {.opcode = 0xDB,
     .has_modrm = true,
     .immediate_size = 0,
     .handler = ExecuteNoOp},
    // ESC instruction 0xDC for 8087 numeric coprocessor
    {.opcode = 0xDC,
     .has_modrm = true,
     .immediate_size = 0,
     .handler = ExecuteNoOp},
    // ESC instruction 0xDD for 8087 numeric coprocessor
    {.opcode = 0xDD,
     .has_modrm = true,
     .immediate_size = 0,
     .handler = ExecuteNoOp},
    // ESC instruction 0xDE for 8087 numeric coprocessor
    {.opcode = 0xDE,
     .has_modrm = true,
     .immediate_size = 0,
     .handler = ExecuteNoOp},
    // ESC instruction 0xDF for 8087 numeric coprocessor
    {.opcode = 0xDF,
     .has_modrm = true,
     .immediate_size = 0,
     .handler = ExecuteNoOp},
    // LOOPNE/LOOPNZ rel8
    {.opcode = 0xE0,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteLoopZOrNZ},
    // LOOPE/LOOPZ rel8
    {.opcode = 0xE1,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteLoopZOrNZ},
    // LOOP rel8
    {.opcode = 0xE2,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteLoop},
    // JCXZ rel8
    {.opcode = 0xE3,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteJumpIfCXIsZero},
    // IN AL, imm8
    {.opcode = 0xE4,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteInImmediate},
    // IN AX, imm8
    {.opcode = 0xE5,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kWord,
     .handler = ExecuteInImmediate},
    // OUT imm8, AL
    {.opcode = 0xE6,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteOutImmediate},
    // OUT imm8, AX
    {.opcode = 0xE7,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kWord,
     .handler = ExecuteOutImmediate},
    // CALL rel16
    {.opcode = 0xE8,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteDirectNearCall},
    // JMP rel16
    {.opcode = 0xE9,
     .has_modrm = false,
     .immediate_size = 2,
     .width = kWord,
     .handler = ExecuteShortOrNearJump},
    // JMP ptr16:16 (4 bytes: 2 for offset, 2 for segment)
    {.opcode = 0xEA,
     .has_modrm = false,
     .immediate_size = 4,
     .width = kWord,
     .handler = ExecuteDirectFarJump},
    // JMP rel8
    {.opcode = 0xEB,
     .has_modrm = false,
     .immediate_size = 1,
     .width = kByte,
     .handler = ExecuteShortOrNearJump},
    // IN AL, DX
    {.opcode = 0xEC,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteInDX},
    // IN AX, DX
    {.opcode = 0xED,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteInDX},
    // OUT DX, AL
    {.opcode = 0xEE,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteOutDX},
    // OUT DX, AX
    {.opcode = 0xEF,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteOutDX},
    // 0xF0 - LOCK prefix
    {.opcode = 0xF0, .handler = 0},
    // 0xF1 - UNSUPPORTED
    {.opcode = 0xF1, .handler = 0},
    // 0xF2 - REPNE prefix
    {.opcode = 0xF2, .handler = 0},
    // 0xF3 - REP/REPE prefix
    {.opcode = 0xF3, .handler = 0},
    // HLT
    {.opcode = 0xF4,
     .has_modrm = false,
     .immediate_size = 0,
     .handler = ExecuteHlt},
    // CMC
    {.opcode = 0xF5,
     .has_modrm = false,
     .immediate_size = 0,
     .handler = ExecuteComplementCarryFlag},
    // TEST/NOT/NEG/MUL/IMUL/DIV/IDIV r/m8 (Group 3)
    // The immediate size depends on the ModR/M byte.
    {.opcode = 0xF6,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteGroup3Instruction},
    // TEST/NOT/NEG/MUL/IMUL/DIV/IDIV r/m16 (Group 3)
    // The immediate size depends on the ModR/M byte.
    {.opcode = 0xF7,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteGroup3Instruction},
    // CLC
    {.opcode = 0xF8,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteClearOrSetFlag},
    // STC
    {.opcode = 0xF9,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteClearOrSetFlag},
    // CLI
    {.opcode = 0xFA,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteClearOrSetFlag},
    // STI
    {.opcode = 0xFB,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteClearOrSetFlag},
    // CLD
    {.opcode = 0xFC,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteClearOrSetFlag},
    // STD
    {.opcode = 0xFD,
     .has_modrm = false,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteClearOrSetFlag},
    // INC/DEC r/m8 (Group 4)
    {.opcode = 0xFE,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kByte,
     .handler = ExecuteGroup4Instruction},
    // INC/DEC/CALL/JMP/PUSH r/m16 (Group 5)
    {.opcode = 0xFF,
     .has_modrm = true,
     .immediate_size = 0,
     .width = kWord,
     .handler = ExecuteGroup5Instruction},
};


// ==============================================================================
// src/cpu/opcode_table.c end
// ==============================================================================

// ==============================================================================
// src/cpu/cpu.c start
// ==============================================================================

#line 1 "./src/cpu/cpu.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "instructions.h"
#include "operands.h"
#include "public.h"
#include "types.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// CPU state
// ============================================================================

void CPUInit(CPUState* cpu, CPUConfig* config) {
  // Zero out the CPU state
  const CPUState zero_cpu_state = {0};
  *cpu = zero_cpu_state;
  cpu->flags = kInitialFlags;
  cpu->config = config;
}

// ============================================================================
// Instruction decoding
// ============================================================================

// Helper to check if a byte is a valid prefix
static bool IsPrefixByte(uint8_t byte) {
  static const uint8_t kPrefixBytes[] = {
      kPrefixES,   kPrefixCS,    kPrefixSS,  kPrefixDS,
      kPrefixLOCK, kPrefixREPNZ, kPrefixREP,
  };
  for (uint8_t i = 0; i < sizeof(kPrefixBytes); ++i) {
    if (byte == kPrefixBytes[i]) {
      return true;
    }
  }
  return false;
}

// Helper to read the next instruction byte.
static uint8_t ReadNextInstructionByte(CPUState* cpu, uint16_t* ip) {
  OperandAddress address = {
      .type = kOperandAddressTypeMemory,
      .value = {
          .memory_address = {
              .segment_register_index = kCS,
              .offset = (*ip)++,
          }}};
  return ReadMemoryOperandByte(cpu, &address).value.byte_value;
}

// Returns the number of displacement bytes based on the ModR/M byte.
static uint8_t GetDisplacementSize(uint8_t mod, uint8_t rm) {
  switch (mod) {
    case 0:
      // Special case: 16-bit displacement
      return rm == 6 ? 2 : 0;
    case 1:
    case 2:
      // 8 or 16-bit displacement
      return mod;
    default:
      // No displacement
      return 0;
  }
}

// Returns the number of immediate bytes in an instruction.
static uint8_t GetImmediateSize(const OpcodeMetadata* metadata, uint8_t reg) {
  switch (metadata->opcode) {
    // TEST r/m8, imm8
    case 0xF6:
    // TEST r/m16, imm16
    case 0xF7:
      return reg == 0 ? metadata->opcode - 0xF5 : 0;
    default:
      return metadata->immediate_size;
  }
}

CPUFetchNextInstructionStatus CPUFetchNextInstruction(
    CPUState* cpu, Instruction* dest_instruction) {
  Instruction instruction = {0};
  uint8_t current_byte;
  const uint16_t original_ip = cpu->registers[kIP];
  uint16_t ip = cpu->registers[kIP];

  // Prefix
  current_byte = ReadNextInstructionByte(cpu, &ip);
  while (IsPrefixByte(current_byte)) {
    if (instruction.prefix_size >= kMaxPrefixBytes) {
      return kFetchPrefixTooLong;
    }
    instruction.prefix[instruction.prefix_size++] = current_byte;
    current_byte = ReadNextInstructionByte(cpu, &ip);
  }

  // Opcode
  instruction.opcode = current_byte;
  const OpcodeMetadata* metadata = &opcode_table[instruction.opcode];

  // ModR/M
  if (metadata->has_modrm) {
    uint8_t mod_rm_byte = ReadNextInstructionByte(cpu, &ip);
    instruction.has_mod_rm = true;
    instruction.mod_rm.mod = (mod_rm_byte >> 6) & 0x03;  // Bits 6-7
    instruction.mod_rm.reg = (mod_rm_byte >> 3) & 0x07;  // Bits 3-5
    instruction.mod_rm.rm = mod_rm_byte & 0x07;          // Bits 0-2

    // Displacement
    instruction.displacement_size =
        GetDisplacementSize(instruction.mod_rm.mod, instruction.mod_rm.rm);
    for (int i = 0; i < instruction.displacement_size; ++i) {
      instruction.displacement[i] = ReadNextInstructionByte(cpu, &ip);
    }
  }

  // Immediate operand
  instruction.immediate_size =
      GetImmediateSize(metadata, instruction.mod_rm.reg);
  for (int i = 0; i < instruction.immediate_size; ++i) {
    instruction.immediate[i] = ReadNextInstructionByte(cpu, &ip);
  }

  instruction.size = ip - original_ip;

  *dest_instruction = instruction;
  return kFetchSuccess;
}

// ============================================================================
// Execution
// ============================================================================

ExecuteStatus CPUExecuteInstruction(CPUState* cpu, Instruction* instruction) {
  ExecuteStatus status;

  // Run the on_before_execute_instruction callback if provided.
  if (cpu->config->on_before_execute_instruction &&
      (status = cpu->config->on_before_execute_instruction(cpu, instruction)) !=
          kExecuteSuccess) {
    return status;
  }

  const OpcodeMetadata* metadata = &opcode_table[instruction->opcode];
  if (!metadata->handler) {
    return kExecuteInvalidOpcode;
  }

  // Check encoded instruction against expected instruction format.
  if (instruction->has_mod_rm != metadata->has_modrm) {
    return kExecuteInvalidInstruction;
  }
  if (instruction->immediate_size !=
      (metadata->has_modrm ? GetImmediateSize(metadata, instruction->mod_rm.reg)
                           : metadata->immediate_size)) {
    return kExecuteInvalidInstruction;
  }

  // Run the instruction handler.
  InstructionContext context = {
      .cpu = cpu,
      .instruction = instruction,
      .metadata = metadata,
  };
  if ((status = metadata->handler(&context)) != kExecuteSuccess) {
    return status;
  }

  // Run the on_after_execute_instruction callback if provided.
  if (cpu->config->on_after_execute_instruction &&
      (status = cpu->config->on_after_execute_instruction(cpu, instruction)) !=
          kExecuteSuccess) {
    return status;
  }

  return kExecuteSuccess;
}

// Process pending interrupt, if any.
static ExecuteStatus ExecutePendingInterrupt(CPUState* cpu) {
  if (!cpu->has_pending_interrupt) {
    return kExecuteSuccess;
  }
  uint8_t interrupt_number = cpu->pending_interrupt_number;
  CPUClearPendingInterrupt(cpu);

  // Prepare for interrupt processing.
  cpu->is_halted = false;
  Push(cpu, WordValue(cpu->flags));
  CPUSetFlag(cpu, kIF, false);
  CPUSetFlag(cpu, kTF, false);
  Push(cpu, WordValue(cpu->registers[kCS]));
  Push(cpu, WordValue(cpu->registers[kIP]));

  // Invoke the interrupt handler callback first. If the caller did not provide
  // an interrupt handler callback, handle the interrupt within the VM using the
  // Interrupt Vector Table.
  ExecuteStatus interrupt_handler_status =
      cpu->config->handle_interrupt
          ? cpu->config->handle_interrupt(cpu, interrupt_number)
          : kExecuteUnhandledInterrupt;

  switch (interrupt_handler_status) {
    case kExecuteSuccess: {
      // If the interrupt was handled by the caller-provided interrupt handler
      // callback, restore state and continue execution.
      return ExecuteReturnFromInterrupt(cpu);
    }
    case kExecuteUnhandledInterrupt: {
      // If the interrupt was not handled by the caller-provided interrupt
      // handler callback, handle it within the VM using the Interrupt Vector
      // Table.
      uint16_t ivt_entry_offset = interrupt_number << 2;
      cpu->registers[kIP] = ReadRawMemoryWord(cpu, ivt_entry_offset);
      cpu->registers[kCS] = ReadRawMemoryWord(cpu, ivt_entry_offset + 2);
      return kExecuteSuccess;
    }
    default:
      // If the interrupt handler returned an error, return it.
      return interrupt_handler_status;
  }
}

ExecuteStatus CPUTick(CPUState* cpu) {
  ExecuteStatus status;

  // Execute next CPU instruction if not halted.
  if (!cpu->is_halted) {
    // Step 1: Fetch the next instruction, and increment IP.
    Instruction instruction;
    CPUFetchNextInstructionStatus fetch_status =
        CPUFetchNextInstruction(cpu, &instruction);
    if (fetch_status != kFetchSuccess) {
      return kExecuteInvalidInstruction;
    }
    cpu->registers[kIP] += instruction.size;

    // Step 2: Execute the instruction.
    status = CPUExecuteInstruction(cpu, &instruction);
    if (status != kExecuteSuccess && status != kExecuteHalt) {
      return status;
    }
  }

  // Step 3: Handle pending interrupts.
  if ((status = ExecutePendingInterrupt(cpu)) != kExecuteSuccess) {
    return status;
  }

  // Step 4: If trap flag is set, handle single-step execution.
  if (CPUGetFlag(cpu, kTF)) {
    CPUSetPendingInterrupt(cpu, kInterruptSingleStep);
    if ((status = ExecutePendingInterrupt(cpu)) != kExecuteSuccess) {
      return status;
    }
  }

  return kExecuteSuccess;
}



// ==============================================================================
// src/cpu/cpu.c end
// ==============================================================================


#endif  // YAX86_IMPLEMENTATION

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  // YAX86_CPU_BUNDLE_H

// ==============================================================================
// YAX86 DMA MODULE - GENERATED SINGLE HEADER BUNDLE
// ==============================================================================

#ifndef YAX86_DMA_BUNDLE_H
#define YAX86_DMA_BUNDLE_H

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// ==============================================================================
// src/dma/public.h start
// ==============================================================================

#line 1 "./src/dma/public.h"
// Public interface for the DMA (Direct Memory Access) module.
#ifndef YAX86_DMA_PUBLIC_H
#define YAX86_DMA_PUBLIC_H

// This module emulates the Intel 8237 DMA controller used in the IBM PC/XT.
// The DMA controller allows peripherals to transfer data directly to and from
// memory without involving the CPU, which is critical for high-speed devices
// like disk drives.
//
// The standard channel assignments are:
// - Channel 0: DRAM Refresh
// - Channel 1: Unused / Expansion
// - Channel 2: Floppy Disk Controller
// - Channel 3: Hard Disk Controller
//
// Note that we do not support all features of the 8237, only those needed to
// support GLaBIOS and basic PC/XT peripherals. Specifically:
// - DRAM Refresh on Channel 0 is not implemented, as it is disabled in the
//   target GLaBIOS build for emulators.
// - Memory-to-memory transfers are not supported.
// - Cascade Mode for multiple DMA controllers is not supported.
// - Advanced transfer modes (Demand, Block) and priorities (Rotating) are not
//   supported. Only Single Cycle mode with Fixed Priority is implemented.

#include <stdbool.h>
#include <stdint.h>

// I/O ports for the 8237 DMA Controller and Page Registers.
typedef enum DMAPort {
  // --- 8237 DMA Controller ---
  // Channel 0 base and current address
  kDMAPortChannel0Address = 0x00,
  // Channel 0 base and current word count
  kDMAPortChannel0Count = 0x01,
  // Channel 1 base and current address
  kDMAPortChannel1Address = 0x02,
  // Channel 1 base and current word count
  kDMAPortChannel1Count = 0x03,
  // Channel 2 base and current address
  kDMAPortChannel2Address = 0x04,
  // Channel 2 base and current word count
  kDMAPortChannel2Count = 0x05,
  // Channel 3 base and current address
  kDMAPortChannel3Address = 0x06,
  // Channel 3 base and current word count
  kDMAPortChannel3Count = 0x07,
  // Read: Status Register / Write: Command Register
  kDMAPortCommandStatus = 0x08,
  // Write: Request Register
  kDMAPortRequest = 0x09,
  // Write: Set/Clear a single channel's mask bit
  kDMAPortSingleMask = 0x0A,
  // Write: Mode Register
  kDMAPortMode = 0x0B,
  // Write: Clear Byte Pointer Flip-Flop
  kDMAPortFlipFlopReset = 0x0C,
  // Write: Master Reset
  kDMAPortMasterReset = 0x0D,
  // Write: Mask Register (for all channels)
  kDMAPortAllMask = 0x0F,

  // --- 74LS670 Page Registers ---
  // Page register for Channel 2 (Floppy)
  kDMAPortPageChannel2 = 0x81,
  // Page register for Channel 3 (Hard Drive)
  kDMAPortPageChannel3 = 0x82,
  // Page register for Channel 1
  kDMAPortPageChannel1 = 0x83,
  // Page register for Channel 0
  kDMAPortPageChannel0 = 0x87,
} DMAPort;

// Bit definitions for the Mode Register (Port 0x0B)
enum {
  // --- Channel Select (bits 0-1) ---
  // Select channel 0
  kDMAModeSelectChannel0 = 0x00,
  // Select channel 1
  kDMAModeSelectChannel1 = 0x01,
  // Select channel 2
  kDMAModeSelectChannel2 = 0x02,
  // Select channel 3
  kDMAModeSelectChannel3 = 0x03,

  // --- Transfer Type (bits 2-3) ---
  // Verify transfer (no data is moved)
  kDMAModeTransferTypeVerify = 0x00,
  // Write to memory (device -> memory)
  kDMAModeTransferTypeWrite = 0x04,
  // Read from memory (memory -> device)
  kDMAModeTransferTypeRead = 0x08,

  // --- Auto-initialization (bit 4) ---
  // If set, the channel reloads its base address and count after a transfer.
  kDMAModeAutoInitialize = 0x10,

  // --- Address Direction (bit 5) ---
  // If set, the memory address is decremented; otherwise, it is incremented.
  kDMAModeAddressDecrement = 0x20,

  // --- Transfer Mode (bits 6-7) ---
  // Demand mode: transfer bytes until the DREQ line becomes inactive.
  kDMAModeDemand = 0x00,
  // Single mode: transfer one byte for each DREQ signal.
  kDMAModeSingle = 0x40,
  // Block mode: transfer an entire block of data in response to a single DREQ.
  kDMAModeBlock = 0x80,
  // Cascade mode: used for chaining multiple DMA controllers (not supported).
  kDMAModeCascade = 0xC0,
};

enum {
  // Number of DMA channels in the controller.
  kDMANumChannels = 4,
};

// ============================================================================
// DMA state
// ============================================================================

struct DMAState;

// Caller-provided runtime configuration for the DMA controller.
typedef struct DMAConfig {
  // Custom data passed through to callbacks.
  void* context;

  // Callback to read a byte from system memory.
  uint8_t (*read_memory_byte)(void* context, uint32_t address);
  // Callback to write a byte to system memory.
  void (*write_memory_byte)(void* context, uint32_t address, uint8_t value);

  // Callback to read a byte from a peripheral for a specific DMA channel.
  uint8_t (*read_device_byte)(void* context, uint8_t channel);
  // Callback to write a byte to a peripheral for a specific DMA channel.
  void (*write_device_byte)(void* context, uint8_t channel, uint8_t value);

  // Callback to notify the system that a channel has reached its terminal count.
  // This corresponds to the EOP (End of Process) signal on the 8237, which is
  // connected to the TC (Terminal Count) pin on devices like the FDC.
  void (*on_terminal_count)(void* context, uint8_t channel);
} DMAConfig;

// State for a single DMA channel.
typedef struct DMAChannelState {
  // Base address register, reloaded on auto-initialization.
  uint16_t base_address;
  // Current address register, updated during a transfer.
  uint16_t current_address;
  // Base count register, reloaded on auto-initialization.
  uint16_t base_count;
  // Current count register, updated during a transfer.
  uint16_t current_count;
  // Mode register for this channel.
  uint8_t mode;
  // High-order address bits from the page register.
  uint8_t page_register;
} DMAChannelState;

// Which register byte to read/write next.
typedef enum DMARegisterByte {
  // Read or write the lower byte next.
  kDMARegisterLSB = 0,
  // Read or write the upper byte next.
  kDMARegisterMSB = 1,
} DMARegisterByte;

// State for the entire 8237 DMA controller.
typedef struct DMAState {
  // Pointer to the DMA configuration.
  DMAConfig* config;

  // The four DMA channels.
  DMAChannelState channels[kDMANumChannels];

  // Command register for the controller.
  uint8_t command_register;
  // Status register (Terminal Count and Request flags).
  uint8_t status_register;
  // Software request register.
  uint8_t request_register;
  // Mask register for all four channels.
  uint8_t mask_register;

  // Internal byte flip-flop for 16-bit register access.
  DMARegisterByte rw_byte;
} DMAState;

// ============================================================================
// DMA interface
// ============================================================================

// Initializes the DMA state to its power-on default.
void DMAInit(DMAState* dma, DMAConfig* config);

// Handles reads from the DMA's I/O ports.
uint8_t DMAReadPort(DMAState* dma, uint16_t port);

// Handles writes to the DMA's I/O ports.
void DMAWritePort(DMAState* dma, uint16_t port, uint8_t value);

// Executes a single-byte transfer for the specified channel. This function
// should be called by the platform in response to a DREQ signal from a
// peripheral.
void DMATransferByte(DMAState* dma, uint8_t channel_index);

#endif  // YAX86_DMA_PUBLIC_H



// ==============================================================================
// src/dma/public.h end
// ==============================================================================


#ifdef YAX86_IMPLEMENTATION

// ==============================================================================
// src/dma/dma.c start
// ==============================================================================

#line 1 "./src/dma/dma.c"
#ifndef YAX86_IMPLEMENTATION
#include "public.h"
#endif  // YAX86_IMPLEMENTATION

void DMAInit(DMAState* dma, DMAConfig* config) {
  static const DMAState zero_dma_state = {0};
  *dma = zero_dma_state;

  dma->config = config;

  // Mask all channels by default on power-on.
  dma->mask_register = 0x0F;
}

// Helper to read a 16-bit value byte-by-byte using the flip-flop.
static inline uint8_t DMAReadRegisterByte(DMAState* dma, uint16_t value) {
  uint8_t byte;
  if (dma->rw_byte == kDMARegisterMSB) {
    byte = (value >> 8) & 0xFF;
    dma->rw_byte = kDMARegisterLSB;
  } else {
    byte = value & 0xFF;
    dma->rw_byte = kDMARegisterMSB;
  }
  return byte;
}

uint8_t DMAReadPort(DMAState* dma, uint16_t port) {
  switch (port) {
    // Channel Address and Count Registers (ports 0x00-0x07)
    case kDMAPortChannel0Address:
    case kDMAPortChannel0Count:
    case kDMAPortChannel1Address:
    case kDMAPortChannel1Count:
    case kDMAPortChannel2Address:
    case kDMAPortChannel2Count:
    case kDMAPortChannel3Address:
    case kDMAPortChannel3Count: {
      const int channel_index = port / 2;
      const bool is_count_register = port % 2;
      const DMAChannelState* channel = &dma->channels[channel_index];
      return DMAReadRegisterByte(
          dma, is_count_register ? channel->current_count
                                 : channel->current_address);
    }

    // Status Register (port 0x08)
    case kDMAPortCommandStatus: {
      uint8_t status = dma->status_register;
      dma->status_register = 0;  // Clear TC flags on read
      return status;
    }

    // All other ports are write-only or unused for reads.
    default:
      return 0xFF;
  }
}

// Helper to write a 16-bit value byte-by-byte using the flip-flop.
// Note: Writes update both the 'base' and 'current' registers.
static inline void DMAWriteRegisterByte(
    DMAState* dma, uint16_t* base_reg, uint16_t* current_reg, uint8_t value) {
  if (dma->rw_byte == kDMARegisterMSB) {
    // Second write sets the high byte.
    *base_reg = (*base_reg & 0x00FF) | ((uint16_t)value << 8);
    dma->rw_byte = kDMARegisterLSB;
  } else {
    // First write sets the low byte.
    *base_reg = (*base_reg & 0xFF00) | value;
    dma->rw_byte = kDMARegisterMSB;
  }
  // The 'current' register always mirrors the 'base' register after a write.
  *current_reg = *base_reg;
}

void DMAWritePort(DMAState* dma, uint16_t port, uint8_t value) {
  switch (port) {
    // Channel Address and Count Registers (ports 0x00-0x07)
    case kDMAPortChannel0Address:
    case kDMAPortChannel0Count:
    case kDMAPortChannel1Address:
    case kDMAPortChannel1Count:
    case kDMAPortChannel2Address:
    case kDMAPortChannel2Count:
    case kDMAPortChannel3Address:
    case kDMAPortChannel3Count: {
      const int channel_index = port / 2;
      const bool is_count_register = port % 2;
      DMAChannelState* channel = &dma->channels[channel_index];

      if (is_count_register) {
        DMAWriteRegisterByte(
            dma, &channel->base_count, &channel->current_count, value);
      } else {
        DMAWriteRegisterByte(
            dma, &channel->base_address, &channel->current_address, value);
      }
      break;
    }

    // Command Register (port 0x08)
    case kDMAPortCommandStatus:
      dma->command_register = value;
      break;

    // Request Register (port 0x09)
    case kDMAPortRequest:
      dma->request_register = value;
      break;

    // Single Mask Register (port 0x0A)
    case kDMAPortSingleMask: {
      const int channel_index = value & 0x03;
      const bool should_mask = (value >> 2) & 1;
      if (should_mask) {
        dma->mask_register |= (1 << channel_index);
      } else {
        dma->mask_register &= ~(1 << channel_index);
      }
      break;
    }

    // Mode Register (port 0x0B)
    case kDMAPortMode: {
      const int channel_index = value & 0x03;
      dma->channels[channel_index].mode = value;
      break;
    }

    // Clear Byte Pointer Flip-Flop (port 0x0C)
    case kDMAPortFlipFlopReset:
      dma->rw_byte = kDMARegisterLSB;
      break;

    // Master Reset (port 0x0D)
    case kDMAPortMasterReset:
      DMAInit(dma, dma->config);
      break;

    // Mask Register for all channels (port 0x0F)
    case kDMAPortAllMask:
      dma->mask_register = value & 0x0F;
      break;

    // Page Registers
    case kDMAPortPageChannel0:
      dma->channels[0].page_register = value;
      break;
    case kDMAPortPageChannel1:
      dma->channels[1].page_register = value;
      break;
    case kDMAPortPageChannel2:
      dma->channels[2].page_register = value;
      break;
    case kDMAPortPageChannel3:
      dma->channels[3].page_register = value;
      break;

    default:
      // Ignore writes to read-only or unused ports.
      break;
  }
}

void DMATransferByte(DMAState* dma, uint8_t channel_index) {
  if (channel_index >= kDMANumChannels) {
    return;
  }
  DMAChannelState* channel = &dma->channels[channel_index];

  // Check if controller is disabled (bit 2 of command register).
  if ((dma->command_register & 0x04) != 0) {
    return;
  }

  // If channel is masked, do nothing.
  if ((dma->mask_register & (1 << channel_index)) != 0) {
    return;
  }

  // Construct full 20-bit memory address
  const uint32_t address =
      ((uint32_t)channel->page_register << 16) | channel->current_address;

  // Perform transfer based on type (bits 2-3 of mode register)
  const uint8_t transfer_type = channel->mode & (0x03 << 2);
  switch (transfer_type) {
    case kDMAModeTransferTypeVerify:  // Verify - no actual transfer
      break;
    case kDMAModeTransferTypeWrite:  // Write to memory (device -> memory)
      if (dma->config->read_device_byte && dma->config->write_memory_byte) {
        const uint8_t data =
            dma->config->read_device_byte(dma->config->context, channel_index);
        dma->config->write_memory_byte(dma->config->context, address, data);
      }
      break;
    case kDMAModeTransferTypeRead:  // Read from memory (memory -> device)
      if (dma->config->read_memory_byte && dma->config->write_device_byte) {
        const uint8_t data =
            dma->config->read_memory_byte(dma->config->context, address);
        dma->config->write_device_byte(
            dma->config->context, channel_index, data);
      }
      break;
    default:
      // Invalid/reserved mode, do nothing
      break;
  }



  // Update address register
  if ((channel->mode & kDMAModeAddressDecrement) == 0) {
    ++channel->current_address;
  } else {
    --channel->current_address;
  }

  // Update count register and check for Terminal Count (TC)
  --channel->current_count;
  if (channel->current_count == 0xFFFF) {
    // Set TC bit in status register
    dma->status_register |= (1 << channel_index);

    // Notify the system that TC has been reached.
    if (dma->config->on_terminal_count) {
      dma->config->on_terminal_count(dma->config->context, channel_index);
    }

    // Handle auto-initialization or mask the channel
    if ((channel->mode & kDMAModeAutoInitialize) != 0) {
      channel->current_address = channel->base_address;
      channel->current_count = channel->base_count;
    } else {
      dma->mask_register |= (1 << channel_index);
    }
  }
}



// ==============================================================================
// src/dma/dma.c end
// ==============================================================================


#endif  // YAX86_IMPLEMENTATION

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  // YAX86_DMA_BUNDLE_H

// ==============================================================================
// YAX86 FDC MODULE - GENERATED SINGLE HEADER BUNDLE
// ==============================================================================

#ifndef YAX86_FDC_BUNDLE_H
#define YAX86_FDC_BUNDLE_H

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// ==============================================================================
// src/util/static_vector.h start
// ==============================================================================

#line 1 "./src/util/static_vector.h"
// Static vector library.
//
// A static vector is a vector backed by a fixed-size array. It's essentially
// a vector, but whose underlying storage is statically allocated and does not
// rely on dynamic memory allocation.

#ifndef YAX86_UTIL_STATIC_VECTOR_H
#define YAX86_UTIL_STATIC_VECTOR_H

#include <stddef.h>
#include <stdint.h>

// Header structure at the beginning of a static vector.
typedef struct StaticVectorHeader {
  // Element size in bytes.
  size_t element_size;
  // Maximum number of elements the vector can hold.
  size_t max_length;
  // Number of elements currently in the vector.
  size_t length;
} StaticVectorHeader;

// Define a static vector type with an element type.
#define STATIC_VECTOR_TYPE(name, element_type, max_length_value)          \
  typedef struct name {                                                   \
    StaticVectorHeader header;                                            \
    element_type elements[max_length_value];                              \
  } name;                                                                 \
  static void name##Init(name* vector) __attribute__((unused));           \
  static void name##Init(name* vector) {                                  \
    static const StaticVectorHeader header = {                            \
        .element_size = sizeof(element_type),                             \
        .max_length = (max_length_value),                                 \
        .length = 0,                                                      \
    };                                                                    \
    vector->header = header;                                              \
  }                                                                       \
  static size_t name##Length(const name* vector) __attribute__((unused)); \
  static size_t name##Length(const name* vector) {                        \
    return vector->header.length;                                         \
  }                                                                       \
  static element_type* name##Get(name* vector, size_t index)              \
      __attribute__((unused));                                            \
  static element_type* name##Get(name* vector, size_t index) {            \
    if (index >= (max_length_value)) {                                    \
      return NULL;                                                        \
    }                                                                     \
    return &(vector->elements[index]);                                    \
  }                                                                       \
  static bool name##Append(name* vector, const element_type* element)     \
      __attribute__((unused));                                            \
  static bool name##Append(name* vector, const element_type* element) {   \
    if (vector->header.length >= (max_length_value)) {                    \
      return false;                                                       \
    }                                                                     \
    vector->elements[vector->header.length++] = *element;                 \
    return true;                                                          \
  }                                                                       \
  static bool name##Insert(                                               \
      name* vector, size_t index, const element_type* element)            \
      __attribute__((unused));                                            \
  static bool name##Insert(                                               \
      name* vector, size_t index, const element_type* element) {          \
    if (index > vector->header.length ||                                  \
        vector->header.length >= (max_length_value)) {                    \
      return false;                                                       \
    }                                                                     \
    for (size_t i = vector->header.length; i > index; --i) {              \
      vector->elements[i] = vector->elements[i - 1];                      \
    }                                                                     \
    vector->elements[index] = *element;                                   \
    ++vector->header.length;                                              \
    return true;                                                          \
  }                                                                       \
  static bool name##Remove(name* vector, size_t index)                    \
      __attribute__((unused));                                            \
  static bool name##Remove(name* vector, size_t index) {                  \
    if (index >= vector->header.length) {                                 \
      return false;                                                       \
    }                                                                     \
    for (size_t i = index; i < vector->header.length - 1; ++i) {          \
      vector->elements[i] = vector->elements[i + 1];                      \
    }                                                                     \
    --vector->header.length;                                              \
    return true;                                                          \
  }                                                                       \
  static void name##Clear(name* vector) __attribute__((unused));          \
  static void name##Clear(name* vector) { vector->header.length = 0; }

#endif  // YAX86_UTIL_STATIC_VECTOR_H


// ==============================================================================
// src/util/static_vector.h end
// ==============================================================================

// ==============================================================================
// src/fdc/public.h start
// ==============================================================================

#line 1 "./src/fdc/public.h"
// Public interface for the Floppy Disk Controller (FDC) module.
#ifndef YAX86_FDC_PUBLIC_H
#define YAX86_FDC_PUBLIC_H

// This module emulates the NEC uPD765 Floppy Disk Controller. It handles I/O
// port communication and DMA transfers for floppy operations. Actual disk
// image access is delegated to the platform via callbacks.

#include <stdbool.h>
#include <stdint.h>

#ifndef YAX86_FDC_BUNDLE_H
#include "../util/static_vector.h"
#endif  // YAX86_FDC_BUNDLE_H

// Floppy disk format configuration.
typedef struct FDCDiskFormat {
  // Number of heads (1 or 2).
  uint8_t num_heads;
  // Number of tracks.
  uint8_t num_tracks;
  // Number of sectors per track.
  uint8_t num_sectors_per_track;
  // Size of each sector in bytes.
  uint16_t sector_size;
} FDCDiskFormat;

// 5.25" 360KB double-sided double-density floppy disk format.
static const FDCDiskFormat kFDCFormat360KB = {
    .num_heads = 2,
    .num_tracks = 40,
    .num_sectors_per_track = 9,
    .sector_size = 512,
};

struct FDCState;

enum {
  // Number of floppy drives supported by the FDC.
  kFDCNumDrives = 4,
  // Maximum size of a command request.
  kFDCCommandBufferSize = 9,
  // Maximum size of a command result.
  kFDCResultBufferSize = 7,
};

// Command phases of the FDC.
typedef enum FDCCommandPhase {
  // No command in progress.
  kFDCPhaseIdle = 0,
  // Command has been issued, waiting for parameters.
  kFDCPhaseCommand,
  // Command parameters received, executing command.
  kFDCPhaseExecution,
  // Command execution complete, sending result bytes.
  kFDCPhaseResult,
} FDCCommandPhase;

// I/O ports for the FDC.
typedef enum FDCPort {
  // Digital Output Register (write-only).
  kFDCPortDOR = 0x3F2,
  // Main Status Register (read-only).
  kFDCPortMSR = 0x3F4,
  // Data Register (read/write).
  kFDCPortData = 0x3F5,
} FDCPort;

// Flags for the Main Status Register (MSR).
enum {
  // Drive 0 is busy with a seek or recalibrate command.
  kFDCMSRDrive0Busy = 1 << 0,
  // Drive 1 is busy with a seek or recalibrate command.
  kFDCMSRDrive1Busy = 1 << 1,
  // Drive 2 is busy with a seek or recalibrate command.
  kFDCMSRDrive2Busy = 1 << 2,
  // Drive 3 is busy with a seek or recalibrate command.
  kFDCMSRDrive3Busy = 1 << 3,
  // A command is in progress.
  kFDCMSRBusy = 1 << 4,
  // The FDC is in non-DMA mode.
  kFDCMSRNonDMAMode = 1 << 5,
  // Indicates direction of data transfer. 0 = write to FDC, 1 = read from FDC.
  kFDCMSRDataDirection = 1 << 6,
  // The Data Register is ready to send or receive data to/from the CPU.
  kFDCMSRRequestForMaster = 1 << 7,
};

// Flags for the Digital Output Register (DOR).
enum {
  // Drive selection (0-3).
  kFDCDORDriveSelectMask = 0x03,
  // Controller reset (0 = Reset active, 1 = Controller enabled).
  kFDCDORReset = 1 << 2,
  // DMA and Interrupt enable (1 = enabled).
  kFDCDORInterruptEnable = 1 << 3,
  // Motor enable flags for drives 0-3.
  kFDCDORMotor0Enable = 1 << 4,
  kFDCDORMotor1Enable = 1 << 5,
  kFDCDORMotor2Enable = 1 << 6,
  kFDCDORMotor3Enable = 1 << 7,
};

// Flags for Status Register 0 (ST0).
enum {
  // Bits 7-6: Interrupt Code
  // 00 = Normal termination
  // 01 = Abnormal termination
  // 10 = Invalid command
  // 11 = Abnormal termination due to polling (Post-reset)
  kFDCST0InterruptCodeMask = 0xC0,
  kFDCST0NormalTermination = 0x00,
  kFDCST0AbnormalTermination = 0x40,
  kFDCST0InvalidCommand = 0x80,
  kFDCST0AbnormalTerminationPolling = 0xC0,

  // Bit 5: Seek End
  kFDCST0SeekEnd = 1 << 5,
  // Bit 4: Equipment Check
  kFDCST0EquipmentCheck = 1 << 4,
  // Bit 3: Not Ready
  kFDCST0NotReady = 1 << 3,
  // Bit 2: Head Address
  kFDCST0HeadAddress = 1 << 2,
  // Bits 1-0: Drive Select
  kFDCST0UnitSelectMask = 0x03,
};

// Flags for Status Register 1 (ST1).
enum {
  // Bit 7: End of Cylinder
  kFDCST1EndOfCylinder = 1 << 7,
  // Bit 5: Data Error
  kFDCST1DataError = 1 << 5,
  // Bit 4: Overrun
  kFDCST1Overrun = 1 << 4,
  // Bit 2: No Data
  kFDCST1NoData = 1 << 2,
  // Bit 1: Not Writable
  kFDCST1NotWritable = 1 << 1,
  // Bit 0: Missing Address Mark
  kFDCST1MissingAddressMark = 1 << 0,
};

// Flags for Status Register 2 (ST2).
enum {
  // Bit 6: Control Mark
  kFDCST2ControlMark = 1 << 6,
  // Bit 5: Data Error in Data Field
  kFDCST2DataErrorInDataField = 1 << 5,
  // Bit 4: Wrong Cylinder
  kFDCST2WrongCylinder = 1 << 4,
  // Bit 3: Scan Equal Hit
  kFDCST2ScanEqualHit = 1 << 3,
  // Bit 2: Scan Not Satisfied
  kFDCST2ScanNotSatisfied = 1 << 2,
  // Bit 1: Bad Cylinder
  kFDCST2BadCylinder = 1 << 1,
  // Bit 0: Missing Address Mark in Data Field
  kFDCST2MissingAddressMarkInDataField = 1 << 0,
};

// State for a single floppy drive.
typedef struct FDCDriveState {
  // Whether there is a disk inserted in the drive, i.e. whether an image is
  // mounted. The real hardware doesn't actually know this and will attempt to
  // access the disk and time out.
  bool present;
  // The format of the disk currently inserted in the drive.
  const FDCDiskFormat* format;
  // The track the read/write head is currently on.
  uint8_t track;
  // The currently active head (0 or 1).
  uint8_t head;
  // Whether the drive is currently busy.
  bool busy;
  // Status Register 0 (ST0) for the last completed Seek or Recalibrate
  // operation on this drive.
  uint8_t st0;
  // Whether there is a pending interrupt from a completed Seek or Recalibrate
  // operation on this drive.
  bool has_pending_interrupt;
} FDCDriveState;

// Caller-provided runtime configuration for the FDC.
typedef struct FDCConfig {
  // Custom data passed through to callbacks.
  void* context;

  // Callback to raise an IRQ6 (FDC interrupt) to the CPU.
  void (*raise_irq6)(void* context);

  // Callback to signal the platform to execute a DMA cycle for Channel 2.
  // This represents the DREQ (DMA Request) signal.
  void (*request_dma)(void* context);

  // Callback to read a byte from a floppy image.
  uint8_t (*read_image_byte)(
      void* context,
      // 0 to kFDCNumDrives-1
      uint8_t drive,
      // byte offset within the image
      uint32_t offset);

  // Callback to write a byte to a floppy image.
  void (*write_image_byte)(
      void* context,
      // 0 to kFDCNumDrives-1
      uint8_t drive,
      // byte offset within the image
      uint32_t offset,
      // byte value to write
      uint8_t value);
} FDCConfig;

STATIC_VECTOR_TYPE(FDCCommandBuffer, uint8_t, kFDCCommandBufferSize)
STATIC_VECTOR_TYPE(FDCResultBuffer, uint8_t, kFDCResultBufferSize)

struct FDCCommandMetadata;

// State of the Floppy Disk Controller.
typedef struct FDCState {
  // Pointer to the FDC configuration.
  FDCConfig* config;

  // Value of the Digital Output Register (DOR) from the last write to port
  // 0x3F2.
  uint8_t dor;

  // Per-drive state.
  FDCDriveState drives[kFDCNumDrives];

  // Current command phase.
  FDCCommandPhase phase;

  // Command buffer to receive command and parameters from the CPU.
  FDCCommandBuffer command_buffer;
  // Metadata for the command currently being processed.
  const struct FDCCommandMetadata* current_command;
  // How many ticks the current command has been executing.
  uint32_t current_command_ticks;

  // Result buffer to send to the CPU.
  FDCResultBuffer result_buffer;
  // Next index to read from result buffer.
  uint8_t next_result_byte_index;

  // State specific to the execution of a data transfer command
  // (Read/Write/Format).
  struct {
    // Current logical position on the disk during transfer.
    uint8_t cylinder;
    uint8_t head;
    uint8_t sector;

    // Command parameters governing the transfer.
    uint8_t sector_size_code;  // N
    uint8_t eot;               // End of Track sector number
    bool multi_track;          // MT bit set (read/write across heads)

    // Internal tracking.
    uint32_t current_offset;  // Current byte offset in the disk image.
    uint16_t
        sector_byte_index;  // Current byte index within the current sector.
    uint8_t data_register;  // Buffer for the byte currently being transferred.
    bool dma_request_active;  // DREQ is asserted, waiting for DMA access.
    bool tc_received;         // TC (Terminal Count) signal received from DMA.
  } transfer;
} FDCState;

// Initializes the FDC to its power-on state.
void FDCInit(FDCState* fdc, FDCConfig* config);

// Handles reads from the FDC's I/O ports.
uint8_t FDCReadPort(FDCState* fdc, uint16_t port);

// Handles writes to the FDC's I/O ports.
void FDCWritePort(FDCState* fdc, uint16_t port, uint8_t value);

// Signals to the FDC that the DMA controller has reached the terminal count.
// This represents the TC signal.
void FDCHandleTC(FDCState* fdc);

// Inserts a disk with the given format into the specified drive.
void FDCInsertDisk(FDCState* fdc, uint8_t drive, const FDCDiskFormat* format);

// Ejects the disk from the specified drive.
void FDCEjectDisk(FDCState* fdc, uint8_t drive);

// Simulates a tick of the FDC, handling any timed operations.
void FDCTick(FDCState* fdc);

#endif  // YAX86_FDC_PUBLIC_H



// ==============================================================================
// src/fdc/public.h end
// ==============================================================================


#ifdef YAX86_IMPLEMENTATION

// ==============================================================================
// src/fdc/fdc.c start
// ==============================================================================

#line 1 "./src/fdc/fdc.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "public.h"
#endif  // YAX86_IMPLEMENTATION

#include <stddef.h>

enum {
  // Invalid offset.
  kFDCInvalidOffset = 0xFFFFFFF,
};

// FDC command opcodes.
typedef enum FDCCommand {
  // Read a Track
  kFDCCmdReadTrack = 0x02,
  // Specify
  kFDCCmdSpecify = 0x03,
  // Sense Drive Status
  kFDCCmdSenseDriveStatus = 0x04,
  // Write Data
  kFDCCmdWriteData = 0x05,
  // Read Data
  kFDCCmdReadData = 0x06,
  // Recalibrate
  kFDCCmdRecalibrate = 0x07,
  // Sense Interrupt Status
  kFDCCmdSenseInterruptStatus = 0x08,
  // Write Deleted Data
  kFDCCmdWriteDeletedData = 0x09,
  // Read ID
  kFDCCmdReadID = 0x0A,
  // Read Deleted Data
  kFDCCmdReadDeletedData = 0x0C,
  // Format a Track
  kFDCCmdFormatTrack = 0x0D,
  // Seek
  kFDCCmdSeek = 0x0F,
  // Scan Equal
  kFDCCmdScanEqual = 0x11,
  // Scan Low or Equal
  kFDCCmdScanLowOrEqual = 0x19,
  // Scan High or Equal
  kFDCCmdScanHighOrEqual = 0x1D,
} FDCCommand;

// Metadata for each FDC command.
typedef struct FDCCommandMetadata {
  // Base opcode of the command (lower 5 bits).
  uint8_t opcode;
  // Number of parameter bytes expected.
  uint8_t num_param_bytes;
  // Handler to execute the command.
  void (*handler)(FDCState* fdc);
} FDCCommandMetadata;

// Helper to raise an IRQ6 if the callback is set and interrupts are enabled in
// DOR.
static inline void FDCRaiseIRQ6(FDCState* fdc) {
  if (fdc->config && fdc->config->raise_irq6 &&
      (fdc->dor & kFDCDORInterruptEnable)) {
    fdc->config->raise_irq6(fdc->config->context);
  }
}

// Transition into execution phase.
static inline void FDCStartCommandExecution(FDCState* fdc) {
  fdc->phase = kFDCPhaseExecution;
  fdc->current_command_ticks = 0;
}

// Transition into result phase after command execution.
static inline void FDCFinishCommandExecution(FDCState* fdc) {
  if (FDCResultBufferLength(&fdc->result_buffer) == 0) {
    // No result bytes to send, go back to idle phase.
    fdc->phase = kFDCPhaseIdle;
  } else {
    // Has result bytes to send, go to result phase.
    fdc->phase = kFDCPhaseResult;
    fdc->next_result_byte_index = 0;
  }
}

// Helper to perform a seek operation (for Seek and Recalibrate).
static void FDCPerformSeek(
    FDCState* fdc, uint8_t drive_index, uint8_t target_track) {
  FDCDriveState* drive = &fdc->drives[drive_index];

  // On initial tick, start seeking.
  if (fdc->current_command_ticks == 0) {
    drive->busy = true;
    return;
  }

  // On 2nd tick, seek is complete.
  drive->track = target_track;
  drive->busy = false;

  // Set Status Register 0 (ST0)
  // Bits 7-6: Interrupt Code = 00 (Normal Termination)
  // Bit 5: Seek End = 1
  // Bits 1-0: Unit Select (Drive Index)
  drive->st0 = kFDCST0NormalTermination | kFDCST0SeekEnd | drive_index;

  // Set interrupt pending flag for this drive.
  drive->has_pending_interrupt = true;

  // Raise Interrupt (IRQ6).
  FDCRaiseIRQ6(fdc);

  FDCFinishCommandExecution(fdc);
}

// Compute the byte offset within a disk image for the given address. Returns
// kFDCInvalidOffset if the address is out of range.
//
// In a raw image file, the data is laid out track by track, starting from the
// outermost track (Track 0). Within each track, it reads all the data from the
// first head (Head 0, the top side) and then all the data from the second head
// (Head 1, the bottom side) before moving to the next track.
// In other words, the layout is an array of
// [num_tracks][num_heads][num_sectors_per_track].
static inline uint32_t FDCComputeOffset(
    FDCDiskFormat format, uint8_t head, uint8_t track, uint8_t sector,
    uint16_t sector_offset) {
  if (head >= format.num_heads || track >= format.num_tracks || sector == 0 ||
      sector > format.num_sectors_per_track ||
      sector_offset >= format.sector_size) {
    return kFDCInvalidOffset;
  }

  uint32_t offset = 0;
  // Seek to start of the track
  offset += (uint32_t)track * format.num_heads * format.num_sectors_per_track *
            format.sector_size;
  // Seek to start of the head within the track
  offset += (uint32_t)head * format.num_sectors_per_track * format.sector_size;
  // Seek to start of the sector within the head
  offset += (uint32_t)(sector - 1) * format.sector_size;
  // Add byte offset within the sector
  offset += (uint32_t)sector_offset;

  return offset;
}

// Helper to finish a read/write command.
static void FDCFinishReadWrite(
    FDCState* fdc, uint8_t st0, uint8_t st1, uint8_t st2) {
  FDCResultBufferAppend(&fdc->result_buffer, &st0);
  FDCResultBufferAppend(&fdc->result_buffer, &st1);
  FDCResultBufferAppend(&fdc->result_buffer, &st2);
  FDCResultBufferAppend(&fdc->result_buffer, &fdc->transfer.cylinder);
  FDCResultBufferAppend(&fdc->result_buffer, &fdc->transfer.head);
  FDCResultBufferAppend(&fdc->result_buffer, &fdc->transfer.sector);
  FDCResultBufferAppend(&fdc->result_buffer, &fdc->transfer.sector_size_code);

  FDCRaiseIRQ6(fdc);
  FDCFinishCommandExecution(fdc);
}

// Handler for Write Data command.
static void FDCHandleWriteData(FDCState* fdc) {
  if (fdc->current_command_ticks == 0) {
    // Initialization.
    uint8_t cmd_byte = *FDCCommandBufferGet(&fdc->command_buffer, 0);
    fdc->transfer.multi_track = (cmd_byte & 0x80) != 0;

    uint8_t drive_head = *FDCCommandBufferGet(&fdc->command_buffer, 1);
    uint8_t drive_index = drive_head & 0x03;
    uint8_t head_address = (drive_head >> 2) & 0x01;

    fdc->transfer.cylinder = *FDCCommandBufferGet(&fdc->command_buffer, 2);
    fdc->transfer.head = *FDCCommandBufferGet(&fdc->command_buffer, 3);
    fdc->transfer.sector = *FDCCommandBufferGet(&fdc->command_buffer, 4);
    fdc->transfer.sector_size_code =
        *FDCCommandBufferGet(&fdc->command_buffer, 5);
    fdc->transfer.eot = *FDCCommandBufferGet(&fdc->command_buffer, 6);
    // GPL and DTL are ignored.

    FDCDriveState* drive = &fdc->drives[drive_index];
    if (!drive->present) {
      // Drive not ready.
      FDCFinishReadWrite(
          fdc,
          kFDCST0AbnormalTermination | kFDCST0NotReady | head_address << 2 |
              drive_index,
          0, 0);
      return;
    }

    // Calculate offset for the first byte.
    fdc->transfer.current_offset = FDCComputeOffset(
        *drive->format, fdc->transfer.head, fdc->transfer.cylinder,
        fdc->transfer.sector, 0);

    if (fdc->transfer.current_offset == kFDCInvalidOffset) {
      FDCFinishReadWrite(
          fdc, kFDCST0AbnormalTermination | head_address << 2 | drive_index,
          kFDCST1NoData, 0);
      return;
    }

    fdc->transfer.sector_byte_index = 0;
    // For Write, we need to request the first byte immediately.
    fdc->transfer.dma_request_active = true;
    fdc->transfer.tc_received = false;
    if (fdc->config && fdc->config->request_dma) {
      fdc->config->request_dma(fdc->config->context);
    }
    return;
  }

  // Execution Loop.

  // Check for Terminal Count (TC).
  if (fdc->transfer.tc_received) {
    // Transfer complete.
    uint8_t drive_index = *FDCCommandBufferGet(&fdc->command_buffer, 1) & 0x03;
    uint8_t head_address = (fdc->transfer.head & 0x01);
    FDCFinishReadWrite(
        fdc, kFDCST0NormalTermination | head_address << 2 | drive_index, 0, 0);
    return;
  }

  // If DREQ is active, wait for the system to service it (write byte to us).
  if (fdc->transfer.dma_request_active) {
    return;
  }

  // Data has arrived in data_register. Write it to image.
  uint8_t drive_index = *FDCCommandBufferGet(&fdc->command_buffer, 1) & 0x03;
  if (fdc->config && fdc->config->write_image_byte) {
    fdc->config->write_image_byte(
        fdc->config->context, drive_index, fdc->transfer.current_offset,
        fdc->transfer.data_register);
  }

  // Advance pointers.
  fdc->transfer.current_offset++;
  fdc->transfer.sector_byte_index++;

  // Calculate sector size.
  uint16_t sector_size;
  uint8_t dtl = *FDCCommandBufferGet(&fdc->command_buffer, 8);
  if (fdc->transfer.sector_size_code == 0) {
    sector_size = dtl;
  } else {
    sector_size = 128 << fdc->transfer.sector_size_code;
  }

  // Check for sector boundary.
  if (fdc->transfer.sector_byte_index >= sector_size) {
    // Sector done.
    if (fdc->transfer.sector >= fdc->transfer.eot) {
      // End of Track reached.
      if (fdc->transfer.multi_track && (fdc->transfer.head & 1) == 0) {
        // Multi-Track rollover.
        fdc->transfer.head ^= 1;
        fdc->transfer.sector = 1;
        fdc->transfer.sector_byte_index = 0;

        // Recompute offset.
        FDCDriveState* drive = &fdc->drives[drive_index];
        fdc->transfer.current_offset = FDCComputeOffset(
            *drive->format, fdc->transfer.head, fdc->transfer.cylinder,
            fdc->transfer.sector, 0);

        if (fdc->transfer.current_offset == kFDCInvalidOffset) {
          fdc->transfer.tc_received = true;
          return;  // Stop here, don't request next byte.
        }
      } else {
        // Terminate.
        fdc->transfer.sector++;
        fdc->transfer.tc_received = true;
        return;  // Stop here.
      }
    } else {
      // Next sector.
      fdc->transfer.sector++;
      fdc->transfer.sector_byte_index = 0;
      FDCDriveState* drive = &fdc->drives[drive_index];
      fdc->transfer.current_offset = FDCComputeOffset(
          *drive->format, fdc->transfer.head, fdc->transfer.cylinder,
          fdc->transfer.sector, 0);

      if (fdc->transfer.current_offset == kFDCInvalidOffset) {
        fdc->transfer.tc_received = true;
        return;
      }
    }
  }

  // Request next byte via DMA.
  fdc->transfer.dma_request_active = true;
  if (fdc->config && fdc->config->request_dma) {
    fdc->config->request_dma(fdc->config->context);
  }
}

// Handler for Read Data command.
static void FDCHandleReadData(FDCState* fdc) {
  if (fdc->current_command_ticks == 0) {
    // Initialization.
    uint8_t cmd_byte = *FDCCommandBufferGet(&fdc->command_buffer, 0);
    fdc->transfer.multi_track = (cmd_byte & 0x80) != 0;

    uint8_t drive_head = *FDCCommandBufferGet(&fdc->command_buffer, 1);
    uint8_t drive_index = drive_head & 0x03;
    uint8_t head_address = (drive_head >> 2) & 0x01;

    fdc->transfer.cylinder = *FDCCommandBufferGet(&fdc->command_buffer, 2);
    fdc->transfer.head = *FDCCommandBufferGet(&fdc->command_buffer, 3);
    fdc->transfer.sector = *FDCCommandBufferGet(&fdc->command_buffer, 4);
    fdc->transfer.sector_size_code =
        *FDCCommandBufferGet(&fdc->command_buffer, 5);
    fdc->transfer.eot = *FDCCommandBufferGet(&fdc->command_buffer, 6);
    // GPL and DTL are ignored as we don't simulate gap timings or use DTL for
    // init.

    FDCDriveState* drive = &fdc->drives[drive_index];
    if (!drive->present) {
      // Drive not ready.
      FDCFinishReadWrite(
          fdc,
          kFDCST0AbnormalTermination | kFDCST0NotReady | head_address << 2 |
              drive_index,
          0, 0);
      return;
    }

    // Calculate offset for the first byte.
    fdc->transfer.current_offset = FDCComputeOffset(
        *drive->format, fdc->transfer.head, fdc->transfer.cylinder,
        fdc->transfer.sector, 0);

    if (fdc->transfer.current_offset == kFDCInvalidOffset) {
      // Invalid sector/track.
      // If the sector is physically out of bounds for the format, report No
      // Data (Sector Not Found).
      FDCFinishReadWrite(
          fdc, kFDCST0AbnormalTermination | head_address << 2 | drive_index,
          kFDCST1NoData, 0);
      return;
    }

    fdc->transfer.sector_byte_index = 0;
    fdc->transfer.dma_request_active = false;
    fdc->transfer.tc_received = false;
    return;
  }

  // Execution Loop.

  // Check for Terminal Count (TC).
  if (fdc->transfer.tc_received) {
    // Transfer complete.
    uint8_t drive_index = *FDCCommandBufferGet(&fdc->command_buffer, 1) & 0x03;
    uint8_t head_address = (fdc->transfer.head & 0x01);
    FDCFinishReadWrite(
        fdc, kFDCST0NormalTermination | head_address << 2 | drive_index, 0, 0);
    return;
  }

  // If DREQ is active, wait for the system to service it.
  if (fdc->transfer.dma_request_active) {
    return;
  }

  // Read next byte.
  uint8_t drive_index = *FDCCommandBufferGet(&fdc->command_buffer, 1) & 0x03;
  if (fdc->config && fdc->config->read_image_byte) {
    fdc->transfer.data_register = fdc->config->read_image_byte(
        fdc->config->context, drive_index, fdc->transfer.current_offset);
  } else {
    fdc->transfer.data_register = 0;
  }

  // Advance pointers.
  fdc->transfer.current_offset++;
  fdc->transfer.sector_byte_index++;

  // Request DMA transfer.
  fdc->transfer.dma_request_active = true;
  if (fdc->config && fdc->config->request_dma) {
    fdc->config->request_dma(fdc->config->context);
  }

  // Calculate sector size again for boundary check.
  uint16_t sector_size;
  uint8_t dtl = *FDCCommandBufferGet(&fdc->command_buffer, 8);
  if (fdc->transfer.sector_size_code == 0) {
    sector_size = dtl;
  } else {
    sector_size = 128 << fdc->transfer.sector_size_code;
  }

  // Check for sector boundary.
  if (fdc->transfer.sector_byte_index >= sector_size) {
    // Sector done.
    if (fdc->transfer.sector >= fdc->transfer.eot) {
      // End of Track reached.
      if (fdc->transfer.multi_track && (fdc->transfer.head & 1) == 0) {
        // Multi-Track rollover: Side 0 -> Side 1.
        fdc->transfer.head ^= 1;   // Flip to Head 1
        fdc->transfer.sector = 1;  // Reset to Sector 1
        fdc->transfer.sector_byte_index = 0;

        // Recompute offset for new head/sector.
        FDCDriveState* drive = &fdc->drives[drive_index];
        fdc->transfer.current_offset = FDCComputeOffset(
            *drive->format, fdc->transfer.head, fdc->transfer.cylinder,
            fdc->transfer.sector, 0);

        if (fdc->transfer.current_offset == kFDCInvalidOffset) {
          fdc->transfer.tc_received = true;
        }
      } else {
        // Standard termination (MT=0 or already on Head 1).
        // Increment sector so result phase reports the *next* logical sector.
        fdc->transfer.sector++;
        fdc->transfer.tc_received = true;
      }
    } else {
      // Move to next sector.
      fdc->transfer.sector++;
      fdc->transfer.sector_byte_index = 0;
      // Recompute offset for new sector.
      FDCDriveState* drive = &fdc->drives[drive_index];
      fdc->transfer.current_offset = FDCComputeOffset(
          *drive->format, fdc->transfer.head, fdc->transfer.cylinder,
          fdc->transfer.sector, 0);

      if (fdc->transfer.current_offset == kFDCInvalidOffset) {
        // Should not happen if EOT is correct, but if we ran off the end
        // of the image despite EOT, terminate.
        fdc->transfer.tc_received = true;
      }
    }
  }
}

// Handler for Recalibrate command.
static void FDCHandleRecalibrate(FDCState* fdc) {
  // Recalibrate command has one parameter byte: drive number (0-3).
  uint8_t drive_index = *FDCCommandBufferGet(&fdc->command_buffer, 1) & 0x03;
  FDCPerformSeek(fdc, drive_index, 0);
}

// Handler for Seek command.
static void FDCHandleSeek(FDCState* fdc) {
  // Seek command parameters:
  // Byte 1: Drive number (0-3) and Head address (ignored for seek).
  // Byte 2: New Cylinder Number (NCN).
  uint8_t drive_index = *FDCCommandBufferGet(&fdc->command_buffer, 1) & 0x03;
  uint8_t target_track = *FDCCommandBufferGet(&fdc->command_buffer, 2);
  FDCPerformSeek(fdc, drive_index, target_track);
}

// Handler for Specify command.
static void FDCHandleSpecify(FDCState* fdc) {
  // We don't currently support changing timings or non-DMA mode, so we just
  // ignore the parameters.
  FDCFinishCommandExecution(fdc);
}

// Handler for Sense Interrupt Status command.
static void FDCHandleSenseInterruptStatus(FDCState* fdc) {
  // Check for any pending interrupts.
  for (int i = 0; i < kFDCNumDrives; ++i) {
    FDCDriveState* drive = &fdc->drives[i];
    if (drive->has_pending_interrupt) {
      // Clear the pending interrupt flag.
      drive->has_pending_interrupt = false;

      // Result Byte 0: ST0 (Status Register 0)
      FDCResultBufferAppend(&fdc->result_buffer, &drive->st0);
      // Result Byte 1: PCN (Present Cylinder Number)
      FDCResultBufferAppend(&fdc->result_buffer, &drive->track);

      FDCFinishCommandExecution(fdc);
      return;
    }
  }

  // No pending interrupts found. This is treated as an invalid command.
  uint8_t st0 = kFDCST0InvalidCommand;
  FDCResultBufferAppend(&fdc->result_buffer, &st0);
  FDCFinishCommandExecution(fdc);
}

// List of supported FDC commands.
// The opcodes here represent the base 5-bit command.
static const FDCCommandMetadata kFDCCommandMetadataTable[] = {
    // Read a Track
    {.opcode = kFDCCmdReadTrack, .num_param_bytes = 8, .handler = NULL},
    // Specify
    {.opcode = kFDCCmdSpecify,
     .num_param_bytes = 2,
     .handler = FDCHandleSpecify},
    // Sense Drive Status
    {.opcode = kFDCCmdSenseDriveStatus, .num_param_bytes = 1, .handler = NULL},
    // Write Data
    {.opcode = kFDCCmdWriteData,
     .num_param_bytes = 8,
     .handler = FDCHandleWriteData},
    // Read Data
    {.opcode = kFDCCmdReadData,
     .num_param_bytes = 8,
     .handler = FDCHandleReadData},
    // Recalibrate
    {.opcode = kFDCCmdRecalibrate,
     .num_param_bytes = 1,
     .handler = FDCHandleRecalibrate},
    // Sense Interrupt Status
    {.opcode = kFDCCmdSenseInterruptStatus,
     .num_param_bytes = 0,
     .handler = FDCHandleSenseInterruptStatus},
    // Write Deleted Data
    {.opcode = kFDCCmdWriteDeletedData, .num_param_bytes = 8, .handler = NULL},
    // Read ID
    {.opcode = kFDCCmdReadID, .num_param_bytes = 1, .handler = NULL},
    // Read Deleted Data
    {.opcode = kFDCCmdReadDeletedData, .num_param_bytes = 8, .handler = NULL},
    // Format a Track
    {.opcode = kFDCCmdFormatTrack, .num_param_bytes = 5, .handler = NULL},
    // Seek
    {.opcode = kFDCCmdSeek, .num_param_bytes = 2, .handler = FDCHandleSeek},
    // Scan Equal
    {.opcode = kFDCCmdScanEqual, .num_param_bytes = 8, .handler = NULL},
    // Scan Low or Equal
    {.opcode = kFDCCmdScanLowOrEqual, .num_param_bytes = 8, .handler = NULL},
    // Scan High or Equal
    {.opcode = kFDCCmdScanHighOrEqual, .num_param_bytes = 8, .handler = NULL},
};

void FDCInit(FDCState* fdc, FDCConfig* config) {
  static const FDCState zero_fdc_state = {0};
  *fdc = zero_fdc_state;

  fdc->config = config;
}

// Looks up command metadata by opcode. Returns NULL if not found. This is a
// linear search, but the command table is small enough that this is fine.
static const FDCCommandMetadata* FDCFindCommandMetadata(uint8_t opcode) {
  for (size_t i = 0;
       i < sizeof(kFDCCommandMetadataTable) / sizeof(FDCCommandMetadata); ++i) {
    if (kFDCCommandMetadataTable[i].opcode == opcode) {
      return &kFDCCommandMetadataTable[i];
    }
  }
  return NULL;
}

static uint8_t FDCReadMSRPort(FDCState* fdc) {
  uint8_t msr = 0;
  switch (fdc->phase) {
    case kFDCPhaseIdle:
    case kFDCPhaseCommand:
      // FDC is ready to receive a command or parameter byte.
      msr = kFDCMSRRequestForMaster;
      break;
    case kFDCPhaseResult:
      // FDC has result bytes to send and is still busy with the command.
      msr = kFDCMSRRequestForMaster | kFDCMSRDataDirection | kFDCMSRBusy;
      break;
    case kFDCPhaseExecution:
      // FDC is busy executing a command.
      msr |= kFDCMSRBusy;
      break;
  }
  // Set drive busy flags.
  for (int i = 0; i < kFDCNumDrives; ++i) {
    if (fdc->drives[i].busy) {
      msr |= (1 << i);
    }
  }
  return msr;
}

static uint8_t FDCReadDataPort(FDCState* fdc) {
  switch (fdc->phase) {
    case kFDCPhaseExecution:
      // DMA or Polling read during execution.
      fdc->transfer.dma_request_active = false;
      return fdc->transfer.data_register;

    case kFDCPhaseResult: {
      if (fdc->next_result_byte_index >=
          FDCResultBufferLength(&fdc->result_buffer)) {
        return 0xFF;  // All result bytes have been read.
      }
      uint8_t value =
          *FDCResultBufferGet(&fdc->result_buffer, fdc->next_result_byte_index);
      fdc->next_result_byte_index++;
      if (fdc->next_result_byte_index >=
          FDCResultBufferLength(&fdc->result_buffer)) {
        // Last result byte was read, reset to idle.
        fdc->phase = kFDCPhaseIdle;
        fdc->next_result_byte_index = 0;
        FDCResultBufferClear(&fdc->result_buffer);
      }
      return value;
    }

    default:
      return 0xFF;  // Invalid read.
  }
}

uint8_t FDCReadPort(FDCState* fdc, uint16_t port) {
  switch (port) {
    case kFDCPortMSR:  // Main Status Register (MSR)
      return FDCReadMSRPort(fdc);
    case kFDCPortData:  // Data Register
      return FDCReadDataPort(fdc);
    default:
      // Per convention for reads from unused/invalid ports.
      return 0xFF;
  }
}

static void FDCWriteDORPort(FDCState* fdc, uint8_t value) {
  uint8_t old_dor = fdc->dor;
  fdc->dor = value;

  bool old_reset_bit = (old_dor & kFDCDORReset) != 0;
  bool new_reset_bit = (value & kFDCDORReset) != 0;

  if (!new_reset_bit && old_reset_bit) {
    // Entering reset state (1 -> 0).
    fdc->phase = kFDCPhaseIdle;
    FDCCommandBufferClear(&fdc->command_buffer);
    FDCResultBufferClear(&fdc->result_buffer);
    for (int i = 0; i < kFDCNumDrives; ++i) {
      fdc->drives[i].busy = false;
      fdc->drives[i].has_pending_interrupt = false;
    }
  } else if (new_reset_bit && !old_reset_bit) {
    // Exiting reset state (0 -> 1).
    // The FDC generates an interrupt and sets up status for Sense
    // Interrupt Status for all drives.
    for (int i = 0; i < kFDCNumDrives; ++i) {
      fdc->drives[i].has_pending_interrupt = true;
      fdc->drives[i].st0 = kFDCST0AbnormalTerminationPolling | (uint8_t)i;
    }
    FDCRaiseIRQ6(fdc);
  }
}

static void FDCWriteDataPort(FDCState* fdc, uint8_t value) {
  switch (fdc->phase) {
    case kFDCPhaseIdle: {
      // This is the first byte of a new command.
      // Extract the opcode (lower 5 bits).
      uint8_t opcode = value & 0x1F;
      fdc->current_command = FDCFindCommandMetadata(opcode);

      if (!fdc->current_command) {
        // Invalid command. Set up the result phase with an error.
        FDCResultBufferClear(&fdc->result_buffer);
        uint8_t status = kFDCST0InvalidCommand;
        FDCResultBufferAppend(&fdc->result_buffer, &status);
        FDCFinishCommandExecution(fdc);
        return;
      }

      // Clear previous command and store the first byte.
      FDCCommandBufferClear(&fdc->command_buffer);
      FDCCommandBufferAppend(&fdc->command_buffer, &value);

      if (fdc->current_command->num_param_bytes == 0) {
        // Command has no parameters, move directly to execution.
        FDCStartCommandExecution(fdc);
      } else {
        // Wait for parameter bytes.
        fdc->phase = kFDCPhaseCommand;
      }
      break;
    }

    case kFDCPhaseCommand: {
      // This is a parameter byte for the current command.
      if (!fdc->current_command) {
        // Should not happen, but as a safeguard, reset to idle.
        fdc->phase = kFDCPhaseIdle;
        return;
      }

      // Store the parameter byte.
      FDCCommandBufferAppend(&fdc->command_buffer, &value);

      // Check if all parameters have been received.
      // Total bytes = 1 (command) + num_param_bytes.
      if (FDCCommandBufferLength(&fdc->command_buffer) >=
          (uint8_t)(fdc->current_command->num_param_bytes + 1)) {
        // All bytes received, move to execution phase.
        FDCStartCommandExecution(fdc);
      }
      break;
    }

    case kFDCPhaseExecution:
      // DMA or Polling write during execution.
      fdc->transfer.data_register = value;
      fdc->transfer.dma_request_active = false;
      break;

    case kFDCPhaseResult:
      // The FDC is busy. Ignore any writes to the data port.
      break;
  }
}

void FDCWritePort(FDCState* fdc, uint16_t port, uint8_t value) {
  switch (port) {
    case kFDCPortDOR:  // Digital Output Register
      FDCWriteDORPort(fdc, value);
      break;

    case kFDCPortData:  // Data Register
      // Logic will be based on the current FDC phase.
      FDCWriteDataPort(fdc, value);
      break;

    default:
      // Ignore writes to other ports.
      break;
  }
}

void FDCHandleTC(FDCState* fdc) { fdc->transfer.tc_received = true; }

void FDCInsertDisk(FDCState* fdc, uint8_t drive, const FDCDiskFormat* format) {
  if (drive >= kFDCNumDrives) {
    return;
  }
  FDCDriveState* drive_state = &fdc->drives[drive];
  drive_state->present = true;
  drive_state->format = format;
  drive_state->head = 0;
  drive_state->track = 0;
}

void FDCEjectDisk(FDCState* fdc, uint8_t drive) {
  if (drive >= kFDCNumDrives) {
    return;
  }
  FDCDriveState* drive_state = &fdc->drives[drive];
  drive_state->present = false;
  drive_state->format = NULL;
}

void FDCTick(FDCState* fdc) {
  if (fdc->phase != kFDCPhaseExecution) {
    return;
  }

  // Run the command handler if defined.
  if (fdc->current_command && fdc->current_command->handler) {
    fdc->current_command->handler(fdc);
    ++fdc->current_command_ticks;
  } else {
    // No handler defined, finish execution immediately.
    FDCResultBufferClear(&fdc->result_buffer);
    FDCFinishCommandExecution(fdc);
  }
}


// ==============================================================================
// src/fdc/fdc.c end
// ==============================================================================


#endif  // YAX86_IMPLEMENTATION

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  // YAX86_FDC_BUNDLE_H

// ==============================================================================
// YAX86 KEYBOARD MODULE - GENERATED SINGLE HEADER BUNDLE
// ==============================================================================

#ifndef YAX86_KEYBOARD_BUNDLE_H
#define YAX86_KEYBOARD_BUNDLE_H

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// ==============================================================================
// src/util/static_vector.h start
// ==============================================================================

#line 1 "./src/util/static_vector.h"
// Static vector library.
//
// A static vector is a vector backed by a fixed-size array. It's essentially
// a vector, but whose underlying storage is statically allocated and does not
// rely on dynamic memory allocation.

#ifndef YAX86_UTIL_STATIC_VECTOR_H
#define YAX86_UTIL_STATIC_VECTOR_H

#include <stddef.h>
#include <stdint.h>

// Header structure at the beginning of a static vector.
typedef struct StaticVectorHeader {
  // Element size in bytes.
  size_t element_size;
  // Maximum number of elements the vector can hold.
  size_t max_length;
  // Number of elements currently in the vector.
  size_t length;
} StaticVectorHeader;

// Define a static vector type with an element type.
#define STATIC_VECTOR_TYPE(name, element_type, max_length_value)          \
  typedef struct name {                                                   \
    StaticVectorHeader header;                                            \
    element_type elements[max_length_value];                              \
  } name;                                                                 \
  static void name##Init(name* vector) __attribute__((unused));           \
  static void name##Init(name* vector) {                                  \
    static const StaticVectorHeader header = {                            \
        .element_size = sizeof(element_type),                             \
        .max_length = (max_length_value),                                 \
        .length = 0,                                                      \
    };                                                                    \
    vector->header = header;                                              \
  }                                                                       \
  static size_t name##Length(const name* vector) __attribute__((unused)); \
  static size_t name##Length(const name* vector) {                        \
    return vector->header.length;                                         \
  }                                                                       \
  static element_type* name##Get(name* vector, size_t index)              \
      __attribute__((unused));                                            \
  static element_type* name##Get(name* vector, size_t index) {            \
    if (index >= (max_length_value)) {                                    \
      return NULL;                                                        \
    }                                                                     \
    return &(vector->elements[index]);                                    \
  }                                                                       \
  static bool name##Append(name* vector, const element_type* element)     \
      __attribute__((unused));                                            \
  static bool name##Append(name* vector, const element_type* element) {   \
    if (vector->header.length >= (max_length_value)) {                    \
      return false;                                                       \
    }                                                                     \
    vector->elements[vector->header.length++] = *element;                 \
    return true;                                                          \
  }                                                                       \
  static bool name##Insert(                                               \
      name* vector, size_t index, const element_type* element)            \
      __attribute__((unused));                                            \
  static bool name##Insert(                                               \
      name* vector, size_t index, const element_type* element) {          \
    if (index > vector->header.length ||                                  \
        vector->header.length >= (max_length_value)) {                    \
      return false;                                                       \
    }                                                                     \
    for (size_t i = vector->header.length; i > index; --i) {              \
      vector->elements[i] = vector->elements[i - 1];                      \
    }                                                                     \
    vector->elements[index] = *element;                                   \
    ++vector->header.length;                                              \
    return true;                                                          \
  }                                                                       \
  static bool name##Remove(name* vector, size_t index)                    \
      __attribute__((unused));                                            \
  static bool name##Remove(name* vector, size_t index) {                  \
    if (index >= vector->header.length) {                                 \
      return false;                                                       \
    }                                                                     \
    for (size_t i = index; i < vector->header.length - 1; ++i) {          \
      vector->elements[i] = vector->elements[i + 1];                      \
    }                                                                     \
    --vector->header.length;                                              \
    return true;                                                          \
  }                                                                       \
  static void name##Clear(name* vector) __attribute__((unused));          \
  static void name##Clear(name* vector) { vector->header.length = 0; }

#endif  // YAX86_UTIL_STATIC_VECTOR_H


// ==============================================================================
// src/util/static_vector.h end
// ==============================================================================

// ==============================================================================
// src/keyboard/public.h start
// ==============================================================================

#line 1 "./src/keyboard/public.h"
// Public interface for the Keyboard module.
#ifndef YAX86_KEYBOARD_PUBLIC_H
#define YAX86_KEYBOARD_PUBLIC_H

// This module emulates a PC/XT keyboard and its interface to the 8255 PPI.
//
// During initialization:
// 1. [0, 0]
//    The BIOS sets both control bits to false and holds them there for at
//    least 20ms. The keyboard detects the clock_low line is held low, and
//    performs a self test.
// 2. -> [1, 1] -> [0, 1]
//    The BIOS restores the clock_low line to true, releasing the reset signal.
//    It pulses the enable_clear line high then low to trigger the next scan
//    code, just like in normal operation.
// 3. The pulse triggers the keyboard to send the self-test OK scancode (0xAA)
//    to the PPI.
// 4. -> [1, 1] -> [0, 1]
//    The BIOS acknowledges the self-test OK scancode by pulsing the
//    enable_clear line again, just like in normal operation.
// 5. -> [1, 1]
//    The BIOS sets both control bits to true to inhibit the keyboard for the
//    rest of the POST process.
// 6. -> [0, 1]
//    At the end of POST, the BIOS enables the keyboard by setting it to normal
//    operational state.
//
// In normal operation:
// 1. [0, 1]
//    In steady state, the control bits are set to enable_clear = false,
//    clock_low = true.
// 2. [0, 1]
//    On key press, the keyboard sends the scancode to the PPI and raises IRQ1.
//    At this point, the control bits are unchanged.
// 3. -> [1, 1] -> [0, 1]
//    The BIOS's IRQ handler sends an ack by briefly pulsing the enable_clear
//    line from false to true to false. This pulse tells the keyboard that it
//    can now send the next scancode.

#include <stdbool.h>
#include <stdint.h>

#ifndef YAX86_KEYBOARD_BUNDLE_H
#include "../util/static_vector.h"
#endif  // YAX86_KEYBOARD_BUNDLE_H

struct KeyboardState;

// Caller-provided runtime configuration for the Keyboard.
typedef struct KeyboardConfig {
  // Opaque context pointer, passed to all callbacks.
  void* context;

  // Callback to send a scancode to the PPI.
  void (*send_scancode)(void* context, uint8_t scancode);
  // Callback to raise an IRQ1 (keyboard interrupt) to the CPU.
  void (*raise_irq1)(void* context);
} KeyboardConfig;

enum {
  // Maximum number of keys to buffer. Additional key presses will be dropped.
  kKeyboardBufferSize = 16,
  // Threshold required to trigger keyboard reset when clock line is held low.
  kKeyboardResetThresholdMs = 20,
};
STATIC_VECTOR_TYPE(KeyboardBuffer, uint8_t, kKeyboardBufferSize)

// State of the Keyboard.
typedef struct KeyboardState {
  // Pointer to the keyboard configuration.
  KeyboardConfig* config;

  // State of PPI Port B bit 7, or PBKB in GLaBIOS.
  // - false = enable keyboard
  // - true  = clear keyboard (reset)
  bool enable_clear;

  // Current state of PPI Port B bit 6, or PBKC in GLaBIOS.
  // - false = hold keyboard clock low
  // - true  = enabled (normal operation)
  bool clock_low;

  // Number of ms since the clock_low line was set to false (enabled). This is
  // used to detect the reset signal from the BIOS, which is holding the clock
  // low for at least 20ms.
  //   - 0 = clock line is high (normal operation)
  //   - 0xFF = clock line has been low for at least 20ms
  uint8_t clock_low_ms;

  // Whether we are currently waiting for ack from BIOS before sending the next
  // scancode. The keyboard will not send any further scancodes until the BIOS
  // pulses the enable_clear line high then low.
  bool waiting_for_ack;

  // Buffer of key presses received.
  KeyboardBuffer buffer;
} KeyboardState;

// Initializes the keyboard to its power-on state.
void KeyboardInit(KeyboardState* keyboard, KeyboardConfig* config);

// Receive keyboard control bits from the PPI (bits 6 and 7 of Port B).
void KeyboardHandleControl(
    KeyboardState* keyboard, bool enable_clear, bool clock_low);

// Handles a real key press event.
void KeyboardHandleKeyPress(KeyboardState* keyboard, uint8_t scancode);

// Simulates a 1ms tick. This is needed to respond to reset commands and to
// send buffered scancodes.
void KeyboardTickMs(KeyboardState* keyboard);

#endif  // YAX86_KEYBOARD_PUBLIC_H



// ==============================================================================
// src/keyboard/public.h end
// ==============================================================================


#ifdef YAX86_IMPLEMENTATION

// ==============================================================================
// src/keyboard/keyboard.c start
// ==============================================================================

#line 1 "./src/keyboard/keyboard.c"
#ifndef YAX86_IMPLEMENTATION
#include "public.h"
#endif  // YAX86_IMPLEMENTATION

enum {
  // Value for clock_low_ms indicating that a reset has already been triggered.
  kKeyboardResetTriggered = 0xFF,
  // Scan code indicating successful self-test.
  kKeyboardSelfTestOK = 0xAA,
};

void KeyboardInit(KeyboardState* keyboard, KeyboardConfig* config) {
  static const KeyboardState zero_keyboard_state = {0};
  *keyboard = zero_keyboard_state;
  keyboard->config = config;

  // Default to keyboard enabled (enable_clear = false) with clock held low
  // (clock_low = true). This allows us to detect a falling edge on clock_low
  // which triggers the reset timer.
  keyboard->enable_clear = false;
  keyboard->clock_low = true;
  keyboard->clock_low_ms = 0;
  KeyboardBufferInit(&keyboard->buffer);
  keyboard->waiting_for_ack = false;
}

// Helper to send a scancode to the PPI and raise IRQ1 if needed.
static inline void KeyboardSendScancode(
    KeyboardState* keyboard, uint8_t scancode) {
  if (keyboard->config && keyboard->config->send_scancode) {
    keyboard->config->send_scancode(keyboard->config->context, scancode);
  }
  if (keyboard->config && keyboard->config->raise_irq1) {
    keyboard->config->raise_irq1(keyboard->config->context);
  }
  keyboard->waiting_for_ack = true;
}

// Helper to send the next scancode in the buffer if available.
static inline void KeyboardSendNextScancode(KeyboardState* keyboard) {
  // Can only send in state [0, 1], i.e. enable_clear = false clock_low = true
  if (!(keyboard->enable_clear == false && keyboard->clock_low == true)) {
    return;
  }
  // Can only send after previous scancode has been acked.
  if (keyboard->waiting_for_ack) {
    return;
  }
  // If buffer is empty, nothing to send.
  if (KeyboardBufferLength(&keyboard->buffer) == 0) {
    return;
  }

  // Send the next scancode in the buffer.
  uint8_t scancode = *KeyboardBufferGet(&keyboard->buffer, 0);
  KeyboardBufferRemove(&keyboard->buffer, 0);
  KeyboardSendScancode(keyboard, scancode);
}

void KeyboardHandleControl(
    KeyboardState* keyboard, bool enable_clear, bool clock_low) {
  // Save previous state.
  bool old_clock_low = keyboard->clock_low;
  bool old_enable_clear = keyboard->enable_clear;

  // Update state.
  keyboard->enable_clear = enable_clear;
  keyboard->clock_low = clock_low;

  // Falling edge of enable_clear bit indicates ack from BIOS. we clear the
  // waiting_for_ack bit, allowing the next queued scancode to be sent on the
  // next tick.
  if (old_enable_clear == true && keyboard->enable_clear == false &&
      keyboard->clock_low == true) {
    keyboard->waiting_for_ack = false;
  }

  // Falling edge of clock_low bit possibly indicates the start of a reset
  // command from BIOS. We reset the timer at 0ms.
  if (old_clock_low == true && keyboard->clock_low == false) {
    keyboard->clock_low_ms = 0;
  }
}

void KeyboardHandleKeyPress(KeyboardState* keyboard, uint8_t scancode) {
  KeyboardBufferAppend(&keyboard->buffer, &scancode);
}

void KeyboardTickMs(KeyboardState* keyboard) {
  // If clock_low line is being held low, update timer and trigger reset if
  // reached threshold.
  if (keyboard->clock_low == false) {
    if (keyboard->clock_low_ms == kKeyboardResetTriggered) {
      // Reset already triggered, nothing to do.
      return;
    }

    // Increment timer since clock line was held low.
    ++keyboard->clock_low_ms;

    // Haven't reached threshold yet, nothing to do.
    if (keyboard->clock_low_ms < kKeyboardResetThresholdMs) {
      return;
    }

    // Reached threshold, trigger reset.
    KeyboardBufferClear(&keyboard->buffer);
    keyboard->waiting_for_ack = false;
    // Set to special value indicating reset has been triggered.
    keyboard->clock_low_ms = kKeyboardResetTriggered;
    // Send self-test passed scancode on next falling edge of enable_clear.
    uint8_t scancode = kKeyboardSelfTestOK;
    KeyboardBufferAppend(&keyboard->buffer, &scancode);
    return;
  }

  // Normal operation.
  KeyboardSendNextScancode(keyboard);
}



// ==============================================================================
// src/keyboard/keyboard.c end
// ==============================================================================


#endif  // YAX86_IMPLEMENTATION

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  // YAX86_KEYBOARD_BUNDLE_H

// ==============================================================================
// YAX86 PIC MODULE - GENERATED SINGLE HEADER BUNDLE
// ==============================================================================

#ifndef YAX86_PIC_BUNDLE_H
#define YAX86_PIC_BUNDLE_H

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// ==============================================================================
// src/pic/public.h start
// ==============================================================================

#line 1 "./src/pic/public.h"
// Public interface for the PIC (Programmable Interrupt Controller) module.
#ifndef YAX86_PIC_PUBLIC_H
#define YAX86_PIC_PUBLIC_H

// This module emulates the Intel 8259 PIC(s) on the IBM PC series. There are
// two possible configurations:
//
// 1. Single PIC - IBM PC and PC/XT
//    The system has a single PIC at I/O ports 0x20/0x21, handling IRQs 0-7,
//    connected to the CPU.
//
// 2. Cascaded PICs - IBM PC/AT and PS/2
//    The system has a master PIC at I/O ports 0x20/0x21 handling IRQs 0-7,
//    and a slave PIC at I/O ports 0xA0/0xA1 handling IRQs 8-15. The slave PIC
//    is connected to the master's IRQ2 line. Only the master PIC is directly
//    connected to the CPU.
//
// Note that we do not support all features of the 8259 PIC, such as auto EOI,
// rotating priorities, etc., as they are not used by MS-DOS or the IBM PC
// BIOS.

#include <stdbool.h>
#include <stdint.h>

// ============================================================================
// PIC state
// ============================================================================

// The mode of a PIC - single, master, or slave.
typedef enum PICMode {
  // Single PIC on IBM PC and PC/XT
  kPICSingle = 0,
  // Master PIC on IBM PC/AT and PS/2
  kPICMaster,
  // Slave PIC on IBM PC/AT and PS/2
  kPICSlave,
  // Number of PIC modes
  kPICNumModes,
} PICMode;

// Initialization state of a PIC.
typedef enum PICInitState {
  // Uninitialized - waiting for ICW1.
  kPICExpectICW1 = 0,
  // ICW1 received - waiting for ICW2.
  kPICExpectICW2,
  // ICW2 received - waiting for ICW3 (if needed).
  kPICExpectICW3,
  // ICW3 received - waiting for ICW4 (if needed) or fully initialized.
  kPICExpectICW4,
  // Fully initialized.
  kPICReady,
} PICInitState;

enum {
  // Indicates no pending interrupt. In normal operation, valid ranges of
  // interrupt vectors are 0x08-0x0F for a single PIC or master PIC, and
  // 0x70-0x77 for a slave PIC.
  kPICNoPendingInterrupt = 0xFF,
};

struct PICState;

// Caller-provided runtime configuration.
typedef struct PICConfig {
  // State of the SP pin.
  // - Single PIC on IBM PC and PC/XT => false
  // - Master PIC on IBM PC/AT and PS/2 => false
  // - Slave PIC on IBM PC/AT and PS/2 => true
  bool sp;
} PICConfig;

// The register to read on the next read from the data port.
typedef enum PICReadRegister {
  kPICReadIMR = 0,  // Default: read Interrupt Mask Register
  kPICReadIRR = 1,  // Read Interrupt Request Register on next read
  kPICReadISR = 2,  // Read In-Service Register on next read
} PICReadRegister;

// State of a single 8259 PIC chip.
typedef struct PICState {
  // Pointer to caller-provided runtime configuration.
  PICConfig* config;

  // Initialization state.
  PICInitState init_state;
  // Received initialization words.
  uint8_t icw1;
  uint8_t icw2;
  uint8_t icw3;
  // We don't store ICW4 as its extra features are not used by MS-DOS or the
  // IBM PC BIOS.

  // Interrupt Request Register - pending interrupts. Bit i is set if IRQ i is
  // pending.
  uint8_t irr;
  // In-Service Register - interrupts currently being serviced. Bit i is set if
  // IRQ i is being serviced.
  uint8_t isr;
  // Interrupt Mask Register - masked interrupts. Bit i is set if IRQ i is
  // masked.
  uint8_t imr;

  // The register to read on the next read from the data port.
  PICReadRegister read_register;

  // Pointer to master PIC if this is a slave, or to slave PIC if this is a
  // master. NULL if this is a single PIC.
  struct PICState* cascade_pic;
} PICState;

// ============================================================================
// PIC initialization
// ============================================================================

// Initialize a PIC with the provided configuration.
void PICInit(PICState* pic, PICConfig* config);

// ============================================================================
// IRQ line control
// ============================================================================

// Raise an IRQ line (0-7) on this PIC. If this is a slave PIC, also raises
// the cascade IRQ on the master PIC.
void PICRaiseIRQ(PICState* pic, uint8_t irq);

// Lower an IRQ line (0-7) on this PIC. If this is a slave PIC and no interrupts
// are pending, also lowers the cascade IRQ on the master PIC.
void PICLowerIRQ(PICState* pic, uint8_t irq);

// ============================================================================
// I/O port interface
// ============================================================================

// Read from a PIC I/O port.
// For master PIC: port should be 0x20 (command) or 0x21 (data).
// For slave PIC: port should be 0xA0 (command) or 0xA1 (data).
uint8_t PICReadPort(PICState* pic, uint16_t port);

// Write to a PIC I/O port.
// For master PIC: port should be 0x20 (command) or 0x21 (data).
// For slave PIC: port should be 0xA0 (command) or 0xA1 (data).
void PICWritePort(PICState* pic, uint16_t port, uint8_t value);

// ============================================================================
// Interrupt handling
// ============================================================================

// Get the highest priority pending interrupt vector number from this PIC. If
// this is a master PIC, this will consider pending interrupts from the slave
// PIC as well. If no interrupts are pending, returns kPICNoPendingInterrupt.
uint8_t PICGetPendingInterrupt(PICState* pic);

#endif  // YAX86_PIC_PUBLIC_H


// ==============================================================================
// src/pic/public.h end
// ==============================================================================


#ifdef YAX86_IMPLEMENTATION

// ==============================================================================
// src/pic/pic.c start
// ==============================================================================

#line 1 "./src/pic/pic.c"
#ifndef YAX86_IMPLEMENTATION
#include "public.h"
#endif  // YAX86_IMPLEMENTATION

// ============================================================================
// Constants
// ============================================================================

enum {
  // ICW bits
  kICW1_IC4 = (1 << 0),   // 1 = ICW4 needed
  kICW1_SNGL = (1 << 1),  // 1 = single PIC, 0 = cascaded
  kICW1_INIT = (1 << 4),  // 1 = initialization mode
  kICW2_BASE = 0xF8,      // Upper 5 bits of ICW2 = the interrupt vector base

  // OCW bits
  kOCW_SELECT = (1 << 3),  // 1 = OCW3, 0 = OCW2
  kOCW2_EOI = (1 << 5),    // End of Interrupt
  kOCW2_SL = (1 << 6),     // Specific Level
  kOCW3_RR = (1 << 1),     // 1 = Read Register command
  kOCW3_RIS = (1 << 0),    // 1 = Read ISR, 0 = Read IRR

  // Master PIC cascade IRQ line
  kMasterCascadeIRQ = 2,
};

// The I/O port of a PIC.
typedef enum PICPort {
  kPICPortCommand = 0,
  kPICPortData = 1,

  // Number of PIC ports.
  kNumPICPorts,
  // Invalid port.
  kPICPortInvalid = -1,
} PICPort;

// Map a PIC mode to its base I/O port.
static const uint16_t kPICBasePorts[kPICNumModes] = {
    0x20,  // kPICSingle
    0x20,  // kPICMaster
    0xA0,  // kPICSlave
};

// ============================================================================
// Helper functions
// ============================================================================

// Returns the mode of a PIC based on its ICWs.
static inline PICMode PICGetMode(PICState* pic) {
  // If SNGL bit set in ICW1, we are single PIC.
  if (pic->icw1 & kICW1_SNGL) {
    return kPICSingle;
  }

  // Otherwise, we are cascaded.
  // If SP pin is set, we are slave; otherwise, master.
  return pic->config->sp ? kPICSlave : kPICMaster;
}

// Returns if the PIC is configured as a single PIC.
static inline bool PICIsSingle(PICState* pic) {
  return PICGetMode(pic) == kPICSingle;
}

// Returns if the PIC is a master PIC.
static inline bool PICIsMaster(PICState* pic) {
  return PICGetMode(pic) == kPICMaster;
}

// Returns if the PIC is a slave PIC.
static inline bool PICIsSlave(PICState* pic) {
  return PICGetMode(pic) == kPICSlave;
}

// Returns the I/O port corresponding to a given port number.
static inline PICPort PICGetPort(PICState* pic, uint16_t port) {
  uint16_t port_offset = port - kPICBasePorts[PICGetMode(pic)];
  if (port_offset >= kNumPICPorts) {
    return kPICPortInvalid;
  }
  return (PICPort)port_offset;
}

// Returns the IRQ number of the parent PIC connected to a slave PIC.
// Only valid if pic is a slave PIC.
static inline uint8_t PICGetCascadeIRQ(PICState* pic) {
  return pic->icw3 & 0x07;
}

// ============================================================================
// PIC initialization
// ============================================================================

void PICInit(PICState* pic, PICConfig* config) {
  // Zero out the PIC state.
  static const PICState zero_pic_state = {0};
  *pic = zero_pic_state;
  pic->config = config;

  // All interrupts masked by default.
  pic->imr = 0xFF;
}

// ============================================================================
// IRQ line control
// ============================================================================

void PICRaiseIRQ(PICState* pic, uint8_t irq) {
  if (irq > 7) {
    return;
  }
  pic->irr |= (1 << irq);

  // If this is a slave PIC, also raise the cascade IRQ on the master.
  if (PICIsSlave(pic) && pic->cascade_pic) {
    PICRaiseIRQ(pic->cascade_pic, PICGetCascadeIRQ(pic));
  }
}

void PICLowerIRQ(PICState* pic, uint8_t irq) {
  if (irq > 7) {
    return;
  }
  pic->irr &= ~(1 << irq);

  // If this is a slave PIC and no interrupts are pending, lower the cascade
  // IRQ on the master.
  if (PICIsSlave(pic) && pic->irr == 0 && pic->cascade_pic) {
    PICLowerIRQ(pic->cascade_pic, PICGetCascadeIRQ(pic));
  }
}

// ============================================================================
// I/O port interface
// ============================================================================

uint8_t PICReadPort(PICState* pic, uint16_t port) {
  PICPort pic_port = PICGetPort(pic, port);
  switch (pic_port) {
    case kPICPortCommand:
      // Reading from the command port is not a defined operation.
      return 0x00;

    case kPICPortData: {
      uint8_t value;
      switch (pic->read_register) {
        case kPICReadIRR:
          value = pic->irr;
          break;
        case kPICReadISR:
          value = pic->isr;
          break;
        default:
          value = pic->imr;
          break;
      }
      pic->read_register = kPICReadIMR;
      return value;
    }

    default:
      // Invalid port.
      return 0x00;
  }
}

void PICWritePort(PICState* pic, uint16_t port, uint8_t value) {
  PICPort pic_port = PICGetPort(pic, port);
  switch (pic_port) {
    case kPICPortCommand:
      if (value & kICW1_INIT) {
        // This is ICW1, which starts the initialization sequence.
        pic->icw1 = value;
        pic->irr = 0x00;
        pic->isr = 0x00;
        // All interrupts masked by default.
        pic->imr = 0xFF;

        // The next write to the data port will be ICW2.
        pic->init_state = kPICExpectICW2;
      } else {
        // This is an OCW (Operational Command Word).
        if (value & kOCW_SELECT) {
          // This is OCW3.
          if (value & kOCW3_RR) {
            // This is a Read Register command.
            pic->read_register = value & kOCW3_RIS ? kPICReadISR : kPICReadIRR;
          } else {
            // Other OCW3 commands (e.g. Special Mask Mode) are not
            // implemented.
          }
        } else {
          // This is OCW2.
          if (value & kOCW2_EOI) {
            if (value & kOCW2_SL) {
              // Specific EOI: clear specified ISR bit.
              uint8_t irq = value & 0x07;
              pic->isr &= ~(1 << irq);
            } else {
              // Non-Specific EOI: clear highest priority ISR bit.
              for (uint8_t i = 0, isr_mask = 1; i < 8; ++i, isr_mask <<= 1) {
                if (pic->isr & isr_mask) {
                  pic->isr &= ~isr_mask;
                  break;
                }
              }
            }
          } else {
            // Other OCW2 commands (Rotate) are not implemented as they are not
            // used by MS-DOS or the IBM PC BIOS.
          }
        }
      }
      break;

    case kPICPortData:
      switch (pic->init_state) {
        case kPICExpectICW2:
          // This is ICW2. It sets the interrupt vector base.
          // The PIC uses the upper 5 bits of this value.
          pic->icw2 = value;
          if (PICIsSingle(pic)) {
            // Single mode -> no ICW3, ICW4 optional depending on ICW1.
            pic->init_state =
                pic->icw1 & kICW1_IC4 ? kPICExpectICW4 : kPICReady;
          } else {
            // Cascaded mode. Expect ICW3 next.
            pic->init_state = kPICExpectICW3;
          }
          break;

        case kPICExpectICW3:
          // This is ICW3.
          // For master, it's a bitmask of slaves.
          // For slave, it's the 3-bit slave ID.
          pic->icw3 = value;
          // ICW4 is optional depending on ICW1.
          pic->init_state = pic->icw1 & kICW1_IC4 ? kPICExpectICW4 : kPICReady;
          break;

        case kPICExpectICW4:
          // This is ICW4.
          pic->init_state = kPICReady;
          break;

        default:
          // This is an OCW1, which sets the IMR.
          pic->imr = value;
          break;
      }
      break;

    default:
      // Invalid port - ignore.
      break;
  }
}

// ============================================================================
// Interrupt handling
// ============================================================================

uint8_t PICGetPendingInterrupt(PICState* pic) {
  // Find highest priority requested and unmasked interrupt.
  uint8_t irr = pic->irr & ~pic->imr;
  if (irr == 0) {
    return kPICNoPendingInterrupt;
  }
  uint8_t pending_irq = 0, pending_irq_mask = 1;
  for (; pending_irq < 8; ++pending_irq, pending_irq_mask <<= 1) {
    if (irr & pending_irq_mask) {
      break;
    }
  }

  // If there is already an interrupt being serviced, the new pending interrupt
  // must have higher priority (lower IRQ number) to be serviced now.
  if (pic->isr > 0) {
    uint8_t in_service_irq = 0, in_service_irq_mask = 1;
    for (; in_service_irq < 8; ++in_service_irq, in_service_irq_mask <<= 1) {
      if (pic->isr & in_service_irq_mask) {
        break;
      }
    }
    if (pending_irq >= in_service_irq) {
      // New interrupt does not have higher priority than in-service interrupt.
      return kPICNoPendingInterrupt;
    }
  }

  // If this is the master PIC and the interrupt is from the slave, return the
  // slave PIC's interrupt vector.
  if (PICIsMaster(pic) && pending_irq == kMasterCascadeIRQ &&
      pic->cascade_pic) {
    uint8_t slave_vector = PICGetPendingInterrupt(pic->cascade_pic);
    if (slave_vector != kPICNoPendingInterrupt) {
      pic->isr |= pending_irq_mask;
    }
    return slave_vector;
  }

  // This is a normal interrupt on this PIC (or it's a slave reporting up).
  pic->isr |= pending_irq_mask;
  pic->irr &= ~pending_irq_mask;

  return (pic->icw2 & kICW2_BASE) + pending_irq;
}



// ==============================================================================
// src/pic/pic.c end
// ==============================================================================


#endif  // YAX86_IMPLEMENTATION

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  // YAX86_PIC_BUNDLE_H

// ==============================================================================
// YAX86 PIT MODULE - GENERATED SINGLE HEADER BUNDLE
// ==============================================================================

#ifndef YAX86_PIT_BUNDLE_H
#define YAX86_PIT_BUNDLE_H

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// ==============================================================================
// src/pit/public.h start
// ==============================================================================

#line 1 "./src/pit/public.h"
// Public interface for the PIT module.
#ifndef YAX86_PIT_PUBLIC_H
#define YAX86_PIT_PUBLIC_H

// This module emulates the Intel 8253/8254 PIT on the IBM PC series.
//
// Note that we do not support all features of the 8253/8254 PIT, notably:
// - Only supports binary mode (not BCD).
// - Only supports modes 0, 2, and 3 (not 1, 4, and 5)
//
// Channel 0 is used for the system timer (IRQ 0).
// Channel 1 is used for DRAM refresh on real hardware but not relevant here.
// Channel 2 is used for the PC speaker.

#include <stdbool.h>
#include <stdint.h>

enum {
  // Number of PIT channels.
  kPITNumChannels = 3,
  // Total number of operating modes (0-5).
  // We only implement modes 0, 2, and 3.
  kPITNumModes = 6,
};

// I/O ports exposed by the PIT.
typedef enum PITPort {
  // Data port for PIT channel 0
  kPITPortChannel0 = 0x40,
  // Data port for PIT channel 1
  kPITPortChannel1 = 0x41,
  // Data port for PIT channel 2
  kPITPortChannel2 = 0x42,
  // Control word port
  kPITPortControl = 0x43,
} PITPort;

// Channel read/write access modes. This corresponds to bits 4-5 of the control
// word written to port 0x43.
typedef enum PITAccessMode {
  // Latch count value command
  kPITAccessLatch = 0,
  // Read/write lower byte only
  kPITAccessLSBOnly = 1,
  // Read/write upper byte only
  kPITAccessMSBOnly = 2,
  // Read/write lower byte then upper byte
  kPITAccessLSBThenMSB = 3,
} PITAccessMode;

// Which byte to read/write next when in mode kPITAccessLSBThenMSB.
typedef enum PITByte {
  kPITByteLSB = 0,
  kPITByteMSB = 1,
} PITByte;

struct PITState;

// Caller-provided runtime configuration for the PIT.
typedef struct PITConfig {
  // Custom data passed through to callbacks.
  void* context;

  // Callback to raise IRQ 0.
  void (*raise_irq_0)(void* context);

  // Callback to set PC speaker frequency in Hz.
  void (*set_pc_speaker_frequency)(void* context, uint32_t frequency_hz);
} PITConfig;

// State of a single PIT timer channel.
typedef struct PITChannelState {
  // The 16-bit counter value.
  uint16_t counter;
  // The 16-bit latched value for reading.
  uint16_t latch;
  // The 16-bit reload value.
  uint16_t reload_value;
  // The operating mode (0-5).
  uint8_t mode;
  // The read/write access mode.
  PITAccessMode access_mode;
  // The current output state of the channel.
  bool output_state;
  // Which byte to read/write next when in mode kPITAccessLSBThenMSB.
  PITByte rw_byte;
  // Whether a latch command is active.
  bool latch_active;
} PITChannelState;

// State of the PIT.
typedef struct PITState {
  // Pointer to the PIT configuration.
  PITConfig* config;

  // The three timer channels.
  PITChannelState channels[kPITNumChannels];
} PITState;

// Initializes the PIT to its power-on state.
void PITInit(PITState* pit, PITConfig* config);

// Handles reads from the PIT's I/O ports (0x40-0x42).
uint8_t PITReadPort(PITState* pit, uint16_t port);

// Handles writes to the PIT's I/O ports (0x40-0x43).
void PITWritePort(PITState* pit, uint16_t port, uint8_t value);

// Simulates a single tick of the PIT's input clock. This method should be
// invoked at a frequency of 1.193182 MHz for accurate timing.
void PITTick(PITState* pit);

#endif  // YAX86_PIT_PUBLIC_H



// ==============================================================================
// src/pit/public.h end
// ==============================================================================


#ifdef YAX86_IMPLEMENTATION

// ==============================================================================
// src/pit/pit.c start
// ==============================================================================

#line 1 "./src/pit/pit.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "public.h"
#endif  // YAX86_IMPLEMENTATION

enum {
  // Tick frequency of the PIT in Hz.
  kPITTickFrequencyHz = 1193182,
  // Fallback reload value when 0 is written to the counter. The hardware
  // treats a reload value of 0 as 0x10000.
  kPITFallbackReloadValue = 0x10000,
};

// Specifies the behavior of a timer channel in a specific mode (0-5).
typedef struct PITModeMetadata {
  // Initial output state when a timer channel is programmed in this mode.
  bool initial_output_state;
  // Callback to handle a tick for this mode.
  void (*handle_tick)(
      PITState* pit, PITChannelState* channel, int channel_index);
} PITModeMetadata;

// Metadata for unsupported modes (1, 4, 5).
static const PITModeMetadata kPITUnsupportedMode = {0};

// Handles a channel reaching terminal count.
static inline void PITChannelSetOutputState(
    PITState* pit, PITChannelState* channel, int channel_index,
    bool new_output_state) {
  // No-op if the output state is unchanged.
  if (channel->output_state == new_output_state) {
    return;
  }

  // Set the new output state.
  channel->output_state = new_output_state;

  // On rising edge of channel 0 output state, raise IRQ 0.
  if (channel_index == 0 && new_output_state && pit->config &&
      pit->config->raise_irq_0) {
    pit->config->raise_irq_0(pit->config->context);
  }
}

// Tick handler for Mode 0: Interrupt on Terminal Count.
static void PITMode0HandleTick(
    PITState* pit, PITChannelState* channel, int channel_index) {
  // Since this is a one-shot timer, do nothing if the counter is already 0.
  if (channel->counter == 0) {
    return;
  }

  // Decrement the counter by 1.
  --channel->counter;

  // If at terminal count, set output high and trigger terminal count.
  if (channel->counter == 0) {
    PITChannelSetOutputState(pit, channel, channel_index, true);
  }
}

// Metadata for Mode 0: Interrupt on Terminal Count.
static const PITModeMetadata kPITMode0Metadata = {
    .initial_output_state = false,
    .handle_tick = PITMode0HandleTick,
};

// Tick handler for Mode 2: Rate Generator.
static void PITMode2HandleTick(
    PITState* pit, PITChannelState* channel, int channel_index) {
  // Decrement the counter by 1.
  --channel->counter;

  switch (channel->counter) {
    case 1:
      // When the counter reaches 1, set output low for one tick.
      PITChannelSetOutputState(pit, channel, channel_index, false);
      break;
    case 0:
      // When the counter reaches 0, reload, set output high again.
      channel->counter = channel->reload_value;
      PITChannelSetOutputState(pit, channel, channel_index, true);
      break;
    default:
      break;
  }
}

// Metadata for Mode 2: Rate Generator.
static const PITModeMetadata kPITMode2Metadata = {
    .initial_output_state = true,
    .handle_tick = PITMode2HandleTick,
};

// Tick handler for Mode 3: Square Wave Generator.
static void PITMode3HandleTick(
    PITState* pit, PITChannelState* channel, int channel_index) {
  // In Mode 3, the counter decrements by 2 each tick. We reach terminal count
  // when we reach either 0 or wrap around to 0xFFFF.
  channel->counter -= 2;

  switch (channel->counter) {
    case 0:
    case 0xFFFF:
      // When the counter reaches terminal count, reload and toggle output.
      channel->counter = channel->reload_value;
      PITChannelSetOutputState(
          pit, channel, channel_index, !channel->output_state);
      break;
    default:
      break;
  }
}

// Metadata for Mode 3: Square Wave Generator.
static const PITModeMetadata kPITMode3Metadata = {
    .initial_output_state = true,
    .handle_tick = PITMode3HandleTick,
};

// Array of mode metadata indexed by mode number.
static const PITModeMetadata* kPITModeMetadata[kPITNumModes] = {
    &kPITMode0Metadata,    // Mode 0
    &kPITUnsupportedMode,  // Mode 1 (unsupported)
    &kPITMode2Metadata,    // Mode 2
    &kPITMode3Metadata,    // Mode 3
    &kPITUnsupportedMode,  // Mode 4 (unsupported)
    &kPITUnsupportedMode,  // Mode 5 (unsupported)
};

void PITInit(PITState* pit, PITConfig* config) {
  static const PITState zero_pit_state = {0};
  *pit = zero_pit_state;
  pit->config = config;

  // On the IBM PC, the output pins of all three channels are initially pulled
  // high.
  for (int i = 0; i < kPITNumChannels; ++i) {
    pit->channels[i].output_state = true;
  }
}

// Helper function to load the counter and handle side effects.
static inline void PITChannelLoadCounter(
    PITState* pit, PITChannelState* channel, int channel_index) {
  // A reload value of 0 is treated as 0x10000 by the hardware.
  // This will wrap to 0 when assigned to the 16-bit counter.
  channel->counter = channel->reload_value;

  // If this is channel 2, notify the platform of the new PC speaker frequency.
  if (channel_index == 2 && pit->config &&
      pit->config->set_pc_speaker_frequency) {
    uint32_t frequency =
        kPITTickFrequencyHz / (channel->reload_value ? channel->reload_value
                                                     : kPITFallbackReloadValue);
    pit->config->set_pc_speaker_frequency(pit->config->context, frequency);
  }
}

// Helper function to handle a write to a channel's data port.
static inline void PITChannelWritePort(
    PITState* pit, PITChannelState* channel, int channel_index, uint8_t value) {
  switch (channel->access_mode) {
    case kPITAccessLatch:
      // If latch command, ignore data writes.
      break;
    case kPITAccessLSBOnly:
      channel->reload_value = (channel->reload_value & 0xFF00) | value;
      PITChannelLoadCounter(pit, channel, channel_index);
      break;
    case kPITAccessMSBOnly:
      channel->reload_value =
          (channel->reload_value & 0x00FF) | ((uint16_t)value << 8);
      PITChannelLoadCounter(pit, channel, channel_index);
      break;
    case kPITAccessLSBThenMSB:
      switch (channel->rw_byte) {
        case kPITByteLSB:
          // LSB
          channel->reload_value = (channel->reload_value & 0xFF00) | value;
          channel->rw_byte = kPITByteMSB;
          break;
        case kPITByteMSB:
          // MSB
          channel->reload_value =
              (channel->reload_value & 0x00FF) | ((uint16_t)value << 8);
          channel->rw_byte = kPITByteLSB;
          PITChannelLoadCounter(pit, channel, channel_index);
          break;
        default:
          // Should not happen - ignore.
          break;
      }
      break;
    default:
      // Invalid access mode - ignore.
      break;
  }
}

void PITWritePort(PITState* pit, uint16_t port, uint8_t value) {
  switch (port) {
    case kPITPortControl: {
      // Control word.
      int channel_index = (value >> 6) & 0x03;
      if (channel_index >= kPITNumChannels) {
        // Invalid channel, or read-back command (not supported).
        return;
      }
      PITChannelState* channel = &pit->channels[channel_index];

      PITAccessMode access_mode = (PITAccessMode)((value >> 4) & 0x03);
      if (access_mode == kPITAccessLatch) {
        // Latch command.
        channel->latch = channel->counter;
        channel->latch_active = true;
      } else {
        // Programming command.
        channel->access_mode = access_mode;
        channel->mode = (value >> 1) & 0x07;
        if (channel->mode >= kPITNumModes) {
          // Modes 6 and 7 are equivalent to modes 2 and 3.
          channel->mode -= 4;
        }
        channel->rw_byte = kPITByteLSB;
        PITChannelSetOutputState(
            pit, channel, channel_index,
            kPITModeMetadata[channel->mode]->initial_output_state);
      }
      break;
    }
    case kPITPortChannel0:
    case kPITPortChannel1:
    case kPITPortChannel2: {
      // Data port for a channel.
      int channel_index = port - kPITPortChannel0;
      PITChannelState* channel = &pit->channels[channel_index];
      PITChannelWritePort(pit, channel, channel_index, value);
      break;
    }
    default:
      // Invalid port - ignore.
      break;
  }
}

// Helper function to handle a read from a channel's data port.
static inline uint8_t PITChannelReadPort(
    YAX86_UNUSED PITState* pit, PITChannelState* channel,
    YAX86_UNUSED int channel_index) {
  uint16_t value = channel->latch_active ? channel->latch : channel->counter;
  uint8_t result = 0;

  switch (channel->access_mode) {
    case kPITAccessLatch:
      // This is a command, not a persistent access mode. Ignore.
      break;
    case kPITAccessLSBOnly:
      result = value & 0xFF;
      channel->latch_active = false;
      break;
    case kPITAccessMSBOnly:
      result = (value >> 8) & 0xFF;
      channel->latch_active = false;
      break;
    case kPITAccessLSBThenMSB:
      switch (channel->rw_byte) {
        case kPITByteLSB:
          result = value & 0xFF;
          channel->rw_byte = kPITByteMSB;
          break;
        case kPITByteMSB:
          result = (value >> 8) & 0xFF;
          channel->rw_byte = kPITByteLSB;
          // The full value has been read, so deactivate the latch.
          channel->latch_active = false;
          break;
        default:
          // Should not happen.
          break;
      }
      break;
    default:
      // Invalid access mode.
      break;
  }
  return result;
}

uint8_t PITReadPort(PITState* pit, uint16_t port) {
  switch (port) {
    case kPITPortChannel0:
    case kPITPortChannel1:
    case kPITPortChannel2: {
      // Data port for a channel.
      int channel_index = port - kPITPortChannel0;
      PITChannelState* channel = &pit->channels[channel_index];
      return PITChannelReadPort(pit, channel, channel_index);
    }
    default:
      // Invalid port - return 0xFF as is common for reads from unused ports.
      return 0xFF;
  }
}

void PITTick(PITState* pit) {
  PITChannelState* channel = &pit->channels[0];
  for (int i = 0; i < kPITNumChannels; ++i, ++channel) {
    if (channel->mode >= kPITNumModes) {
      // Invalid mode - ignore.
      continue;
    }
    const PITModeMetadata* mode_metadata = kPITModeMetadata[channel->mode];
    if (mode_metadata->handle_tick) {
      mode_metadata->handle_tick(pit, channel, i);
    }
  }
}


// ==============================================================================
// src/pit/pit.c end
// ==============================================================================


#endif  // YAX86_IMPLEMENTATION

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  // YAX86_PIT_BUNDLE_H

// ==============================================================================
// YAX86 PLATFORM MODULE - GENERATED SINGLE HEADER BUNDLE
// ==============================================================================

#ifndef YAX86_PLATFORM_BUNDLE_H
#define YAX86_PLATFORM_BUNDLE_H

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// ==============================================================================
// src/util/static_vector.h start
// ==============================================================================

#line 1 "./src/util/static_vector.h"
// Static vector library.
//
// A static vector is a vector backed by a fixed-size array. It's essentially
// a vector, but whose underlying storage is statically allocated and does not
// rely on dynamic memory allocation.

#ifndef YAX86_UTIL_STATIC_VECTOR_H
#define YAX86_UTIL_STATIC_VECTOR_H

#include <stddef.h>
#include <stdint.h>

// Header structure at the beginning of a static vector.
typedef struct StaticVectorHeader {
  // Element size in bytes.
  size_t element_size;
  // Maximum number of elements the vector can hold.
  size_t max_length;
  // Number of elements currently in the vector.
  size_t length;
} StaticVectorHeader;

// Define a static vector type with an element type.
#define STATIC_VECTOR_TYPE(name, element_type, max_length_value)          \
  typedef struct name {                                                   \
    StaticVectorHeader header;                                            \
    element_type elements[max_length_value];                              \
  } name;                                                                 \
  static void name##Init(name* vector) __attribute__((unused));           \
  static void name##Init(name* vector) {                                  \
    static const StaticVectorHeader header = {                            \
        .element_size = sizeof(element_type),                             \
        .max_length = (max_length_value),                                 \
        .length = 0,                                                      \
    };                                                                    \
    vector->header = header;                                              \
  }                                                                       \
  static size_t name##Length(const name* vector) __attribute__((unused)); \
  static size_t name##Length(const name* vector) {                        \
    return vector->header.length;                                         \
  }                                                                       \
  static element_type* name##Get(name* vector, size_t index)              \
      __attribute__((unused));                                            \
  static element_type* name##Get(name* vector, size_t index) {            \
    if (index >= (max_length_value)) {                                    \
      return NULL;                                                        \
    }                                                                     \
    return &(vector->elements[index]);                                    \
  }                                                                       \
  static bool name##Append(name* vector, const element_type* element)     \
      __attribute__((unused));                                            \
  static bool name##Append(name* vector, const element_type* element) {   \
    if (vector->header.length >= (max_length_value)) {                    \
      return false;                                                       \
    }                                                                     \
    vector->elements[vector->header.length++] = *element;                 \
    return true;                                                          \
  }                                                                       \
  static bool name##Insert(                                               \
      name* vector, size_t index, const element_type* element)            \
      __attribute__((unused));                                            \
  static bool name##Insert(                                               \
      name* vector, size_t index, const element_type* element) {          \
    if (index > vector->header.length ||                                  \
        vector->header.length >= (max_length_value)) {                    \
      return false;                                                       \
    }                                                                     \
    for (size_t i = vector->header.length; i > index; --i) {              \
      vector->elements[i] = vector->elements[i - 1];                      \
    }                                                                     \
    vector->elements[index] = *element;                                   \
    ++vector->header.length;                                              \
    return true;                                                          \
  }                                                                       \
  static bool name##Remove(name* vector, size_t index)                    \
      __attribute__((unused));                                            \
  static bool name##Remove(name* vector, size_t index) {                  \
    if (index >= vector->header.length) {                                 \
      return false;                                                       \
    }                                                                     \
    for (size_t i = index; i < vector->header.length - 1; ++i) {          \
      vector->elements[i] = vector->elements[i + 1];                      \
    }                                                                     \
    --vector->header.length;                                              \
    return true;                                                          \
  }                                                                       \
  static void name##Clear(name* vector) __attribute__((unused));          \
  static void name##Clear(name* vector) { vector->header.length = 0; }

#endif  // YAX86_UTIL_STATIC_VECTOR_H


// ==============================================================================
// src/util/static_vector.h end
// ==============================================================================

// ==============================================================================
// src/platform/public.h start
// ==============================================================================

#line 1 "./src/platform/public.h"
// Public interface for the Platform module.
#ifndef YAX86_PLATFORM_PUBLIC_H
#define YAX86_PLATFORM_PUBLIC_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifndef YAX86_PLATFORM_BUNDLE_H
#include "../util/static_vector.h"
#endif  // YAX86_PLATFORM_BUNDLE_H

#include "cpu.h"
#include "dma.h"
#include "fdc.h"
#include "keyboard.h"
#include "pic.h"
#include "pit.h"
#include "ppi.h"
#include "video.h"

struct PlatformState;

// ============================================================================
// Memory mapping
// ============================================================================

// Type ID of a memory map entry.
typedef uint8_t MemoryMapEntryType;

enum {
  // Conventional memory - first 640KB of physical memory, mapped to 0x00000 to
  // 0x9FFFF (640KB).
  kMemoryMapEntryConventional = 0,

  // Maximum number of memory map entries.
  kMaxMemoryMapEntries = 16,

  // Maximum size of physical memory in bytes.
  kMaxPhysicalMemorySize = 640 * 1024,
  // Minimum size of physical memory in bytes.
  kMinPhysicalMemorySize = 64 * 1024,
};

// A memory map entry for a region in logical address space. Memory regions
// should not overlap.
typedef struct MemoryMapEntry {
  // Custom data passed through to callbacks.
  void* context;

  // The memory map entry type, such as kMemoryMapEntryConventional.
  MemoryMapEntryType entry_type;
  // Start address of the memory region.
  uint32_t start;
  // Inclusive end address of the memory region.
  uint32_t end;
  // Callback to read a byte from the memory map entry, where address is
  // relative to the start of the entry.
  uint8_t (*read_byte)(struct MemoryMapEntry* entry, uint32_t relative_address);
  // Callback to write a byte to memory, where address is relative to the start
  // address.
  void (*write_byte)(
      struct MemoryMapEntry* entry, uint32_t relative_address, uint8_t value);
} MemoryMapEntry;

// Register a memory map entry in the platform state. Returns true if the entry
// was successfully registered, or false if:
//   - There already exists a memory map entry with the same type.
//   - The new entry's memory region overlaps with an existing entry.
//   - The number of memory map entries would exceed kMaxMemoryMapEntries.
bool RegisterMemoryMapEntry(
    struct PlatformState* platform, const MemoryMapEntry* entry);
// Look up the memory map entry corresponding to an address. Returns NULL if the
// address is not mapped to a known memory map entry.
MemoryMapEntry* GetMemoryMapEntryForAddress(
    struct PlatformState* platform, uint32_t address);
// Look up a memory map entry by type. Returns NULL if no entry found with the
// specified type.
MemoryMapEntry* GetMemoryMapEntryByType(
    struct PlatformState* platform, MemoryMapEntryType entry_type);

// Read a byte from a logical memory address by invoking the corresponding
// memory map entry's read_byte callback.
//
// On the 8086, accessing an invalid memory address will yield garbage data
// rather than causing a page fault. This callback interface mirrors that
// behavior.
uint8_t ReadMemoryByte(struct PlatformState* platform, uint32_t address);
// Read a word from a logical memory address by invoking the corresponding
// memory map entry's read_byte callback.
uint16_t ReadMemoryWord(struct PlatformState* platform, uint32_t address);
// Write a byte to a logical memory address by invoking the corresponding
// memory map entry's write_byte callback.
//
// On the 8086, accessing an invalid memory address will yield garbage data
// rather than causing a page fault. This callback interface mirrors that
// behavior.
void WriteMemoryByte(
    struct PlatformState* platform, uint32_t address, uint8_t value);
// Write a word to a logical memory address by invoking the corresponding
// memory map entry's write_byte callback.
void WriteMemoryWord(
    struct PlatformState* platform, uint32_t address, uint16_t value);

// ============================================================================
// I/O port mapping
// ============================================================================

// Type ID of an I/O port map entry.
typedef uint16_t PortMapEntryType;

enum {
  // Maximum number of I/O port mapping entries.
  kMaxPortMapEntries = 16,
  // I/O port map entry for the master PIC (ports 0x20-0x21).
  kPortMapEntryPIC = 0x20,
  // I/O port map entry for the PIT (ports 0x40-0x43).
  kPortMapEntryPIT = 0x40,
  // I/O port map entry for the PPI (ports 0x60-0x63).
  kPortMapEntryPPI = 0x60,
  // I/O port map entry for the FDC (ports 0x3F0-0x3F7).
  kPortMapEntryFDC = 0x3F0,
  // I/O port map entry for the DMA controller (ports 0x00-0x0F).
  kPortMapEntryDMA = 0x00,
  // I/O port map entry for the DMA Page Registers (ports 0x80-0x8F).
  kPortMapEntryDMAPage = 0x80,
};

// An I/O port map entry. Entries should not overlap.
typedef struct PortMapEntry {
  // Custom data passed through to callbacks.
  void* context;

  // The I/O port map entry type.
  PortMapEntryType entry_type;
  // Start of the I/O port range.
  uint16_t start;
  // Inclusive end of the I/O port range.
  uint16_t end;
  // Callback to read a byte from an I/O port within the range.
  uint8_t (*read_byte)(struct PortMapEntry* entry, uint16_t port);
  // Callback to write a byte an I/O port within the range.
  void (*write_byte)(struct PortMapEntry* entry, uint16_t port, uint8_t value);
} PortMapEntry;

// Register an I/O port map entry in the platform state. Returns true if the
// entry was successfully registered, or false if:
//   - There already exists an I/O port map entry with the same type.
//   - The new entry's I/O port range overlaps with an existing entry.
bool RegisterPortMapEntry(
    struct PlatformState* platform, const PortMapEntry* entry);
// Look up the I/O port map entry corresponding to a port. Returns NULL if the
// port is not mapped to a known I/O port map entry.
PortMapEntry* GetPortMapEntryForPort(
    struct PlatformState* platform, uint16_t port);
// Look up an I/O port map entry by type. Returns NULL if no entry found with
// the specified type.
PortMapEntry* GetPortMapEntryByType(
    struct PlatformState* platform, PortMapEntryType entry_type);

// Read a byte from an I/O port by invoking the corresponding I/O port map
// entry's read_byte callback.
uint8_t ReadPortByte(struct PlatformState* platform, uint16_t port);
// Read a word from an I/O port by invoking the corresponding I/O port map
// entry's read_byte callback. This reads two consecutive bytes from the port.
uint16_t ReadPortWord(struct PlatformState* platform, uint16_t port);
// Write a byte to an I/O port by invoking the corresponding I/O port map
// entry's write_byte callback.
void WritePortByte(
    struct PlatformState* platform, uint16_t port, uint8_t value);
// Write a word to an I/O port by invoking the corresponding I/O port map
// entry's write_byte callback. This writes two consecutive bytes to the port.
void WritePortWord(
    struct PlatformState* platform, uint16_t port, uint16_t value);

// ============================================================================
// Platform state
// ============================================================================

// Caller-provided runtime configuration.
typedef struct PlatformConfig {
  // Custom data passed through to callbacks.
  void* context;

  // Physical memory size in bytes. Must be between 64K and 640K.
  uint32_t physical_memory_size;

  // Callback to read a byte from physical memory.
  //
  // On the 8086, accessing an invalid memory address will yield garbage data
  // rather than causing a page fault. This callback interface mirrors that
  // behavior.
  //
  // For simplicity, we use a single 8-bit interface for memory access, similar
  // to the real-life 8088.
  uint8_t (*read_physical_memory_byte)(
      struct PlatformState* platform, uint32_t address);

  // Callback to write a byte to physical memory.
  //
  // On the 8086, accessing an invalid memory address will yield garbage data
  // rather than causing a page fault. This callback interface mirrors that
  // behavior.
  //
  // For simplicity, we use a single 8-bit interface for memory access, similar
  // to the real-life 8088.
  void (*write_physical_memory_byte)(
      struct PlatformState* platform, uint32_t address, uint8_t value);
} PlatformConfig;

STATIC_VECTOR_TYPE(MemoryMap, MemoryMapEntry, kMaxMemoryMapEntries)
STATIC_VECTOR_TYPE(PortMap, PortMapEntry, kMaxPortMapEntries)

// State of the platform.
typedef struct PlatformState {
  // Pointer to caller-provided runtime configuration.
  PlatformConfig* config;

  // CPU runtime configuration.
  CPUConfig cpu_config;
  // CPU state.
  CPUState cpu;

  // PIC runtime configuration.
  PICConfig pic_config;
  // PIC state.
  PICState pic;

  // PIT runtime configuration.
  PITConfig pit_config;
  // PIT state.
  PITState pit;

  // PPI runtime configuration.
  PPIConfig ppi_config;
  // PPI state.
  PPIState ppi;

  // Keyboard runtime configuration.
  KeyboardConfig keyboard_config;
  // Keyboard state.
  KeyboardState keyboard;

  // DMA controller runtime configuration.
  DMAConfig dma_config;
  // DMA controller state.
  DMAState dma;

  // FDC state.
  FDCConfig fdc_config;
  FDCState fdc;

  // MDA runtime configuration.
  MDAConfig mda_config;
  // MDA state.
  MDAState mda;

  // Memory map.
  MemoryMap memory_map;
  // I/O port map.
  PortMap io_port_map;

  // How many ticks have run.
  uint32_t ticks;
} PlatformState;

// Initialize the platform state with the provided configuration. Returns true
// if the platform state was successfully initialized, or false if:
//   - The physical memory size is not between 64K and 640K.
bool PlatformInit(PlatformState* platform, PlatformConfig* config);

// Raise a hardware interrupt to the CPU via the PIC. Returns true if the
// IRQ was successfully raised, or false if the IRQ number is invalid.
bool PlatformRaiseIRQ(PlatformState* platform, uint8_t irq);

// Run a single cycle of the platform, including ticking all sub-modules. This
// should be called at the CPU clock rate (4.77MHz for the 8088).
void PlatformTick(PlatformState* platform);

#endif  // YAX86_PLATFORM_PUBLIC_H


// ==============================================================================
// src/platform/public.h end
// ==============================================================================


#ifdef YAX86_IMPLEMENTATION

// ==============================================================================
// src/util/common.h start
// ==============================================================================

#line 1 "./src/util/common.h"
#ifndef YAX86_UTIL_COMMON_H
#define YAX86_UTIL_COMMON_H

// Macro that expands to `static` when bundled. Use for variables and functions
// that need to be visible to other files within the same module, but not
// publicly to users of the bundled library.
//
// This enables better IDE integration as it allows each source file to be
// compiled independently in unbundled form, but still keeps the symbols private
// when bundled.
#ifdef YAX86_IMPLEMENTATION
// When bundled, static linkage so that the symbol is only visible within the
// implementation file.
#define YAX86_PRIVATE static
#else
// When unbundled, use default linkage.
#define YAX86_PRIVATE
#endif  // YAX86_IMPLEMENTATION

// Macro to mark a function or parameter as unused.
#if defined(__GNUC__) || defined(__clang__)
#define YAX86_UNUSED __attribute__((unused))
#else
#define YAX86_UNUSED
#endif  // defined(__GNUC__) || defined(__clang__)

#endif  // YAX86_UTIL_COMMON_H


// ==============================================================================
// src/util/common.h end
// ==============================================================================

// ==============================================================================
// src/platform/platform.c start
// ==============================================================================

#line 1 "./src/platform/platform.c"
#include "bios.h"
#include "pic.h"
#include "ppi.h"

#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "public.h"
#endif  // YAX86_IMPLEMENTATION

// Register a memory map entry in the platform state. Returns true if the entry
// was successfully registered, or false if:
//   - There already exists a memory map entry with the same type.
//   - The new entry's memory region overlaps with an existing entry.
//   - The number of memory map entries would exceed kMaxMemoryMapEntries.
bool RegisterMemoryMapEntry(
    PlatformState* platform, const MemoryMapEntry* entry) {
  if (MemoryMapLength(&platform->memory_map) >= kMaxMemoryMapEntries) {
    return false;
  }
  for (uint8_t i = 0; i < MemoryMapLength(&platform->memory_map); ++i) {
    MemoryMapEntry* existing_entry = MemoryMapGet(&platform->memory_map, i);
    if (existing_entry->entry_type == entry->entry_type) {
      return false;
    }
    if (!(existing_entry->start > entry->end ||
          entry->start > existing_entry->end)) {
      return false;
    }
  }
  return MemoryMapAppend(&platform->memory_map, entry);
}

// Look up the memory region corresponding to an address. Returns NULL if the
// address is not mapped to a known memory region.
MemoryMapEntry* GetMemoryMapEntryForAddress(
    PlatformState* platform, uint32_t address) {
  // TODO: Use a more efficient data structure for lookups, such as a sorted
  // array with binary search.
  for (uint8_t i = 0; i < MemoryMapLength(&platform->memory_map); ++i) {
    MemoryMapEntry* entry = MemoryMapGet(&platform->memory_map, i);
    if (address >= entry->start && address <= entry->end) {
      return entry;
    }
  }
  return NULL;
}

// Look up a memory region by type. Returns NULL if no region found with the
// specified type.
MemoryMapEntry* GetMemoryMapEntryByType(
    PlatformState* platform, uint8_t entry_type) {
  for (uint8_t i = 0; i < MemoryMapLength(&platform->memory_map); ++i) {
    MemoryMapEntry* entry = MemoryMapGet(&platform->memory_map, i);
    if (entry->entry_type == entry_type) {
      return entry;
    }
  }
  return NULL;
}

// Read a byte from a logical memory address.
uint8_t ReadMemoryByte(PlatformState* platform, uint32_t address) {
  MemoryMapEntry* entry = GetMemoryMapEntryForAddress(platform, address);
  if (!entry || !entry->read_byte) {
    return 0xFF;
  }
  return entry->read_byte(entry, address - entry->start);
}

// Read a word from a logical memory address.
uint16_t ReadMemoryWord(PlatformState* platform, uint32_t address) {
  uint8_t low_byte = ReadMemoryByte(platform, address);
  uint8_t high_byte = ReadMemoryByte(platform, address + 1);
  return (high_byte << 8) | low_byte;
}

// Write a byte to a logical memory address.
void WriteMemoryByte(PlatformState* platform, uint32_t address, uint8_t value) {
  MemoryMapEntry* entry = GetMemoryMapEntryForAddress(platform, address);
  if (!entry || !entry->write_byte) {
    return;
  }
  entry->write_byte(entry, address - entry->start, value);
}

// Write a word to a logical memory address.
void WriteMemoryWord(
    PlatformState* platform, uint32_t address, uint16_t value) {
  WriteMemoryByte(platform, address, value & 0xFF);
  WriteMemoryByte(platform, address + 1, (value >> 8) & 0xFF);
}

// Register an I/O port map entry in the platform state. Returns true if the
// entry was successfully registered, or false if:
//   - There already exists an I/O port map entry with the same type.
//   - The new entry's I/O port range overlaps with an existing entry.
bool RegisterPortMapEntry(PlatformState* platform, const PortMapEntry* entry) {
  if (PortMapLength(&platform->io_port_map) >= kMaxPortMapEntries) {
    return false;
  }
  for (uint8_t i = 0; i < PortMapLength(&platform->io_port_map); ++i) {
    PortMapEntry* existing_entry = PortMapGet(&platform->io_port_map, i);
    if (existing_entry->entry_type == entry->entry_type) {
      return false;
    }
    if (!(existing_entry->start > entry->end ||
          entry->start > existing_entry->end)) {
      return false;
    }
  }
  return PortMapAppend(&platform->io_port_map, entry);
}

// Look up the I/O port map entry corresponding to a port. Returns NULL if the
// port is not mapped to a known I/O port map entry.
PortMapEntry* GetPortMapEntryForPort(PlatformState* platform, uint16_t port) {
  for (uint8_t i = 0; i < PortMapLength(&platform->io_port_map); ++i) {
    PortMapEntry* entry = PortMapGet(&platform->io_port_map, i);
    if (port >= entry->start && port <= entry->end) {
      return entry;
    }
  }
  return NULL;
}
// Look up an I/O port map entry by type. Returns NULL if no entry found with
// the specified type.
PortMapEntry* GetPortMapEntryByType(
    PlatformState* platform, PortMapEntryType entry_type) {
  for (uint8_t i = 0; i < PortMapLength(&platform->io_port_map); ++i) {
    PortMapEntry* entry = PortMapGet(&platform->io_port_map, i);
    if (entry->entry_type == entry_type) {
      return entry;
    }
  }
  return NULL;
}

// Read a byte from an I/O port by invoking the corresponding I/O port map
// entry's read_byte callback.
uint8_t ReadPortByte(PlatformState* platform, uint16_t port) {
  PortMapEntry* entry = GetPortMapEntryForPort(platform, port);
  if (!entry || !entry->read_byte) {
    return 0xFF;
  }
  return entry->read_byte(entry, port);
}

// Read a word from an I/O port by invoking the corresponding I/O port map
// entry's read_byte callback. This reads two consecutive bytes from the port.
uint16_t ReadPortWord(PlatformState* platform, uint16_t port) {
  uint8_t low_byte = ReadPortByte(platform, port);
  uint8_t high_byte = ReadPortByte(platform, port + 1);
  return (high_byte << 8) | low_byte;
}

// Write a byte to an I/O port by invoking the corresponding I/O port map
// entry's write_byte callback.
void WritePortByte(PlatformState* platform, uint16_t port, uint8_t value) {
  PortMapEntry* entry = GetPortMapEntryForPort(platform, port);
  if (!entry || !entry->write_byte) {
    return;
  }
  entry->write_byte(entry, port, value);
}

// Write a word to an I/O port by invoking the corresponding I/O port map
// entry's write_byte callback. This writes two consecutive bytes to the port.
void WritePortWord(PlatformState* platform, uint16_t port, uint16_t value) {
  WritePortByte(platform, port, value & 0xFF);
  WritePortByte(platform, port + 1, (value >> 8) & 0xFF);
}

// ============================================================================
// Callbacks for CPU module
// ============================================================================

static uint8_t CPUCallbackReadMemoryByte(CPUState* cpu, uint32_t address) {
  return ReadMemoryByte((PlatformState*)cpu->config->context, address);
}

static void CPUCallbackWriteMemoryByte(
    CPUState* cpu, uint32_t address, uint8_t value) {
  WriteMemoryByte((PlatformState*)cpu->config->context, address, value);
}

static uint8_t CPUCallbackReadPortByte(CPUState* cpu, uint16_t port) {
  return ReadPortByte((PlatformState*)cpu->config->context, port);
}

static void CPUCallbackWritePortByte(
    CPUState* cpu, uint16_t port, uint8_t value) {
  WritePortByte((PlatformState*)cpu->config->context, port, value);
}

static const CPUConfig kEmptyCPUConfig = {0};

// ============================================================================
// Callbacks for physical memory
// ============================================================================
static uint8_t ReadPhysicalMemoryByte(MemoryMapEntry* entry, uint32_t address) {
  PlatformState* platform = (PlatformState*)entry->context;
  if (platform->config && platform->config->read_physical_memory_byte) {
    return platform->config->read_physical_memory_byte(platform, address);
  }
  return 0xFF;
}

static void WritePhysicalMemoryByte(
    MemoryMapEntry* entry, uint32_t address, uint8_t value) {
  PlatformState* platform = (PlatformState*)entry->context;
  if (platform->config && platform->config->write_physical_memory_byte) {
    platform->config->write_physical_memory_byte(platform, address, value);
  }
}

// ============================================================================
// Callbacks for 8259 PIC module
// ============================================================================

static uint8_t PICCallbackReadPortByte(PortMapEntry* entry, uint16_t port) {
  return PICReadPort((PICState*)entry->context, port);
}

static void PICCallbackWritePortByte(
    PortMapEntry* entry, uint16_t port, uint8_t value) {
  PICWritePort((PICState*)entry->context, port, value);
}

static void PICCallbackPlatformRaiseIRQ0(void* context) {
  PlatformState* platform = (PlatformState*)context;
  PlatformRaiseIRQ(platform, 0);
}

// ============================================================================
// Callbacks for 8253 PIT module
// ============================================================================

static uint8_t PITCallbackReadPortByte(PortMapEntry* entry, uint16_t port) {
  return PITReadPort((PITState*)entry->context, port);
}

static void PITCallbackWritePortByte(
    PortMapEntry* entry, uint16_t port, uint8_t value) {
  PITWritePort((PITState*)entry->context, port, value);
}

static void PITCallbackSetPCSpeakerFrequency(
    void* context, uint32_t frequency_hz) {
  PlatformState* platform = (PlatformState*)context;
  PPISetPCSpeakerFrequencyFromPIT(&platform->ppi, frequency_hz);
}

// ============================================================================
// Callbacks for 8255 PPI module
// ============================================================================

static uint8_t PPICallbackReadPortByte(PortMapEntry* entry, uint16_t port) {
  return PPIReadPort((PPIState*)entry->context, port);
}

static void PPICallbackWritePortByte(
    PortMapEntry* entry, uint16_t port, uint8_t value) {
  PPIWritePort((PPIState*)entry->context, port, value);
}

static void PPICallbackSetKeyboardControl(
    void* context, bool keyboard_enable_clear, bool keyboard_clock_low) {
  PlatformState* platform = (PlatformState*)context;
  KeyboardHandleControl(
      &platform->keyboard, keyboard_enable_clear, keyboard_clock_low);
}

// ============================================================================
// Callbacks for Keyboard module
// ============================================================================

static void KeyboardCallbackPlatformRaiseIRQ1(void* context) {
  PlatformState* platform = (PlatformState*)context;
  PlatformRaiseIRQ(platform, 1);
}

static void KeyboardCallbackSendScancode(void* context, uint8_t scancode) {
  PlatformState* platform = (PlatformState*)context;
  PPISetScancode(&platform->ppi, scancode);
}

// ============================================================================
// Callbacks for uPD765 FDC module
// ============================================================================

enum {
  kPlatformDMAChannelFloppy = 2,
};

static void FDCCallbackRaiseIRQ6(void* context) {
  PlatformState* platform = (PlatformState*)context;
  PlatformRaiseIRQ(platform, 6);
}

static void FDCCallbackRequestDMA(void* context) {
  PlatformState* platform = (PlatformState*)context;
  DMATransferByte(&platform->dma, kPlatformDMAChannelFloppy);
}

static uint8_t FDCCallbackReadPortByte(PortMapEntry* entry, uint16_t port) {
  return FDCReadPort((FDCState*)entry->context, port);
}

static void FDCCallbackWritePortByte(
    PortMapEntry* entry, uint16_t port, uint8_t value) {
  FDCWritePort((FDCState*)entry->context, port, value);
}

// ============================================================================
// Callbacks for DMA module
// ============================================================================

static uint8_t DMACallbackReadMemoryByte(void* context, uint32_t address) {
  PlatformState* platform = (PlatformState*)context;
  return ReadMemoryByte(platform, address);
}

static void DMACallbackWriteMemoryByte(
    void* context, uint32_t address, uint8_t value) {
  PlatformState* platform = (PlatformState*)context;
  WriteMemoryByte(platform, address, value);
}

static uint8_t DMACallbackReadDeviceByte(void* context, uint8_t channel) {
  PlatformState* platform = (PlatformState*)context;
  switch (channel) {
    case kPlatformDMAChannelFloppy:
      return FDCReadPort(&platform->fdc, kFDCPortData);
    default:
      return 0xFF;
  }
}

static void DMACallbackWriteDeviceByte(
    void* context, uint8_t channel, uint8_t value) {
  PlatformState* platform = (PlatformState*)context;
  switch (channel) {
    case kPlatformDMAChannelFloppy:
      FDCWritePort(&platform->fdc, kFDCPortData, value);
      break;
    default:
      break;
  }
}

static void DMACallbackOnTerminalCount(void* context, uint8_t channel) {
  PlatformState* platform = (PlatformState*)context;
  switch (channel) {
    case kPlatformDMAChannelFloppy:
      FDCHandleTC(&platform->fdc);
      break;
    default:
      break;
  }
}

static uint8_t DMACallbackReadPortByte(PortMapEntry* entry, uint16_t port) {
  return DMAReadPort((DMAState*)entry->context, port);
}

static void DMACallbackWritePortByte(
    PortMapEntry* entry, uint16_t port, uint8_t value) {
  DMAWritePort((DMAState*)entry->context, port, value);
}

// ============================================================================
// Callbacks for MDA module
// ============================================================================

static uint8_t MDACallbackReadPortByte(PortMapEntry* entry, uint16_t port) {
  return MDAReadPort((MDAState*)entry->context, port);
}

static void MDACallbackWritePortByte(
    PortMapEntry* entry, uint16_t port, uint8_t value) {
  MDAWritePort((MDAState*)entry->context, port, value);
}

static uint8_t MDACallbackReadVRAMByte(
    MemoryMapEntry* entry, uint32_t address) {
  return MDAReadVRAM((MDAState*)entry->context, address);
}

static void MDACallbackWriteVRAMByte(
    MemoryMapEntry* entry, uint32_t address, uint8_t value) {
  MDAWriteVRAM((MDAState*)entry->context, address, value);
}

// ============================================================================
// Callbacks for BIOS module
// ============================================================================

static uint8_t BIOSCallbackReadROMByte(
    YAX86_UNUSED MemoryMapEntry* entry, uint32_t address) {
  return BIOSReadROMByte(address);
}

// ============================================================================
// Initialization
// ============================================================================

static void PlatformInitBIOS(PlatformState* platform) {
  uint32_t bios_size = BIOSGetROMSize();
  MemoryMapEntry bios_rom = {
      .context = NULL,
      .entry_type = kMemoryMapEntryBIOSROM,
      .start = kBIOSROMStartAddress,
      .end = kBIOSROMStartAddress + bios_size - 1,
      .read_byte = BIOSCallbackReadROMByte,
      .write_byte = NULL,  // BIOS ROM is read-only.
  };
  RegisterMemoryMapEntry(platform, &bios_rom);
}

static void PlatformInitCPU(PlatformState* platform) {
  platform->cpu_config = kEmptyCPUConfig;
  platform->cpu_config.context = platform;
  platform->cpu_config.read_memory_byte = CPUCallbackReadMemoryByte;
  platform->cpu_config.write_memory_byte = CPUCallbackWriteMemoryByte;
  platform->cpu_config.read_port = CPUCallbackReadPortByte;
  platform->cpu_config.write_port = CPUCallbackWritePortByte;
  CPUInit(&platform->cpu, &platform->cpu_config);

  // Initialize CPU registers.
  // CS:IP points to the BIOS entry point at 0xFFFF0.
  platform->cpu.registers[kCS] = 0xF000;
  platform->cpu.registers[kIP] = 0xFFF0;
  platform->cpu.registers[kDS] = 0x0000;
  platform->cpu.registers[kSS] = 0x0000;
  platform->cpu.registers[kES] = 0x0000;
  platform->cpu.registers[kSP] = 0xFFFE;
}

static void PlatformInitMemoryMap(PlatformState* platform) {
  MemoryMapInit(&platform->memory_map);
  MemoryMapEntry conventional_memory = {
      .context = platform,
      .entry_type = kMemoryMapEntryConventional,
      .start = 0x0000,
      .end = platform->config->physical_memory_size - 1,
      .read_byte = ReadPhysicalMemoryByte,
      .write_byte = WritePhysicalMemoryByte};
  MemoryMapAppend(&platform->memory_map, &conventional_memory);
}

static void PlatformInitPIC(PlatformState* platform) {
  platform->pic_config.sp = false;
  PICInit(&platform->pic, &platform->pic_config);
  PortMapEntry pic_entry = {
      .entry_type = kPortMapEntryPIC,
      .start = 0x20,
      .end = 0x21,
      .read_byte = PICCallbackReadPortByte,
      .write_byte = PICCallbackWritePortByte,
      .context = &platform->pic,
  };
  RegisterPortMapEntry(platform, &pic_entry);
}

static void PlatformInitPIT(PlatformState* platform) {
  platform->pit_config.context = platform;
  platform->pit_config.raise_irq_0 = PICCallbackPlatformRaiseIRQ0;
  platform->pit_config.set_pc_speaker_frequency =
      PITCallbackSetPCSpeakerFrequency;
  PITInit(&platform->pit, &platform->pit_config);
  PortMapEntry pit_entry = {
      .entry_type = kPortMapEntryPIT,
      .start = 0x40,
      .end = 0x43,
      .read_byte = PITCallbackReadPortByte,
      .write_byte = PITCallbackWritePortByte,
      .context = &platform->pit,
  };
  RegisterPortMapEntry(platform, &pit_entry);
}

static void PlatformInitPPI(PlatformState* platform) {
  platform->ppi_config.context = platform;
  platform->ppi_config.num_floppy_drives = 1;
  platform->ppi_config.memory_size = kPPIMemorySize256KB;
  platform->ppi_config.display_mode = kPPIDisplayMDA;
  platform->ppi_config.fpu_installed = false;
  platform->ppi_config.set_pc_speaker_frequency = NULL;  // TODO
  platform->ppi_config.set_keyboard_control = PPICallbackSetKeyboardControl;
  PPIInit(&platform->ppi, &platform->ppi_config);
  PortMapEntry ppi_entry = {
      .entry_type = kPortMapEntryPPI,
      .start = 0x60,
      .end = 0x63,
      .read_byte = PPICallbackReadPortByte,
      .write_byte = PPICallbackWritePortByte,
      .context = &platform->ppi,
  };
  RegisterPortMapEntry(platform, &ppi_entry);
}

static void PlatformInitKeyboard(PlatformState* platform) {
  platform->keyboard_config.context = platform;
  platform->keyboard_config.raise_irq1 = KeyboardCallbackPlatformRaiseIRQ1;
  platform->keyboard_config.send_scancode = KeyboardCallbackSendScancode;
  KeyboardInit(&platform->keyboard, &platform->keyboard_config);
}

static void PlatformInitFDC(PlatformState* platform) {
  platform->fdc_config.context = platform;
  platform->fdc_config.raise_irq6 = FDCCallbackRaiseIRQ6;
  platform->fdc_config.request_dma = FDCCallbackRequestDMA;
  platform->fdc_config.read_image_byte = NULL;
  platform->fdc_config.write_image_byte = NULL;
  FDCInit(&platform->fdc, &platform->fdc_config);
  PortMapEntry fdc_entry = {
      .entry_type = (PortMapEntryType)kPortMapEntryFDC,
      .start = 0x3F0,
      .end = 0x3F7,
      .read_byte = FDCCallbackReadPortByte,
      .write_byte = FDCCallbackWritePortByte,
      .context = &platform->fdc,
  };
  RegisterPortMapEntry(platform, &fdc_entry);
}

static void PlatformInitDMA(PlatformState* platform) {
  platform->dma_config.context = platform;
  platform->dma_config.read_memory_byte = DMACallbackReadMemoryByte;
  platform->dma_config.write_memory_byte = DMACallbackWriteMemoryByte;
  platform->dma_config.read_device_byte = DMACallbackReadDeviceByte;
  platform->dma_config.write_device_byte = DMACallbackWriteDeviceByte;
  platform->dma_config.on_terminal_count = DMACallbackOnTerminalCount;
  DMAInit(&platform->dma, &platform->dma_config);
  PortMapEntry dma_entry = {
      .entry_type = (PortMapEntryType)kPortMapEntryDMA,
      .start = 0x00,
      .end = 0x0F,
      .read_byte = DMACallbackReadPortByte,
      .write_byte = DMACallbackWritePortByte,
      .context = &platform->dma,
  };
  RegisterPortMapEntry(platform, &dma_entry);
  PortMapEntry dma_page_entry = {
      .entry_type = (PortMapEntryType)kPortMapEntryDMAPage,
      .start = 0x80,
      .end = 0x8F,
      .read_byte = DMACallbackReadPortByte,
      .write_byte = DMACallbackWritePortByte,
      .context = &platform->dma,
  };
  RegisterPortMapEntry(platform, &dma_page_entry);
}

static void PlatformInitMDA(PlatformState* platform) {
  platform->mda_config = kDefaultMDAConfig;
  platform->mda_config.context = platform;
  MDAInit(&platform->mda, &platform->mda_config);

  MemoryMapEntry vram_entry = {
      .context = &platform->mda,
      .entry_type = kMemoryMapEntryMDAVRAM,
      .start = kMDAModeMetadata.vram_address,
      .end = kMDAModeMetadata.vram_address + kMDAModeMetadata.vram_size - 1,
      .read_byte = MDACallbackReadVRAMByte,
      .write_byte = MDACallbackWriteVRAMByte,
  };
  RegisterMemoryMapEntry(platform, &vram_entry);

  PortMapEntry port_entry = {
      .context = &platform->mda,
      .entry_type = kPortMapEntryMDA,
      .start = 0x3B0,
      .end = 0x3BF,
      .read_byte = MDACallbackReadPortByte,
      .write_byte = MDACallbackWritePortByte,
  };
  RegisterPortMapEntry(platform, &port_entry);
}

// Initialize the platform state with the provided configuration. Returns true
// if the platform state was successfully initialized, or false if:
//   - The physical memory size is not between 64K and 640K.
bool PlatformInit(PlatformState* platform, PlatformConfig* config) {
  if (config->physical_memory_size < kMinPhysicalMemorySize ||
      config->physical_memory_size > kMaxPhysicalMemorySize) {
    return false;
  }

  platform->config = config;

  PlatformInitCPU(platform);
  PlatformInitMemoryMap(platform);
  PlatformInitBIOS(platform);
  PlatformInitPIC(platform);
  PlatformInitPIT(platform);
  PlatformInitPPI(platform);
  PlatformInitKeyboard(platform);
  PlatformInitFDC(platform);
  PlatformInitDMA(platform);
  PlatformInitMDA(platform);

  platform->ticks = 0;

  return true;
}

bool PlatformRaiseIRQ(PlatformState* platform, uint8_t irq) {
  if (irq >= 8) {
    return false;
  }
  PICRaiseIRQ(&platform->pic, irq);
  return true;
}

void PlatformTick(PlatformState* platform) {
  // Tick the CPU.
  CPUTick(&platform->cpu);

  // Check for pending interrupts from the PIC after an
  // instruction has been executed. This is how we connect the PIC to the CPU's
  // interrupt handling flow.
  if (CPUGetFlag(&platform->cpu, kIF)) {
    uint8_t interrupt_vector = PICGetPendingInterrupt(&platform->pic);
    if (interrupt_vector != kPICNoPendingInterrupt) {
      CPUSetPendingInterrupt(&platform->cpu, interrupt_vector);
    }
  }

  // PIT ticks at 1.19MHz, CPU at 4.77MHz. 4.77 / 1.19 ~= 4.
  if (platform->ticks % 4 == 0) {
    PITTick(&platform->pit);
  }

  // The main clock on the FDC is 8MHz. 8MHz / 4.77MHz ~= 2.
  if (platform->ticks % 2 == 0) {
    FDCTick(&platform->fdc);
  }

  // The keyboard ticks every 1ms.
  if (platform->ticks % 4770 == 0) {
    KeyboardTickMs(&platform->keyboard);
  }

  ++platform->ticks;
}



// ==============================================================================
// src/platform/platform.c end
// ==============================================================================


#endif  // YAX86_IMPLEMENTATION

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  // YAX86_PLATFORM_BUNDLE_H

// ==============================================================================
// YAX86 PPI MODULE - GENERATED SINGLE HEADER BUNDLE
// ==============================================================================

#ifndef YAX86_PPI_BUNDLE_H
#define YAX86_PPI_BUNDLE_H

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// ==============================================================================
// src/ppi/public.h start
// ==============================================================================

#line 1 "./src/ppi/public.h"
// Public interface for the PPI (Programmable Peripheral Interface) module.
#ifndef YAX86_PPI_PUBLIC_H
#define YAX86_PPI_PUBLIC_H

// This module emulates the Intel 8255 PPI chip as used in the IBM PC and
// PC/XT. Note that we don't implement all features of the 8255, only those
// needed to support GLaBIOS in ARCH_TYPE_EMU mode. Specifically:
//
// - Simplified PC speaker control
//     - Only on/off and frequency from PIT channel 2
//     - No real-time mirroring of PIT channel 2 on port C pin 5
// - No memory or I/O parity checking
// - No cassette support
//
// Reference tables from GLaBIOS source code:
//
// ----------------------------------------------------------------------------
//  5160/Standard: 8255 PPI Channel B (Port 61h) Flags
// ----------------------------------------------------------------------------
//  84218421
//  7 	    |	PBKB	0=enable keyboard read, 1=clear
//   6      |	PBKC	0=hold keyboard clock low, 1=enable clock
//    5     |	PBIO	0=enable i/o check, 1=disable
//     4    |	PBPC	0=enable memory parity check, 1=disable
//      3   |	PBSW	0=read SW1-4, 1=read SW-5-8
//       2  |	PBTB	0=turbo, 1=normal
//        1 |	PBSP	0=turn off speaker, 1=turn on
//         0|	PBST	0=turn off timer 2, 1=turn on
// ----------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------
//  5160: 8255 PPI Channel C (Port 62h) Flags When PPI B PBSW = 0
// ----------------------------------------------------------------------------
//  84218421
//  7 	    |	PCPE	0=no parity error, 1=memory parity error
//   6      |	PCIE	0=no i/o channel error, 1=i/o channel error
//    5     |	PCT2	timer 2 output / cassette data output
//     4    |	PCCI	cassette data input
//      32  |	PCMB	SW 3,4: MB RAM (00=64K, 01=128K, 10=192K, 11=256K)
//        1 |	PCFP	SW 2: 0=no FPU, 1=FPU installed
//         0|	PCFD	SW 1: Floppy drive (IPL) installed
// ----------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------
//  8255 PPI Channel C (Port 62h) Flags When PPI B PBSW = 1
// ----------------------------------------------------------------------------
//  84218421
//  7 	    |	PC2PE	0=no parity error, 1 r/w memory parity check error
//   6      |	PC2IE	0=no i/o channel error, 1 i/o channel check error
//    5     |	PC2T2	timer 2 output
//     4    |	PC2CI	cassette data input
//      32  |	PCDRV	SW 7,8: # of drives (00=1, 01=2, 10=3, 11=4)
//        10|	PCVID	SW 5,6: video Mode (00=ROM, 01=CG40, 10=CG80, 11=MDA)
// ----------------------------------------------------------------------------

#include <stdbool.h>
#include <stdint.h>

// I/O ports exposed by the PPI.
typedef enum PPIPort {
  // Keyboard scancode
  kPPIPortA = 0x60,
  // System control
  kPPIPortB = 0x61,
  // DIP switches
  kPPIPortC = 0x62,
  // Control word
  kPPIPortControl = 0x63,
} PPIPort;

// Bit definitions for PPI Port B (kPPIPortB).
enum {
  // Bit 0: Timer 2 signal gate (0 = disable, 1 = enable).
  kPPIPortBTimer2Gate = (1 << 0),
  // Bit 1: PC speaker enable/disable.
  kPPIPortBSpeakerData = (1 << 1),
  // Bit 2: Turbo mode (0 = turbo, 1 = normal). Not supported.
  kPPIPortBTurboMode = (1 << 2),
  // Bit 3: DIP switch select (0 = SW1-4, 1 = SW5-8).
  kPPIPortBDipSwitchSelect = (1 << 3),
  // Bit 4: Memory parity check enable/disable. Not supported.
  kPPIPortBMemoryParityCheck = (1 << 4),
  // Bit 5: I/O channel check enable/disable. Not supported.
  kPPIPortBIoChannelCheck = (1 << 5),
  // Bit 6: Keyboard clock control (0 = hold low, 1 = enable).
  kPPIPortBKeyboardClockLow = (1 << 6),
  // Bit 7: Keyboard enable/clear (0 = enable read, 1 = clear).
  kPPIPortBKeyboardEnableClear = (1 << 7),
};

// Memory sizes defined by DIP switches, corresponding to Port A bits 2-3.
// Note that GLaBIOS in ARCH_TYPE_EMU mode does not actually make use of these
// and instead performs its own memory detection based on the video card type.
typedef enum PPIMemorySize {
  // 00 = 64KB
  kPPIMemorySize64KB = 0,
  // 01 = 128KB
  kPPIMemorySize128KB = 1,
  // 10 = 192KB
  kPPIMemorySize192KB = 2,
  // 11 = 256KB
  kPPIMemorySize256KB = 3,
} PPIMemorySize;

// Display mode at boot time, corresponding to Port A bits 4-5.
typedef enum PPIDisplayMode {
  // 00 = EGA/VGA (ROM)
  kPPIDisplayEGA = 0,
  // 01 = CGA 40x25
  kPPIDisplayCGA40x25 = 1,
  // 10 = CGA 80x25
  kPPIDisplayCGA80x25 = 2,
  // 11 = MDA 80x25
  kPPIDisplayMDA = 3,
} PPIDisplayMode;

struct PPIState;

// Caller-provided runtime configuration for the PPI.
typedef struct PPIConfig {
  // Opaque context pointer, passed to all callbacks.
  void* context;

  // Number of floppy drives (1-4).
  uint8_t num_floppy_drives;

  // Memory size setting from DIP switches.
  PPIMemorySize memory_size;

  // Display mode setting from DIP switches.
  PPIDisplayMode display_mode;

  // Whether FPU is installed.
  bool fpu_installed;

  // Callback to control PC speaker.If frequency_hz is 0, the speaker should
  // be turned off. Otherwise, it should be set to the specified frequency.
  void (*set_pc_speaker_frequency)(void* context, uint32_t frequency_hz);

  // Callback when keyboard control bits are modified (bits 6 and 7 of Port B).
  void (*set_keyboard_control)(
      void* context,
      // Port B bit 7
      bool keyboard_enable_clear,
      // Port B bit 6
      bool keyboard_clock_low);
} PPIConfig;

// State of the PPI.
typedef struct PPIState {
  // Pointer to the PPI configuration.
  PPIConfig* config;

  // Port A: Keyboard scancode latch.
  uint8_t port_a_latch;

  // Port B: System control register.
  uint8_t port_b;

  // Current frequency of the PC speaker generated by the PIT, in Hz.
  uint32_t pc_speaker_frequency_from_pit;
} PPIState;

// Initializes the PPI to its power-on state.
void PPIInit(PPIState* ppi, PPIConfig* config);

// Handles reads from the PPI's I/O ports (0x60-0x62).
uint8_t PPIReadPort(PPIState* ppi, uint16_t port);

// Handles writes to the PPI's I/O ports (0x61, 0x63).
void PPIWritePort(PPIState* ppi, uint16_t port, uint8_t value);

// Returns whether the PC speaker is currently enabled. This is determined by
// bit 0 and 1 of Port B.
bool PPIIsPCSpeakerEnabled(PPIState* ppi);

// Sets the PC speaker frequency from the 8253 timer channel 2 output. This
// should be wired up to the callback from the PIT emulation module.
void PPISetPCSpeakerFrequencyFromPIT(PPIState* ppi, uint32_t frequency_hz);

// Sets the scancode byte that will be returned when the CPU reads from Port A.
// This function should be called by the keyboard emulation module.
void PPISetScancode(PPIState* ppi, uint8_t scancode);

#endif  // YAX86_PPI_PUBLIC_H


// ==============================================================================
// src/ppi/public.h end
// ==============================================================================


#ifdef YAX86_IMPLEMENTATION

// ==============================================================================
// src/ppi/ppi.c start
// ==============================================================================

#line 1 "./src/ppi/ppi.c"
#ifndef YAX86_IMPLEMENTATION
#include "public.h"
#endif  // YAX86_IMPLEMENTATION

void PPIInit(PPIState* ppi, PPIConfig* config) {
  static const PPIState zero_ppi_state = {0};
  *ppi = zero_ppi_state;
  ppi->config = config;
  // Initially, keyboard clock is enabled (bit 6 = 1) and keyboard read is 
  // enabled (bit 7 = 0).
  ppi->port_b = kPPIPortBKeyboardClockLow;
}

// Gets the number of floppy drives from the config, clamped to 1-4.
static inline uint8_t GetNumFloppyDrives(const PPIConfig* config) {
  if (config->num_floppy_drives < 1) return 1;
  if (config->num_floppy_drives > 4) return 4;
  return config->num_floppy_drives;
}

uint8_t PPIReadPort(PPIState* ppi, uint16_t port) {
  switch (port) {
    case kPPIPortA:
      // Reading Port A gets the keyboard scancode.
      return ppi->port_a_latch;
    case kPPIPortB:
      // Reading Port B returns its last written value.
      return ppi->port_b;
    case kPPIPortC:
      if ((ppi->port_b & kPPIPortBDipSwitchSelect) == 0) {
        // Read from SW1-4.
        uint8_t port_c = 0;
        // Bit 0: Floppy drive (IPL) installed
        port_c |= (ppi->config->num_floppy_drives > 0) & 0x01;
        // Bit 1: FPU installed
        port_c |= (ppi->config->fpu_installed << 1);
        // Bits 2-3: Memory size
        port_c |= ((ppi->config->memory_size & 0x03) << 2);
        // Bits 4-7 are for unsupported features (cassette, parity, etc.).
        return port_c;
      } else {
        // Read from SW5-8.
        uint8_t port_c = 0;
        // Bits 0-1: Video mode.
        port_c |= ppi->config->display_mode & 0x03;
        // Bits 2-3: Number of drives. Slightly confusingly, the encoding is
        // 1-based, i.e. 00=1 drive, 01=2 drives, etc.
        port_c |= (((GetNumFloppyDrives(ppi->config) - 1) & 0x03) << 2);
        // Bits 4-7 are for unsupported features.
        return port_c;
      }
    default:
      // Invalid port.
      return 0xFF;
  }
}

bool PPIIsPCSpeakerEnabled(PPIState* ppi) {
  return (ppi->port_b & kPPIPortBTimer2Gate) &&
         (ppi->port_b & kPPIPortBSpeakerData);
}

static inline uint8_t PPIGetKeyboardControl(const PPIState* ppi) {
  return (
      ppi->port_b & (kPPIPortBKeyboardEnableClear | kPPIPortBKeyboardClockLow));
}

void PPIWritePort(PPIState* ppi, uint16_t port, uint8_t value) {
  switch (port) {
    case kPPIPortB: {
      // Save old states in order to check for changes after the write.
      bool old_speaker_enabled = PPIIsPCSpeakerEnabled(ppi);
      uint8_t old_keyboard_control = PPIGetKeyboardControl(ppi);

      ppi->port_b = value;

      // Bit 7: Keyboard enable/clear (0 = enable read, 1 = clear).
      if (value & kPPIPortBKeyboardEnableClear) {
        ppi->port_a_latch = 0;
      }

      // Check for changes in PC speaker control bits and fire callback.
      bool speaker_enabled = PPIIsPCSpeakerEnabled(ppi);
      if (old_speaker_enabled != speaker_enabled && ppi->config &&
          ppi->config->set_pc_speaker_frequency) {
        const uint32_t frequency =
            PPIIsPCSpeakerEnabled(ppi) ? ppi->pc_speaker_frequency_from_pit : 0;
        ppi->config->set_pc_speaker_frequency(ppi->config->context, frequency);
      }

      // Check for changes in keyboard control bits and fire callback.
      uint8_t keyboard_control = PPIGetKeyboardControl(ppi);
      if (old_keyboard_control != keyboard_control && ppi->config &&
          ppi->config->set_keyboard_control) {
        ppi->config->set_keyboard_control(
            ppi->config->context,
            (ppi->port_b & kPPIPortBKeyboardEnableClear) != 0,
            (ppi->port_b & kPPIPortBKeyboardClockLow) != 0);
      }
      break;
    }
    case kPPIPortControl:
      // The BIOS always writes 0x99 (0b10011001) to set up the PPI. We can
      // ignore it since our emulation is hardcoded to behave accordingly.
      break;

    default:
      // Writes to Port A or C are ignored as they are inputs.
      break;
  }
}

void PPISetPCSpeakerFrequencyFromPIT(PPIState* ppi, uint32_t frequency_hz) {
  uint32_t old_frequency = ppi->pc_speaker_frequency_from_pit;
  ppi->pc_speaker_frequency_from_pit = frequency_hz;
  // Invoke the callback only if the speaker is currently enabled and the
  // frequency has changed.
  if (PPIIsPCSpeakerEnabled(ppi) && (frequency_hz != old_frequency) &&
      ppi->config && ppi->config->set_pc_speaker_frequency) {
    ppi->config->set_pc_speaker_frequency(ppi->config->context, frequency_hz);
  }
}

void PPISetScancode(PPIState* ppi, uint8_t scancode) {
  ppi->port_a_latch = scancode;
}


// ==============================================================================
// src/ppi/ppi.c end
// ==============================================================================


#endif  // YAX86_IMPLEMENTATION

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  // YAX86_PPI_BUNDLE_H

// ==============================================================================
// YAX86 VIDEO MODULE - GENERATED SINGLE HEADER BUNDLE
// ==============================================================================

#ifndef YAX86_VIDEO_BUNDLE_H
#define YAX86_VIDEO_BUNDLE_H

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// ==============================================================================
// src/video/public.h start
// ==============================================================================

#line 1 "./src/video/public.h"
// Public interface for the Video module.
#ifndef YAX86_VIDEO_PUBLIC_H
#define YAX86_VIDEO_PUBLIC_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifndef YAX86_VIDEO_BUNDLE_H
#include "../util/static_vector.h"
#endif  // YAX86_VIDEO_BUNDLE_H

// ============================================================================
// General
// ============================================================================

// RGB pixel value.
typedef struct RGB {
  // Red component (0-255).
  uint8_t r;
  // Green component (0-255).
  uint8_t g;
  // Blue component (0-255).
  uint8_t b;
} RGB;

// Position in 2D space.
typedef struct Position {
  // X coordinate.
  uint16_t x;
  // Y coordinate.
  uint16_t y;
} Position;

// Text mode character position. We use a different structure to avoid confusion
// with Position, which is used for pixel coordinates.
typedef struct TextPosition {
  // Column (0-based).
  uint8_t col;
  // Row (0-based).
  uint8_t row;
} TextPosition;

// Video modes.
typedef enum VideoMode {
  // MDA text mode 0x07: Text, 8025, monochrome, 720x350, 9x14
  kMDAText07 = 0x07,

  // Number of video modes supported.
  kNumVideoModes = 8,
} VideoMode;

// Text vs graphics modes.
typedef enum VideoModeType {
  // Invalid video mode. This is needed due to gap in the list of video mode
  // values.
  kVideoModeUnsupported = 0,
  // Text mode.
  kVideoModeText,
  // Graphics mode.
  kVideoModeGraphics,
} VideoModeType;

// Metadata for video modes.
typedef struct VideoModeMetadata {
  // The video mode.
  VideoMode mode;
  // Type of the video mode (text or graphics).
  VideoModeType type;
  // Mapped memory address of video RAM.
  uint32_t vram_address;
  // Video RAM size in bytes.
  uint32_t vram_size;
  // Resolution width in pixels.
  uint16_t width;
  // Resolution height in pixels.
  uint16_t height;
  // Number of pages in the video mode.
  uint8_t num_pages;

  // Text mode - number of columns.
  uint8_t columns;
  // Text mode - number of rows.
  uint8_t rows;
  // Text mode - character width in pixels.
  uint8_t char_width;
  // Text mode - character height in pixels.
  uint8_t char_height;
} VideoModeMetadata;

// ============================================================================
// Monochrome Display and Printer Adapter (MDA)
// ============================================================================

// MDA I/O ports
// ========================================
// I/O Register |
// Address      |  Function
// -------------|--------------------------
// 3B0          | Not Used
// 3B1          | Not Used
// 3B2          | Not Used
// 3B3          | Not Used
// 3B4          | 6845 Index Register
// 3B5          | 6845 Data Register
// 3B6          | Not Used
// 3B7          | Not Used
// 3B8          | CRT Control Port 1
// 3B9          | Reserved
// 3BA          | CRT Status Port
// 3BB          | Reserved
// 3BC          | Parallel Data Port
// 3BD          | Printer Status Port
// 3BE          | Printer Control Port
// 3BF          | Not Used
// ========================================

// CRT Control Port 1 (I/O port 3B8) - write only
// ========================================
// Bit Number | Function
//------------|-------------------------
// 0          | + High Resolution Mode
// 1          | Not Used
// 2          | Not Used
// 3          | + Video Enable
// 4          | Not Used
// 5          | + Enable Blink
// 6,7        | Not Used
// ========================================

// CRT Status Port (I/O port 3BA) - read only
// ========================================
// Bit Number | Function
//------------|-------------------------
// 0          | + Horizontal Drive
// 1          | Reserved
// 2          | Reserved
// 3          | + Black/White Video
// ========================================

// The MDA contains a Motorola 6845 CRT controller. I/O port 3B4 is used to
// select a register, and port I/O port 3B5 is used to read or write the data
// for that register. Below are the registers and their default values for the
// IBM Monochrome Display.
// =============================================================================
// Register | Register File              | Program Unit     | IBM Monochrome
// Number   |                            |                  | Display
// ---------|----------------------------|------------------|------------------
// R0       | Horizontal Total           | Characters       | 0x61
// R1       | Horizontal Displayed       | Characters       | 0x50
// R2       | Horizontal Sync Position   | Characters       | 0x52
// R3       | Horizontal Sync Width      | Characters       | 0x0F
// R4       | Vertical Total             | Character Rows   | 0x19
// R5       | Vertical Total Adjust      | Scan Line        | 0x06
// R6       | Vertical Displayed         | Character Row    | 0x19
// R7       | Vertical Sync Position     | Character Row    | 0x19
// R8       | Interlace Mode             | --------         | 0x02
// R9       | Maximum Scan Line          | Scan Line        | 0x0D
// R10      | Cursor Start               | Scan Line        | 0x0B
// R11      | Cursor End                 | Scan Line        | 0x0C
// R12      | Start Address (H)          | --------         | 0x00
// R13      | Start Address (L)          | --------         | 0x00
// R14      | Cursor (H)                 | --------         | 0x00
// R15      | Cursor (L)                 | --------         | 0x00
// R16      | Reserved                   | --------         | --
// R17      | Reserved                   | --------         | --
// =============================================================================

// MDA registers
enum {
  kMDARegisterHorizontalTotal = 0,
  kMDARegisterHorizontalDisplayed,
  kMDARegisterHorizontalSyncPosition,
  kMDARegisterHorizontalSyncWidth,
  kMDARegisterVerticalTotal,
  kMDARegisterVerticalTotalAdjust,
  kMDARegisterVerticalDisplayed,
  kMDARegisterVerticalSyncPosition,
  kMDARegisterInterlaceMode,
  kMDARegisterMaximumScanLine,
  kMDARegisterCursorStart,
  kMDARegisterCursorEnd,
  kMDARegisterStartAddressH,
  kMDARegisterStartAddressL,
  kMDARegisterCursorH,
  kMDARegisterCursorL,
  kMDARegisterReserved16,
  kMDARegisterReserved17,

  // Total number of MDA registers.
  kMDANumRegisters,
};

// MDA I/O ports.
enum {
  kMDAPortRegisterIndex = 0x3B4,
  kMDAPortRegisterData = 0x3B5,
  kMDAPortControl = 0x3B8,
  kMDAPortStatus = 0x3BA,
  kMDAPortPrinterData = 0x3BC,
  kMDAPortPrinterStatus = 0x3BD,
  kMDAPortPrinterControl = 0x3BE,
};

enum {
  // MDA memory map entry type.
  kMemoryMapEntryMDAVRAM = 0x10,
  // MDA VRAM size.
  kMDAVRAMSize = 4 * 1024,  // 4K

  // MDA port map entry type.
  kPortMapEntryMDA = 0x10,
};

// MDA text mode 0x07: Text, 8025, monochrome, 720x350, 9x14
static const VideoModeMetadata kMDAModeMetadata = {
    .mode = kMDAText07,
    .type = kVideoModeText,
    .vram_address = 0xB0000,
    .vram_size = kMDAVRAMSize,
    .width = 720,
    .height = 350,
    .num_pages = 1,
    .columns = 80,
    .rows = 25,
    .char_width = 9,
    .char_height = 14,
};

struct MDAState;

// Caller-provided configuration for MDA text mode rendering.
typedef struct MDAConfig {
  // Custom data passed through to callbacks.
  void* context;

  // Foreground color.
  RGB foreground;
  // Intense foreground color.
  RGB intense_foreground;
  // Background color.
  RGB background;

  // Callback to read a byte from the emulated video RAM.
  uint8_t (*read_vram_byte)(struct MDAState* mda, uint32_t address);
  // Callback to write a byte to the emulated video RAM.
  void (*write_vram_byte)(
      struct MDAState* mda, uint32_t address, uint8_t value);

  // Callback to write an RGB pixel value to the real display, invoked from
  // MDARender().
  void (*write_pixel)(struct MDAState* mda, Position position, RGB rgb);
} MDAConfig;

// Default MDA config.
static const MDAConfig kDefaultMDAConfig = {
    .context = NULL,

    .foreground = {.r = 0xAA, .g = 0xAA, .b = 0xAA},
    .intense_foreground = {.r = 0xFF, .g = 0xFF, .b = 0xFF},
    .background = {.r = 0x00, .g = 0x00, .b = 0x00},

    .read_vram_byte = NULL,
    .write_vram_byte = NULL,
    .write_pixel = NULL,
};

// MDA state.
typedef struct MDAState {
  // Caller-provided runtime configuration.
  MDAConfig* config;

  // Motorola 6845 CRT controller registers.
  uint8_t registers[kMDANumRegisters];
  // Currently selected 6845 CRT controller register index (I/O port 3B4).
  uint8_t selected_register;
  // Control port value (I/O port 3B8).
  uint8_t control_port;
  // Status port value (I/O port 3BA).
  uint8_t status_port;
} MDAState;

// Initialize MDA state with the provided configuration.
void MDAInit(MDAState* mda, MDAConfig* config);

// Read a byte from an MDA I/O port.
uint8_t MDAReadPort(MDAState* mda, uint16_t port);
// Write a byte to an MDA I/O port.
void MDAWritePort(MDAState* mda, uint16_t port, uint8_t value);

// Read a byte from MDA VRAM.
uint8_t MDAReadVRAM(MDAState* mda, uint32_t address);
// Write a byte to MDA VRAM.
void MDAWriteVRAM(MDAState* mda, uint32_t address, uint8_t value);

// Render the current display. Invokes the write_pixel callback to do the actual
// pixel rendering.
void MDARender(MDAState* mda);

#endif  // YAX86_VIDEO_PUBLIC_H


// ==============================================================================
// src/video/public.h end
// ==============================================================================


#ifdef YAX86_IMPLEMENTATION

// ==============================================================================
// src/util/common.h start
// ==============================================================================

#line 1 "./src/util/common.h"
#ifndef YAX86_UTIL_COMMON_H
#define YAX86_UTIL_COMMON_H

// Macro that expands to `static` when bundled. Use for variables and functions
// that need to be visible to other files within the same module, but not
// publicly to users of the bundled library.
//
// This enables better IDE integration as it allows each source file to be
// compiled independently in unbundled form, but still keeps the symbols private
// when bundled.
#ifdef YAX86_IMPLEMENTATION
// When bundled, static linkage so that the symbol is only visible within the
// implementation file.
#define YAX86_PRIVATE static
#else
// When unbundled, use default linkage.
#define YAX86_PRIVATE
#endif  // YAX86_IMPLEMENTATION

// Macro to mark a function or parameter as unused.
#if defined(__GNUC__) || defined(__clang__)
#define YAX86_UNUSED __attribute__((unused))
#else
#define YAX86_UNUSED
#endif  // defined(__GNUC__) || defined(__clang__)

#endif  // YAX86_UTIL_COMMON_H


// ==============================================================================
// src/util/common.h end
// ==============================================================================

// ==============================================================================
// src/video/fonts.h start
// ==============================================================================

#line 1 "./src/video/fonts.h"
#ifndef YAX86_VIDEO_FONTS_H
#define YAX86_VIDEO_FONTS_H

#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "public.h"

// MDA 9x14 font bitmaps.
extern const uint16_t kFontMDA9x14Bitmap[256][14];
// CGA 8x8 font bitmaps.
extern const uint8_t kFontCGA8x8Bitmap[256][8];

#endif  // YAX86_IMPLEMENTATION

#endif  // YAX86_VIDEO_FONTS_H


// ==============================================================================
// src/video/fonts.h end
// ==============================================================================

// ==============================================================================
// src/video/fonts.c start
// ==============================================================================

#line 1 "./src/video/fonts.c"
#ifndef YAX86_IMPLEMENTATION
#include "fonts.h"

#include "../util/common.h"
#endif  // YAX86_IMPLEMENTATION

// MDA 9x14 font bitmaps. Each character is actually 8x14, with the rightmost
// column left blank except for block characters.
//
// From pcface project:
// https://github.com/susam/pcface/blob/main/out/oldschool-mda-9x14/fontlist.js
YAX86_PRIVATE const uint16_t kFontMDA9x14Bitmap[256][14] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (0)
    {0x00, 0x00, 0xfc, 0x102, 0x14a, 0x102, 0x102, 0x17a, 0x132, 0x102, 0xfc,
     0x00, 0x00, 0x00},  // [] (1)
    {0x00, 0x00, 0xfc, 0x1fe, 0x1b6, 0x1fe, 0x1fe, 0x186, 0x1ce, 0x1fe, 0xfc,
     0x00, 0x00, 0x00},  // [] (2)
    {0x00, 0x00, 0x00, 0x6c, 0xfe, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
     0x00, 0x00},  // [] (3)
    {0x00, 0x00, 0x00, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00, 0x00,
     0x00, 0x00},  // [] (4)
    {0x00, 0x00, 0x30, 0x78, 0x78, 0x1ce, 0x1ce, 0x1ce, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [] (5)
    {0x00, 0x00, 0x30, 0x78, 0xfc, 0x1fe, 0x1fe, 0xfc, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [] (6)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x78, 0x78, 0x30, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (7)
    {0x1fe, 0x1fe, 0x1fe, 0x1fe, 0x1fe, 0x1ce, 0x186, 0x186, 0x1ce, 0x1fe,
     0x1fe, 0x1fe, 0x1fe, 0x1fe},  // [] (8)
    {0x00, 0x00, 0x00, 0x00, 0x78, 0xcc, 0x84, 0x84, 0xcc, 0x78, 0x00, 0x00,
     0x00, 0x00},  // [] (9)
    {0x1fe, 0x1fe, 0x1fe, 0x1fe, 0x186, 0x132, 0x17a, 0x17a, 0x132, 0x186,
     0x1fe, 0x1fe, 0x1fe, 0x1fe},  // [] (10)
    {0x00, 0x00, 0x1e, 0x0e, 0x1a, 0x32, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
     0x00, 0x00},  // [] (11)
    {0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0xfc, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [] (12)
    {0x00, 0x00, 0x7e, 0x66, 0x7e, 0x60, 0x60, 0x60, 0xe0, 0x1e0, 0x1c0, 0x00,
     0x00, 0x00},  // [] (13)
    {0x00, 0x00, 0xfe, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xce, 0x1ce, 0x1cc, 0x180,
     0x00, 0x00},  // [] (14)
    {0x00, 0x00, 0x30, 0x30, 0x1b6, 0x78, 0x1ce, 0x78, 0x1b6, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [] (15)
    {0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0xc0, 0x80, 0x00,
     0x00, 0x00},  // [] (16)
    {0x00, 0x00, 0x02, 0x06, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x06, 0x02, 0x00,
     0x00, 0x00},  // [] (17)
    {0x00, 0x00, 0x30, 0x78, 0xfc, 0x30, 0x30, 0x30, 0xfc, 0x78, 0x30, 0x00,
     0x00, 0x00},  // [] (18)
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x66, 0x00,
     0x00, 0x00},  // [] (19)
    {0x00, 0x00, 0xfe, 0x1b6, 0x1b6, 0x1b6, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x00,
     0x00, 0x00},  // [] (20)
    {0x00, 0x7c, 0xc6, 0x60, 0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x38, 0x0c, 0xc6,
     0x7c, 0x00},  // [] (21)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfe, 0x00,
     0x00, 0x00},  // [] (22)
    {0x00, 0x00, 0x30, 0x78, 0xfc, 0x30, 0x30, 0x30, 0xfc, 0x78, 0x30, 0xfc,
     0x00, 0x00},  // [] (23)
    {0x00, 0x00, 0x30, 0x78, 0xfc, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [] (24)
    {0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x78, 0x30, 0x00,
     0x00, 0x00},  // [] (25)
    {0x00, 0x00, 0x00, 0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (26)
    {0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (27)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (28)
    {0x00, 0x00, 0x00, 0x00, 0x48, 0xcc, 0x1fe, 0xcc, 0x48, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (29)
    {0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7c, 0x7c, 0xfe, 0xfe, 0x00, 0x00,
     0x00, 0x00},  // [] (30)
    {0x00, 0x00, 0x00, 0xfe, 0xfe, 0x7c, 0x7c, 0x38, 0x38, 0x10, 0x00, 0x00,
     0x00, 0x00},  // [] (31)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [ ] (32)
    {0x00, 0x00, 0x30, 0x78, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [!] (33)
    {0x00, 0xc6, 0xc6, 0xc6, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // ["] (34)
    {0x00, 0x00, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
     0x00, 0x00},  // [#] (35)
    {0x18, 0x18, 0x7c, 0xc6, 0xc2, 0xc0, 0x7c, 0x06, 0x86, 0xc6, 0x7c, 0x18,
     0x18, 0x00},  // [$] (36)
    {0x00, 0x00, 0x00, 0x00, 0xc2, 0xc6, 0x0c, 0x18, 0x30, 0x66, 0xc6, 0x00,
     0x00, 0x00},  // [%] (37)
    {0x00, 0x00, 0x38, 0x6c, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [&] (38)
    {0x00, 0x60, 0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // ['] (39)
    {0x00, 0x00, 0x18, 0x30, 0x60, 0x60, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
     0x00, 0x00},  // [(] (40)
    {0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00,
     0x00, 0x00},  // [)] (41)
    {0x00, 0x00, 0x00, 0x00, 0xcc, 0x78, 0x1fe, 0x78, 0xcc, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [*] (42)
    {0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x1fe, 0x30, 0x30, 0x30, 0x00, 0x00,
     0x00, 0x00},  // [+] (43)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x60,
     0x00, 0x00},  // [,] (44)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1fe, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [-] (45)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [.] (46)
    {0x00, 0x00, 0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00, 0x00,
     0x00, 0x00},  // [/] (47)
    {0x00, 0x00, 0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [0] (48)
    {0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00,
     0x00, 0x00},  // [1] (49)
    {0x00, 0x00, 0x7c, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00,
     0x00, 0x00},  // [2] (50)
    {0x00, 0x00, 0x7c, 0xc6, 0x06, 0x06, 0x3c, 0x06, 0x06, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [3] (51)
    {0x00, 0x00, 0x0c, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x0c, 0x1e, 0x00,
     0x00, 0x00},  // [4] (52)
    {0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0, 0xfc, 0x06, 0x06, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [5] (53)
    {0x00, 0x00, 0x38, 0x60, 0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [6] (54)
    {0x00, 0x00, 0xfe, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [7] (55)
    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [8] (56)
    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x06, 0x0c, 0x78, 0x00,
     0x00, 0x00},  // [9] (57)
    {0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00,
     0x00, 0x00},  // [:] (58)
    {0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60, 0x00,
     0x00, 0x00},  // [;] (59)
    {0x00, 0x00, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x00,
     0x00, 0x00},  // [<] (60)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [=] (61)
    {0x00, 0x00, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x00,
     0x00, 0x00},  // [>] (62)
    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x0c, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00,
     0x00, 0x00},  // [?] (63)
    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xde, 0xde, 0xde, 0xdc, 0xc0, 0x7c, 0x00,
     0x00, 0x00},  // [@] (64)
    {0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [A] (65)
    {0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x66, 0xfc, 0x00,
     0x00, 0x00},  // [B] (66)
    {0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xc0, 0xc2, 0x66, 0x3c, 0x00,
     0x00, 0x00},  // [C] (67)
    {0x00, 0x00, 0xf8, 0x6c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
     0x00, 0x00},  // [D] (68)
    {0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66, 0xfe, 0x00,
     0x00, 0x00},  // [E] (69)
    {0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0xf0, 0x00,
     0x00, 0x00},  // [F] (70)
    {0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xde, 0xc6, 0x66, 0x3a, 0x00,
     0x00, 0x00},  // [G] (71)
    {0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [H] (72)
    {0x00, 0x00, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [I] (73)
    {0x00, 0x00, 0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
     0x00, 0x00},  // [J] (74)
    {0x00, 0x00, 0xe6, 0x66, 0x6c, 0x6c, 0x78, 0x6c, 0x6c, 0x66, 0xe6, 0x00,
     0x00, 0x00},  // [K] (75)
    {0x00, 0x00, 0xf0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
     0x00, 0x00},  // [L] (76)
    {0x00, 0x00, 0x186, 0x1ce, 0x1fe, 0x1b6, 0x186, 0x186, 0x186, 0x186, 0x186,
     0x00, 0x00, 0x00},  // [M] (77)
    {0x00, 0x00, 0xc6, 0xe6, 0xf6, 0xfe, 0xde, 0xce, 0xc6, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [N] (78)
    {0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
     0x00, 0x00},  // [O] (79)
    {0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0xf0, 0x00,
     0x00, 0x00},  // [P] (80)
    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xde, 0x7c, 0x0c, 0x0e,
     0x00, 0x00},  // [Q] (81)
    {0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x66, 0xe6, 0x00,
     0x00, 0x00},  // [R] (82)
    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x60, 0x38, 0x0c, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [S] (83)
    {0x00, 0x00, 0x1fe, 0x1b6, 0x132, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [T] (84)
    {0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [U] (85)
    {0x00, 0x00, 0x186, 0x186, 0x186, 0x186, 0x186, 0x186, 0xcc, 0x78, 0x30,
     0x00, 0x00, 0x00},  // [V] (86)
    {0x00, 0x00, 0x186, 0x186, 0x186, 0x186, 0x1b6, 0x1b6, 0x1fe, 0xcc, 0xcc,
     0x00, 0x00, 0x00},  // [W] (87)
    {0x00, 0x00, 0x186, 0x186, 0xcc, 0x78, 0x30, 0x78, 0xcc, 0x186, 0x186, 0x00,
     0x00, 0x00},  // [X] (88)
    {0x00, 0x00, 0x186, 0x186, 0x186, 0xcc, 0x78, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [Y] (89)
    {0x00, 0x00, 0x1fe, 0x186, 0x10c, 0x18, 0x30, 0x60, 0xc2, 0x186, 0x1fe,
     0x00, 0x00, 0x00},  // [Z] (90)
    {0x00, 0x00, 0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
     0x00, 0x00},  // [[] (91)
    {0x00, 0x00, 0x80, 0xc0, 0xe0, 0x70, 0x38, 0x1c, 0x0e, 0x06, 0x02, 0x00,
     0x00, 0x00},  // [\] (92)
    {0x00, 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
     0x00, 0x00},  // []] (93)
    {0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [^] (94)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x1fe, 0x00},  // [_] (95)
    {0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [`] (96)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [a] (97)
    {0x00, 0x00, 0xe0, 0x60, 0x60, 0x78, 0x6c, 0x66, 0x66, 0x66, 0xdc, 0x00,
     0x00, 0x00},  // [b] (98)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [c] (99)
    {0x00, 0x00, 0x1c, 0x0c, 0x0c, 0x3c, 0x6c, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [d] (100)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [e] (101)
    {0x00, 0x00, 0x38, 0x6c, 0x64, 0x60, 0xf8, 0x60, 0x60, 0x60, 0xf0, 0x00,
     0x00, 0x00},  // [f] (102)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xcc,
     0x78, 0x00},  // [g] (103)
    {0x00, 0x00, 0xe0, 0x60, 0x60, 0x6c, 0x76, 0x66, 0x66, 0x66, 0xe6, 0x00,
     0x00, 0x00},  // [h] (104)
    {0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
     0x00, 0x00},  // [i] (105)
    {0x00, 0x00, 0x0c, 0x0c, 0x00, 0x1c, 0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc,
     0x78, 0x00},  // [j] (106)
    {0x00, 0x00, 0xe0, 0x60, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
     0x00, 0x00},  // [k] (107)
    {0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
     0x00, 0x00},  // [l] (108)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x1cc, 0x1fe, 0x1b6, 0x1b6, 0x1b6, 0x1b6,
     0x00, 0x00, 0x00},  // [m] (109)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00,
     0x00, 0x00},  // [n] (110)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [o] (111)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60,
     0xf0, 0x00},  // [p] (112)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0x0c,
     0x1e, 0x00},  // [q] (113)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0x60, 0xf0, 0x00,
     0x00, 0x00},  // [r] (114)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x70, 0x1c, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [s] (115)
    {0x00, 0x00, 0x10, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x36, 0x1c, 0x00,
     0x00, 0x00},  // [t] (116)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [u] (117)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x186, 0x186, 0x186, 0xcc, 0x78, 0x30, 0x00,
     0x00, 0x00},  // [v] (118)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x186, 0x186, 0x1b6, 0x1b6, 0x1fe, 0xcc,
     0x00, 0x00, 0x00},  // [w] (119)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
     0x00, 0x00},  // [x] (120)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c,
     0x78, 0x00},  // [y] (121)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xcc, 0x18, 0x30, 0x66, 0xfe, 0x00,
     0x00, 0x00},  // [z] (122)
    {0x00, 0x00, 0x1c, 0x30, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x30, 0x1c, 0x00,
     0x00, 0x00},  // [{] (123)
    {0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x00, 0x30, 0x30, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [|] (124)
    {0x00, 0x00, 0xe0, 0x30, 0x30, 0x30, 0x1c, 0x30, 0x30, 0x30, 0xe0, 0x00,
     0x00, 0x00},  // [}] (125)
    {0x00, 0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [~] (126)
    {0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00, 0x00,
     0x00, 0x00},  // [] (127)
    {0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xc2, 0x66, 0x3c, 0x0c, 0x06,
     0x7c, 0x00},  // [] (128)
    {0x00, 0x00, 0xcc, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [] (129)
    {0x00, 0x0c, 0x18, 0x30, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [] (130)
    {0x00, 0x10, 0x38, 0x6c, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [] (131)
    {0x00, 0x00, 0xcc, 0xcc, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [] (132)
    {0x00, 0x60, 0x30, 0x18, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [] (133)
    {0x00, 0x38, 0x6c, 0x38, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [] (134)
    {0x00, 0x00, 0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x18, 0x0c, 0x78,
     0x00, 0x00},  // [] (135)
    {0x00, 0x10, 0x38, 0x6c, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [] (136)
    {0x00, 0x00, 0xcc, 0xcc, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [] (137)
    {0x00, 0x60, 0x30, 0x18, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [] (138)
    {0x00, 0x00, 0xcc, 0xcc, 0x00, 0x70, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [] (139)
    {0x00, 0x30, 0x78, 0xcc, 0x00, 0x70, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [] (140)
    {0x00, 0xc0, 0x60, 0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [] (141)
    {0x00, 0xc6, 0xc6, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [] (142)
    {0x38, 0x6c, 0x38, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [] (143)
    {0x18, 0x30, 0x60, 0x00, 0xfe, 0x66, 0x60, 0x7c, 0x60, 0x66, 0xfe, 0x00,
     0x00, 0x00},  // [] (144)
    {0x00, 0x00, 0x00, 0x00, 0xdc, 0x76, 0x36, 0xfc, 0x1b0, 0x1b8, 0xee, 0x00,
     0x00, 0x00},  // [] (145)
    {0x00, 0x00, 0x3e, 0x6c, 0xcc, 0xcc, 0xfe, 0xcc, 0xcc, 0xcc, 0xce, 0x00,
     0x00, 0x00},  // [] (146)
    {0x00, 0x10, 0x38, 0x6c, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [] (147)
    {0x00, 0x00, 0xc6, 0xc6, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [] (148)
    {0x00, 0x60, 0x30, 0x18, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [] (149)
    {0x00, 0x30, 0x78, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [] (150)
    {0x00, 0x60, 0x30, 0x18, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [] (151)
    {0x00, 0x00, 0xc6, 0xc6, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c,
     0x78, 0x00},  // [] (152)
    {0x00, 0xc6, 0xc6, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
     0x00, 0x00},  // [] (153)
    {0x00, 0xc6, 0xc6, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [] (154)
    {0x00, 0x30, 0x30, 0xfc, 0x186, 0x180, 0x180, 0x186, 0xfc, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [] (155)
    {0x00, 0x38, 0x6c, 0x64, 0x60, 0xf0, 0x60, 0x60, 0x60, 0xe6, 0xfc, 0x00,
     0x00, 0x00},  // [] (156)
    {0x00, 0x00, 0x186, 0xcc, 0x78, 0x30, 0x1fe, 0x30, 0x1fe, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [] (157)
    {0x00, 0x1f8, 0xcc, 0xcc, 0xf8, 0xc4, 0xcc, 0xde, 0xcc, 0xcc, 0x1e6, 0x00,
     0x00, 0x00},  // [] (158)
    {0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x30, 0x1b0,
     0xe0, 0x00},  // [] (159)
    {0x00, 0x18, 0x30, 0x60, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [] (160)
    {0x00, 0x18, 0x30, 0x60, 0x00, 0x70, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [] (161)
    {0x00, 0x18, 0x30, 0x60, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [] (162)
    {0x00, 0x18, 0x30, 0x60, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [] (163)
    {0x00, 0x00, 0x76, 0xdc, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00,
     0x00, 0x00},  // [] (164)
    {0x76, 0xdc, 0x00, 0xc6, 0xe6, 0xf6, 0xfe, 0xde, 0xce, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [] (165)
    {0x00, 0x78, 0xd8, 0xd8, 0x7c, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (166)
    {0x00, 0x70, 0xd8, 0xd8, 0x70, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (167)
    {0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [] (168)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0, 0x00, 0x00,
     0x00, 0x00},  // [] (169)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x06, 0x06, 0x06, 0x00, 0x00,
     0x00, 0x00},  // [] (170)
    {0x00, 0xc0, 0x1c0, 0xc6, 0xcc, 0xd8, 0x30, 0x60, 0xdc, 0x186, 0x0c, 0x18,
     0x3e, 0x00},  // [] (171)
    {0x00, 0xc0, 0x1c0, 0xc6, 0xcc, 0xd8, 0x30, 0x66, 0xce, 0x19e, 0x3e, 0x06,
     0x06, 0x00},  // [] (172)
    {0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x78, 0x78, 0x78, 0x30, 0x00,
     0x00, 0x00},  // [] (173)
    {0x00, 0x00, 0x00, 0x00, 0x36, 0x6c, 0xd8, 0x6c, 0x36, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (174)
    {0x00, 0x00, 0x00, 0x00, 0xd8, 0x6c, 0x36, 0x6c, 0xd8, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (175)
    {0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88,
     0x22, 0x88},  // [] (176)
    {0xaa, 0x154, 0xaa, 0x154, 0xaa, 0x154, 0xaa, 0x154, 0xaa, 0x154, 0xaa,
     0x154, 0xaa, 0x154},  // [] (177)
    {0x1ba, 0xee, 0x1ba, 0xee, 0x1ba, 0xee, 0x1ba, 0xee, 0x1ba, 0xee, 0x1ba,
     0xee, 0x1ba, 0xee},  // [] (178)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (179)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1f0, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (180)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x1f0, 0x30, 0x1f0, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (181)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ec, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [] (182)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1fc, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [] (183)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x1f0, 0x30, 0x1f0, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (184)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ec, 0x0c, 0x1ec, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [] (185)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [] (186)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x1fc, 0x0c, 0x1ec, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [] (187)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ec, 0x0c, 0x1fc, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (188)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1fc, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (189)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x1f0, 0x30, 0x1f0, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (190)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f0, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (191)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3f, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (192)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (193)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (194)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3f, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (195)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (196)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1ff, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (197)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x3f, 0x30, 0x3f, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (198)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6f, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [] (199)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6f, 0x60, 0x7f, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (200)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x60, 0x6f, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [] (201)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ef, 0x00, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (202)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x00, 0x1ef, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [] (203)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6f, 0x60, 0x6f, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [] (204)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x00, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (205)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ef, 0x00, 0x1ef, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [] (206)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x1ff, 0x00, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (207)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (208)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x00, 0x1ff, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (209)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [] (210)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x7f, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (211)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x3f, 0x30, 0x3f, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (212)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x30, 0x3f, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (213)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [] (214)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ff, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [] (215)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x1ff, 0x30, 0x1ff, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (216)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1f0, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (217)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (218)
    {0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff,
     0x1ff, 0x1ff, 0x1ff, 0x1ff},  // [] (219)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x1ff, 0x1ff, 0x1ff,
     0x1ff, 0x1ff, 0x1ff},  // [] (220)
    {0x1e0, 0x1e0, 0x1e0, 0x1e0, 0x1e0, 0x1e0, 0x1e0, 0x1e0, 0x1e0, 0x1e0,
     0x1e0, 0x1e0, 0x1e0, 0x1e0},  // [] (221)
    {0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
     0x1f, 0x1f},  // [] (222)
    {0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00},  // [] (223)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0xd8, 0xd8, 0xdc, 0x76, 0x00,
     0x00, 0x00},  // [] (224)
    {0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xfc, 0xc6, 0xc6, 0xfc, 0xc0, 0xc0,
     0x40, 0x00},  // [] (225)
    {0x00, 0x00, 0xfe, 0xc6, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x00,
     0x00, 0x00},  // [] (226)
    {0x00, 0x00, 0x00, 0x00, 0xfe, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00,
     0x00, 0x00},  // [] (227)
    {0x00, 0x00, 0xfe, 0xc6, 0x60, 0x30, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00,
     0x00, 0x00},  // [] (228)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xd8, 0xd8, 0xd8, 0xd8, 0x70, 0x00,
     0x00, 0x00},  // [] (229)
    {0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xc0,
     0x00, 0x00},  // [] (230)
    {0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
     0x00, 0x00},  // [] (231)
    {0x00, 0x00, 0xfc, 0x30, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0xfc, 0x00,
     0x00, 0x00},  // [] (232)
    {0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
     0x00, 0x00},  // [] (233)
    {0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x6c, 0x6c, 0xee, 0x00,
     0x00, 0x00},  // [] (234)
    {0x00, 0x00, 0x3c, 0x60, 0x30, 0x18, 0x7c, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
     0x00, 0x00},  // [] (235)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1b6, 0x1b6, 0xfc, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (236)
    {0x00, 0x00, 0x06, 0x0c, 0xfc, 0x1b6, 0x1b6, 0x1e6, 0xfc, 0xc0, 0x180, 0x00,
     0x00, 0x00},  // [] (237)
    {0x00, 0x00, 0x38, 0x60, 0xc0, 0xc0, 0xf8, 0xc0, 0xc0, 0x60, 0x38, 0x00,
     0x00, 0x00},  // [] (238)
    {0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [] (239)
    {0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00,
     0x00, 0x00},  // [] (240)
    {0x00, 0x00, 0x30, 0x30, 0x30, 0x1fe, 0x30, 0x30, 0x30, 0x00, 0x1fe, 0x00,
     0x00, 0x00},  // [] (241)
    {0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00, 0xfc, 0x00,
     0x00, 0x00},  // [] (242)
    {0x00, 0x00, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00, 0xfc, 0x00,
     0x00, 0x00},  // [] (243)
    {0x00, 0x00, 0x1c, 0x36, 0x36, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [] (244)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1b0, 0x1b0, 0xe0, 0x00,
     0x00, 0x00},  // [] (245)
    {0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x1fe, 0x00, 0x00, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [] (246)
    {0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0x00, 0x76, 0xdc, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (247)
    {0x00, 0x70, 0xd8, 0xd8, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (248)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (249)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (250)
    {0x00, 0x1e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1d8, 0xd8, 0x78, 0x38, 0x00,
     0x00, 0x00},  // [] (251)
    {0x00, 0x1b0, 0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (252)
    {0x00, 0xe0, 0x1b0, 0x60, 0xc0, 0x190, 0x1f0, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (253)
    {0x00, 0x00, 0x00, 0x00, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x00, 0x00,
     0x00, 0x00},  // [] (254)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (255)
};

// CGA 8x8 font bitmaps.
//
// From pcface project:
// https://github.com/susam/pcface/blob/main/out/oldschool-cga-8x8/fontlist.js
YAX86_PRIVATE const uint8_t kFontCGA8x8Bitmap[256][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // [] (0)
    {0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e},  // [] (1)
    {0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e},  // [] (2)
    {0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00},  // [] (3)
    {0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00},  // [] (4)
    {0x38, 0x7c, 0x38, 0xfe, 0xfe, 0xd6, 0x10, 0x38},  // [] (5)
    {0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x10, 0x38},  // [] (6)
    {0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00},  // [] (7)
    {0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff},  // [] (8)
    {0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00},  // [] (9)
    {0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff},  // [] (10)
    {0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78},  // [] (11)
    {0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18},  // [] (12)
    {0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0},  // [] (13)
    {0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0},  // [] (14)
    {0x18, 0xdb, 0x3c, 0xe7, 0xe7, 0x3c, 0xdb, 0x18},  // [] (15)
    {0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00},  // [] (16)
    {0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00},  // [] (17)
    {0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18},  // [] (18)
    {0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00},  // [] (19)
    {0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00},  // [] (20)
    {0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78},  // [] (21)
    {0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00},  // [] (22)
    {0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff},  // [] (23)
    {0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00},  // [] (24)
    {0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00},  // [] (25)
    {0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00},  // [] (26)
    {0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00},  // [] (27)
    {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00},  // [] (28)
    {0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00},  // [] (29)
    {0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00},  // [] (30)
    {0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00},  // [] (31)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // [ ] (32)
    {0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00},  // [!] (33)
    {0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00},  // ["] (34)
    {0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00},  // [#] (35)
    {0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00},  // [$] (36)
    {0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00},  // [%] (37)
    {0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00},  // [&] (38)
    {0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00},  // ['] (39)
    {0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00},  // [(] (40)
    {0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00},  // [)] (41)
    {0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00},  // [*] (42)
    {0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00},  // [+] (43)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60},  // [,] (44)
    {0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00},  // [-] (45)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00},  // [.] (46)
    {0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00},  // [/] (47)
    {0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00},  // [0] (48)
    {0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00},  // [1] (49)
    {0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00},  // [2] (50)
    {0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00},  // [3] (51)
    {0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00},  // [4] (52)
    {0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00},  // [5] (53)
    {0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00},  // [6] (54)
    {0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00},  // [7] (55)
    {0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00},  // [8] (56)
    {0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00},  // [9] (57)
    {0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00},  // [:] (58)
    {0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60},  // [;] (59)
    {0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00},  // [<] (60)
    {0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00},  // [=] (61)
    {0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00},  // [>] (62)
    {0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00},  // [?] (63)
    {0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00},  // [@] (64)
    {0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00},  // [A] (65)
    {0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00},  // [B] (66)
    {0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00},  // [C] (67)
    {0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00},  // [D] (68)
    {0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00},  // [E] (69)
    {0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00},  // [F] (70)
    {0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00},  // [G] (71)
    {0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00},  // [H] (72)
    {0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},  // [I] (73)
    {0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00},  // [J] (74)
    {0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00},  // [K] (75)
    {0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00},  // [L] (76)
    {0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00},  // [M] (77)
    {0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00},  // [N] (78)
    {0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00},  // [O] (79)
    {0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00},  // [P] (80)
    {0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00},  // [Q] (81)
    {0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00},  // [R] (82)
    {0x78, 0xcc, 0x60, 0x30, 0x18, 0xcc, 0x78, 0x00},  // [S] (83)
    {0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},  // [T] (84)
    {0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00},  // [U] (85)
    {0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00},  // [V] (86)
    {0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00},  // [W] (87)
    {0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00},  // [X] (88)
    {0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00},  // [Y] (89)
    {0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00},  // [Z] (90)
    {0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00},  // [[] (91)
    {0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00},  // [\] (92)
    {0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00},  // []] (93)
    {0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00},  // [^] (94)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff},  // [_] (95)
    {0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},  // [`] (96)
    {0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00},  // [a] (97)
    {0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00},  // [b] (98)
    {0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00},  // [c] (99)
    {0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00},  // [d] (100)
    {0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},  // [e] (101)
    {0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00},  // [f] (102)
    {0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},  // [g] (103)
    {0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00},  // [h] (104)
    {0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},  // [i] (105)
    {0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78},  // [j] (106)
    {0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00},  // [k] (107)
    {0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},  // [l] (108)
    {0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00},  // [m] (109)
    {0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00},  // [n] (110)
    {0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00},  // [o] (111)
    {0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0},  // [p] (112)
    {0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e},  // [q] (113)
    {0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00},  // [r] (114)
    {0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00},  // [s] (115)
    {0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00},  // [t] (116)
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00},  // [u] (117)
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00},  // [v] (118)
    {0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00},  // [w] (119)
    {0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00},  // [x] (120)
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},  // [y] (121)
    {0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00},  // [z] (122)
    {0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00},  // [{] (123)
    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},  // [|] (124)
    {0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00},  // [}] (125)
    {0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // [~] (126)
    {0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00},  // [] (127)
    {0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x18, 0x0c, 0x78},  // [] (128)
    {0x00, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},  // [] (129)
    {0x1c, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},  // [] (130)
    {0x7e, 0xc3, 0x3c, 0x06, 0x3e, 0x66, 0x3f, 0x00},  // [] (131)
    {0xcc, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},  // [] (132)
    {0xe0, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},  // [] (133)
    {0x30, 0x30, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},  // [] (134)
    {0x00, 0x00, 0x78, 0xc0, 0xc0, 0x78, 0x0c, 0x38},  // [] (135)
    {0x7e, 0xc3, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00},  // [] (136)
    {0xcc, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},  // [] (137)
    {0xe0, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},  // [] (138)
    {0xcc, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},  // [] (139)
    {0x7c, 0xc6, 0x38, 0x18, 0x18, 0x18, 0x3c, 0x00},  // [] (140)
    {0xe0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},  // [] (141)
    {0xc6, 0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0xc6, 0x00},  // [] (142)
    {0x30, 0x30, 0x00, 0x78, 0xcc, 0xfc, 0xcc, 0x00},  // [] (143)
    {0x1c, 0x00, 0xfc, 0x60, 0x78, 0x60, 0xfc, 0x00},  // [] (144)
    {0x00, 0x00, 0x7f, 0x0c, 0x7f, 0xcc, 0x7f, 0x00},  // [] (145)
    {0x3e, 0x6c, 0xcc, 0xfe, 0xcc, 0xcc, 0xce, 0x00},  // [] (146)
    {0x78, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},  // [] (147)
    {0x00, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},  // [] (148)
    {0x00, 0xe0, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},  // [] (149)
    {0x78, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},  // [] (150)
    {0x00, 0xe0, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},  // [] (151)
    {0x00, 0xcc, 0x00, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},  // [] (152)
    {0xc3, 0x18, 0x3c, 0x66, 0x66, 0x3c, 0x18, 0x00},  // [] (153)
    {0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x00},  // [] (154)
    {0x18, 0x18, 0x7e, 0xc0, 0xc0, 0x7e, 0x18, 0x18},  // [] (155)
    {0x38, 0x6c, 0x64, 0xf0, 0x60, 0xe6, 0xfc, 0x00},  // [] (156)
    {0xcc, 0xcc, 0x78, 0xfc, 0x30, 0xfc, 0x30, 0x30},  // [] (157)
    {0xf8, 0xcc, 0xcc, 0xfa, 0xc6, 0xcf, 0xc6, 0xc7},  // [] (158)
    {0x0e, 0x1b, 0x18, 0x3c, 0x18, 0x18, 0xd8, 0x70},  // [] (159)
    {0x1c, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},  // [] (160)
    {0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},  // [] (161)
    {0x00, 0x1c, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},  // [] (162)
    {0x00, 0x1c, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},  // [] (163)
    {0x00, 0xf8, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0x00},  // [] (164)
    {0xfc, 0x00, 0xcc, 0xec, 0xfc, 0xdc, 0xcc, 0x00},  // [] (165)
    {0x3c, 0x6c, 0x6c, 0x3e, 0x00, 0x7e, 0x00, 0x00},  // [] (166)
    {0x38, 0x6c, 0x6c, 0x38, 0x00, 0x7c, 0x00, 0x00},  // [] (167)
    {0x30, 0x00, 0x30, 0x60, 0xc0, 0xcc, 0x78, 0x00},  // [] (168)
    {0x00, 0x00, 0x00, 0xfc, 0xc0, 0xc0, 0x00, 0x00},  // [] (169)
    {0x00, 0x00, 0x00, 0xfc, 0x0c, 0x0c, 0x00, 0x00},  // [] (170)
    {0xc3, 0xc6, 0xcc, 0xde, 0x33, 0x66, 0xcc, 0x0f},  // [] (171)
    {0xc3, 0xc6, 0xcc, 0xdb, 0x37, 0x6f, 0xcf, 0x03},  // [] (172)
    {0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00},  // [] (173)
    {0x00, 0x33, 0x66, 0xcc, 0x66, 0x33, 0x00, 0x00},  // [] (174)
    {0x00, 0xcc, 0x66, 0x33, 0x66, 0xcc, 0x00, 0x00},  // [] (175)
    {0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88},  // [] (176)
    {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa},  // [] (177)
    {0xdb, 0x77, 0xdb, 0xee, 0xdb, 0x77, 0xdb, 0xee},  // [] (178)
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},  // [] (179)
    {0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18},  // [] (180)
    {0x18, 0x18, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18},  // [] (181)
    {0x36, 0x36, 0x36, 0x36, 0xf6, 0x36, 0x36, 0x36},  // [] (182)
    {0x00, 0x00, 0x00, 0x00, 0xfe, 0x36, 0x36, 0x36},  // [] (183)
    {0x00, 0x00, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18},  // [] (184)
    {0x36, 0x36, 0xf6, 0x06, 0xf6, 0x36, 0x36, 0x36},  // [] (185)
    {0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36},  // [] (186)
    {0x00, 0x00, 0xfe, 0x06, 0xf6, 0x36, 0x36, 0x36},  // [] (187)
    {0x36, 0x36, 0xf6, 0x06, 0xfe, 0x00, 0x00, 0x00},  // [] (188)
    {0x36, 0x36, 0x36, 0x36, 0xfe, 0x00, 0x00, 0x00},  // [] (189)
    {0x18, 0x18, 0xf8, 0x18, 0xf8, 0x00, 0x00, 0x00},  // [] (190)
    {0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18},  // [] (191)
    {0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00},  // [] (192)
    {0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00},  // [] (193)
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18},  // [] (194)
    {0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 0x18},  // [] (195)
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00},  // [] (196)
    {0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18},  // [] (197)
    {0x18, 0x18, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18},  // [] (198)
    {0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36},  // [] (199)
    {0x36, 0x36, 0x37, 0x30, 0x3f, 0x00, 0x00, 0x00},  // [] (200)
    {0x00, 0x00, 0x3f, 0x30, 0x37, 0x36, 0x36, 0x36},  // [] (201)
    {0x36, 0x36, 0xf7, 0x00, 0xff, 0x00, 0x00, 0x00},  // [] (202)
    {0x00, 0x00, 0xff, 0x00, 0xf7, 0x36, 0x36, 0x36},  // [] (203)
    {0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36},  // [] (204)
    {0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00},  // [] (205)
    {0x36, 0x36, 0xf7, 0x00, 0xf7, 0x36, 0x36, 0x36},  // [] (206)
    {0x18, 0x18, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00},  // [] (207)
    {0x36, 0x36, 0x36, 0x36, 0xff, 0x00, 0x00, 0x00},  // [] (208)
    {0x00, 0x00, 0xff, 0x00, 0xff, 0x18, 0x18, 0x18},  // [] (209)
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x36, 0x36, 0x36},  // [] (210)
    {0x36, 0x36, 0x36, 0x36, 0x3f, 0x00, 0x00, 0x00},  // [] (211)
    {0x18, 0x18, 0x1f, 0x18, 0x1f, 0x00, 0x00, 0x00},  // [] (212)
    {0x00, 0x00, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18},  // [] (213)
    {0x00, 0x00, 0x00, 0x00, 0x3f, 0x36, 0x36, 0x36},  // [] (214)
    {0x36, 0x36, 0x36, 0x36, 0xff, 0x36, 0x36, 0x36},  // [] (215)
    {0x18, 0x18, 0xff, 0x18, 0xff, 0x18, 0x18, 0x18},  // [] (216)
    {0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00},  // [] (217)
    {0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18},  // [] (218)
    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},  // [] (219)
    {0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff},  // [] (220)
    {0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0},  // [] (221)
    {0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f},  // [] (222)
    {0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},  // [] (223)
    {0x00, 0x00, 0x76, 0xdc, 0xc8, 0xdc, 0x76, 0x00},  // [] (224)
    {0x00, 0x78, 0xcc, 0xf8, 0xcc, 0xf8, 0xc0, 0xc0},  // [] (225)
    {0x00, 0xfc, 0xcc, 0xc0, 0xc0, 0xc0, 0xc0, 0x00},  // [] (226)
    {0x00, 0xfe, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00},  // [] (227)
    {0xfc, 0xcc, 0x60, 0x30, 0x60, 0xcc, 0xfc, 0x00},  // [] (228)
    {0x00, 0x00, 0x7e, 0xd8, 0xd8, 0xd8, 0x70, 0x00},  // [] (229)
    {0x00, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0xc0},  // [] (230)
    {0x00, 0x76, 0xdc, 0x18, 0x18, 0x18, 0x18, 0x00},  // [] (231)
    {0xfc, 0x30, 0x78, 0xcc, 0xcc, 0x78, 0x30, 0xfc},  // [] (232)
    {0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0x6c, 0x38, 0x00},  // [] (233)
    {0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x6c, 0xee, 0x00},  // [] (234)
    {0x1c, 0x30, 0x18, 0x7c, 0xcc, 0xcc, 0x78, 0x00},  // [] (235)
    {0x00, 0x00, 0x7e, 0xdb, 0xdb, 0x7e, 0x00, 0x00},  // [] (236)
    {0x06, 0x0c, 0x7e, 0xdb, 0xdb, 0x7e, 0x60, 0xc0},  // [] (237)
    {0x38, 0x60, 0xc0, 0xf8, 0xc0, 0x60, 0x38, 0x00},  // [] (238)
    {0x78, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x00},  // [] (239)
    {0x00, 0xfc, 0x00, 0xfc, 0x00, 0xfc, 0x00, 0x00},  // [] (240)
    {0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0xfc, 0x00},  // [] (241)
    {0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xfc, 0x00},  // [] (242)
    {0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xfc, 0x00},  // [] (243)
    {0x0e, 0x1b, 0x1b, 0x18, 0x18, 0x18, 0x18, 0x18},  // [] (244)
    {0x18, 0x18, 0x18, 0x18, 0x18, 0xd8, 0xd8, 0x70},  // [] (245)
    {0x30, 0x30, 0x00, 0xfc, 0x00, 0x30, 0x30, 0x00},  // [] (246)
    {0x00, 0x76, 0xdc, 0x00, 0x76, 0xdc, 0x00, 0x00},  // [] (247)
    {0x38, 0x6c, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00},  // [] (248)
    {0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00},  // [] (249)
    {0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00},  // [] (250)
    {0x0f, 0x0c, 0x0c, 0x0c, 0xec, 0x6c, 0x3c, 0x1c},  // [] (251)
    {0x78, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00},  // [] (252)
    {0x70, 0x18, 0x30, 0x60, 0x78, 0x00, 0x00, 0x00},  // [] (253)
    {0x00, 0x00, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00},  // [] (254)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // [] (255)
};


// ==============================================================================
// src/video/fonts.c end
// ==============================================================================

// ==============================================================================
// src/video/mda.c start
// ==============================================================================

#line 1 "./src/video/mda.c"
#ifndef YAX86_IMPLEMENTATION
#include "fonts.h"
#include "public.h"
#endif  // YAX86_IMPLEMENTATION

// Default MDA state.
static const MDAState kDefaultMDAState = {
    .config = NULL,
    .registers =
        {
            0x61,
            0x50,
            0x52,
            0x0F,
            0x19,
            0x06,
            0x19,
            0x19,
            0x02,
            0x0D,
            0x0B,
            0x0C,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
        },
    .selected_register = 0,
    // high resolution mode, video enable, blink enable
    .control_port = 0x29,
    .status_port = 0x00,
};

static inline uint8_t ReadVRAMByte(MDAState* mda, uint32_t address) {
  if (mda->config && mda->config->read_vram_byte &&
      address < kMDAModeMetadata.vram_size) {
    return mda->config->read_vram_byte(mda, address);
  }
  return 0xFF;
}

static inline void WriteVRAMByte(
    MDAState* mda, uint32_t address, uint8_t value) {
  if (mda->config && mda->config->write_vram_byte &&
      address < kMDAModeMetadata.vram_size) {
    mda->config->write_vram_byte(mda, address, value);
  }
}

// Initialize MDA state with the provided configuration.
void MDAInit(MDAState* mda, MDAConfig* config) {
  *mda = kDefaultMDAState;
  mda->config = config;

  for (uint32_t i = 0; i < kMDAModeMetadata.vram_size; i += 2) {
    WriteVRAMByte(mda, i, ' ');
    WriteVRAMByte(mda, i + 1, 0x07 /* default attr */);
  }
}

uint8_t MDAReadVRAM(MDAState* mda, uint32_t address) {
  return ReadVRAMByte(mda, address);
}

void MDAWriteVRAM(MDAState* mda, uint32_t address, uint8_t value) {
  WriteVRAMByte(mda, address, value);
}

uint8_t MDAReadPort(MDAState* mda, uint16_t port) {
  switch (port) {
    case kMDAPortRegisterIndex:
      return mda->selected_register;
    case kMDAPortRegisterData:
      if (mda->selected_register < kMDANumRegisters) {
        return mda->registers[mda->selected_register];
      }
      return 0xFF;
    case kMDAPortControl:
      return mda->control_port;
    case kMDAPortStatus:
      return mda->status_port;
    default:
      return 0xFF;
  }
}

void MDAWritePort(MDAState* mda, uint16_t port, uint8_t value) {
  switch (port) {
    case kMDAPortRegisterIndex:
      mda->selected_register = value;
      break;
    case kMDAPortRegisterData:
      if (mda->selected_register < kMDANumRegisters) {
        mda->registers[mda->selected_register] = value;
      }
      break;
    case kMDAPortControl:
      mda->control_port = value;
      break;
    case kMDAPortStatus:
      mda->status_port = value;
      break;
    default:
      break;
  }
}

enum {
  // Position of underline in MDA text mode.
  kMDAUnderlinePosition = 12,
};

// Write a character to display in MDA text mode. For the attribute byte, we
// only support the officially documented combinations of values.
//
// Attribute byte structure:
//   - Bit 7: blink (0 = normal, 1 = blink)
//   - Bits 6-4: background
//   - Bit 3: intense foreground (0 = normal, 1 = intense)
//   - Bits 2-0: foreground
//
// Valid MDA character background and foreground attribute combinations:
//   - Normal: background = 000, foreground = 111
//   - Inverse video: background = 111, foreground = 000
//   - Invisible: background = 000, foreground = 000
//   - Underline: background = 000, foreground = 001
//
// Other combinations are undefined, but we will treat them as normal.
// TODO: Support blinking.
static void MDAWriteChar(MDAState* mda, TextPosition char_pos) {
  uint32_t char_address =
      (char_pos.row * kMDAModeMetadata.columns + char_pos.col) *
      2;  // Each character takes 2 bytes (char + attr).
  uint8_t char_value = ReadVRAMByte(mda, char_address);
  uint8_t attr_value = ReadVRAMByte(mda, char_address + 1);
  const uint16_t* char_bitmap = kFontMDA9x14Bitmap[char_value];

  const RGB* foreground;
  const RGB* background;
  bool underline = false;

  bool intense = ((attr_value >> 3) & 0x01) != 0;
  uint8_t background_attr = (attr_value >> 4) & 0x07;
  uint8_t foreground_attr = attr_value & 0x07;
  if (background_attr == 0x00 && foreground_attr == 0x07) {
    // Normal video mode.
    foreground =
        intense ? &mda->config->intense_foreground : &mda->config->foreground;
    background = &mda->config->background;
  } else if (background_attr == 0x07 && foreground_attr == 0x00) {
    // Inverse video mode.
    foreground = &mda->config->background;
    background = &mda->config->foreground;
  } else if (background_attr == 0x00 && foreground_attr == 0x00) {
    // Invisible mode.
    foreground = &mda->config->background;
    background = &mda->config->background;
  } else if (background_attr == 0x00 && foreground_attr == 0x01) {
    // Underline mode.
    underline = true;
    foreground =
        intense ? &mda->config->intense_foreground : &mda->config->foreground;
    background = &mda->config->background;
  } else {
    // Other combinations are treated as normal.
    foreground =
        intense ? &mda->config->intense_foreground : &mda->config->foreground;
    background = &mda->config->background;
  }

  const VideoModeMetadata* metadata = &kMDAModeMetadata;
  Position origin_pixel_pos = {
      .x = char_pos.col * metadata->char_width,
      .y = char_pos.row * metadata->char_height,
  };
  for (uint8_t y = 0; y < metadata->char_height; ++y) {
    uint16_t row_bitmap;
    // If underline, set entire underline row to foreground color.
    if (y == kMDAUnderlinePosition && underline) {
      row_bitmap = 0xFFFF;
    } else {
      row_bitmap = char_bitmap[y];
    }
    for (uint8_t x = 0; x < metadata->char_width; ++x) {
      Position pixel_pos = {
          .x = origin_pixel_pos.x + x,
          .y = origin_pixel_pos.y + y,
      };
      bool is_foreground =
          (row_bitmap & (1 << (metadata->char_width - 1 - x))) != 0;
      const RGB* pixel_rgb = is_foreground ? foreground : background;
      mda->config->write_pixel(mda, pixel_pos, *pixel_rgb);
    }
  }
}

// Render the current display. Invokes the write_pixel callback to do the actual
// pixel rendering.
void MDARender(MDAState* mda) {
  for (uint8_t row = 0; row < kMDAModeMetadata.rows; ++row) {
    for (uint8_t col = 0; col < kMDAModeMetadata.columns; ++col) {
      TextPosition char_pos = {.col = col, .row = row};
      MDAWriteChar(mda, char_pos);
    }
  }
}


// ==============================================================================
// src/video/mda.c end
// ==============================================================================


#endif  // YAX86_IMPLEMENTATION

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  // YAX86_VIDEO_BUNDLE_H

