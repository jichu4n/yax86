// ==============================================================================
// YAX86 BIOS MODULE - GENERATED SINGLE HEADER BUNDLE
// ==============================================================================

#ifndef YAX86_BIOS_BUNDLE_H
#define YAX86_BIOS_BUNDLE_H

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// ==============================================================================
// src/util/static_vector.h start
// ==============================================================================

#line 1 "./src/util/static_vector.h"
// Static vector library.
//
// A static vector is a vector backed by a fixed-size array. It's essentially
// a vector, but whose underlying storage is statically allocated and does not
// rely on dynamic memory allocation.

#ifndef YAX86_UTIL_STATIC_VECTOR_H
#define YAX86_UTIL_STATIC_VECTOR_H

#include <stddef.h>
#include <stdint.h>

// Header structure at the beginning of a static vector.
typedef struct StaticVectorHeader {
  // Element size in bytes.
  size_t element_size;
  // Maximum number of elements the vector can hold.
  size_t max_length;
  // Number of elements currently in the vector.
  size_t length;
} StaticVectorHeader;

// Define a static vector type with an element type.
#define STATIC_VECTOR_TYPE(name, element_type, max_length_value)          \
  typedef struct name {                                                   \
    StaticVectorHeader header;                                            \
    element_type elements[max_length_value];                              \
  } name;                                                                 \
  static void name##Init(name* vector) __attribute__((unused));           \
  static void name##Init(name* vector) {                                  \
    static const StaticVectorHeader header = {                            \
        .element_size = sizeof(element_type),                             \
        .max_length = (max_length_value),                                 \
        .length = 0,                                                      \
    };                                                                    \
    vector->header = header;                                              \
  }                                                                       \
  static size_t name##Length(const name* vector) __attribute__((unused)); \
  static size_t name##Length(const name* vector) {                        \
    return vector->header.length;                                         \
  }                                                                       \
  static element_type* name##Get(name* vector, size_t index)              \
      __attribute__((unused));                                            \
  static element_type* name##Get(name* vector, size_t index) {            \
    if (index >= (max_length_value)) {                                    \
      return NULL;                                                        \
    }                                                                     \
    return &(vector->elements[index]);                                    \
  }                                                                       \
  static bool name##Append(name* vector, const element_type* element)     \
      __attribute__((unused));                                            \
  static bool name##Append(name* vector, const element_type* element) {   \
    if (vector->header.length >= (max_length_value)) {                    \
      return false;                                                       \
    }                                                                     \
    vector->elements[vector->header.length++] = *element;                 \
    return true;                                                          \
  }                                                                       \
  static bool name##Insert(                                               \
      name* vector, size_t index, const element_type* element)            \
      __attribute__((unused));                                            \
  static bool name##Insert(                                               \
      name* vector, size_t index, const element_type* element) {          \
    if (index > vector->header.length ||                                  \
        vector->header.length >= (max_length_value)) {                    \
      return false;                                                       \
    }                                                                     \
    for (size_t i = vector->header.length; i > index; --i) {              \
      vector->elements[i] = vector->elements[i - 1];                      \
    }                                                                     \
    vector->elements[index] = *element;                                   \
    ++vector->header.length;                                              \
    return true;                                                          \
  }                                                                       \
  static bool name##Remove(name* vector, size_t index)                    \
      __attribute__((unused));                                            \
  static bool name##Remove(name* vector, size_t index) {                  \
    if (index >= vector->header.length) {                                 \
      return false;                                                       \
    }                                                                     \
    for (size_t i = index; i < vector->header.length - 1; ++i) {          \
      vector->elements[i] = vector->elements[i + 1];                      \
    }                                                                     \
    --vector->header.length;                                              \
    return true;                                                          \
  }

#endif  // YAX86_UTIL_STATIC_VECTOR_H


// ==============================================================================
// src/util/static_vector.h end
// ==============================================================================

// ==============================================================================
// src/bios/public.h start
// ==============================================================================

#line 1 "./src/bios/public.h"
// Public interface for the BIOS module.
#ifndef YAX86_BIOS_PUBLIC_H
#define YAX86_BIOS_PUBLIC_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifndef YAX86_BIOS_BUNDLE_H
#include "../util/static_vector.h"
#endif  // YAX86_BIOS_BUNDLE_H

#include "cpu.h"

struct BIOSState;

// ============================================================================
// Memory
// ============================================================================

// Memory region types.
enum {
  // Conventional memory - first 640KB of physical memory, mapped to 0x00000 to
  // 0x9FFFF (640KB).
  kMemoryRegionConventional = 0,
  // Video RAM. Mapping depends on the video mode.
  kMemoryRegionVideo = 1,

  // Maximum number of memory region entries.
  kMaxMemoryRegions = 8,
};

// A memory region in the BIOS memory map. Memory regions should not overlap.
typedef struct MemoryRegion {
  // The memory region type, such as kMemoryRegionConventional.
  uint8_t region_type;
  // Start address of the memory region.
  uint32_t start;
  // Size of the memory region in bytes.
  uint32_t size;
  // Callback to read a byte from the memory region, where address is relative
  // to the start of the region.
  uint8_t (*read_memory_byte)(
      struct BIOSState* bios, uint32_t relative_address);
  // Callback to write a byte to memory, where address is relative to the start
  // of the region.
  void (*write_memory_byte)(
      struct BIOSState* bios, uint32_t relative_address, uint8_t value);
} MemoryRegion;

// Look up the memory region corresponding to an address. Returns NULL if the
// address is not mapped to a known memory region.
MemoryRegion* GetMemoryRegionForAddress(
    struct BIOSState* bios, uint32_t address);
// Look up a memory region by type. Returns NULL if no region found with the
// specified type.
MemoryRegion* GetMemoryRegionByType(
    struct BIOSState* bios, uint8_t region_type);

// Read a byte from a logical memory address.
//
// On the 8086, accessing an invalid memory address will yield garbage data
// rather than causing a page fault. This callback interface mirrors that
// behavior.
uint8_t ReadMemoryByte(struct BIOSState* bios, uint32_t address);
// Read a word from a logical memory address.
uint16_t ReadMemoryWord(struct BIOSState* bios, uint32_t address);

// Write a byte to a logical memory address.
//
// On the 8086, accessing an invalid memory address will yield garbage data
// rather than causing a page fault. This callback interface mirrors that
// behavior.
void WriteMemoryByte(struct BIOSState* bios, uint32_t address, uint8_t value);
// Write a word to a logical memory address.
void WriteMemoryWord(struct BIOSState* bios, uint32_t address, uint16_t value);

// ============================================================================
// Video.
// ============================================================================

// RGB pixel value.
typedef struct RGB {
  // Red component (0-255).
  uint8_t r;
  // Green component (0-255).
  uint8_t g;
  // Blue component (0-255).
  uint8_t b;
} RGB;

// Position in 2D space.
typedef struct Position {
  // X coordinate.
  uint16_t x;
  // Y coordinate.
  uint16_t y;
} Position;

// Text mode character position. We use a different structure to avoid confusion
// with Position, which is used for pixel coordinates.
typedef struct TextPosition {
  // Column (0-based).
  uint8_t col;
  // Row (0-based).
  uint8_t row;
} TextPosition;

// Video modes.
typedef enum VideoMode {
  // CGA text mode 0x00: Text, 40×25, grayscale, 320x200, 8x8
  kVideoTextModeCGA00 = 0x00,
  // CGA text mode 0x01: Text, 40×25, 16 colors, 320x200, 8x8
  kVideoTextModeCGA01 = 0x01,
  // CGA text mode 0x02: Text, 80×25, grayscale, 640x200, 8x8
  kVideoTextModeCGA02 = 0x02,
  // CGA text mode 0x03: Text, 80×25, 16 colors, 640x200, 8x8
  kVideoTextModeCGA03 = 0x03,
  // CGA graphics mode 0x04: Graphics, 4 colors, 320×200
  kVideoGraphicsModeCGA04 = 0x04,
  // CGA graphics mode 0x05: Graphics, grayscale, 320×200
  kVideoGraphicsModeCGA05 = 0x05,
  // CGA graphics mode 0x06: Graphics, monochrome, 640×200
  kVideoGraphicsModeCGA06 = 0x06,
  // MDA text mode 0x07: Text, 80×25, monochrome, 720x350, 9x14
  kVideoTextModeMDA07 = 0x07,

  // Invalid video mode value.
  kInvalidVideoMode = 0xFF,

  // Number of video modes supported.
  kNumVideoModes = 8,
} VideoMode;

// Text vs graphics modes.
typedef enum VideoModeType {
  // Invalid video mode. This is needed due to gap in the list of video mode
  // values.
  kVideoModeUnsupported = 0,
  // Text mode.
  kVideoTextMode,
  // Graphics mode.
  kVideoGraphicsMode,
} VideoModeType;

// Metadata for each video mode.
typedef struct VideoModeMetadata {
  // The video mode.
  VideoMode mode;
  // Type of the video mode (text or graphics).
  VideoModeType type;
  // Mapped memory address of video RAM.
  uint32_t vram_address;
  // Video RAM size in bytes.
  uint32_t vram_size;
  // Resolution width in pixels.
  uint16_t width;
  // Resolution height in pixels.
  uint16_t height;

  // Text mode - number of columns.
  uint8_t columns;
  // Text mode - number of rows.
  uint8_t rows;
  // Text mode - character width in pixels.
  uint8_t char_width;
  // Text mode - character height in pixels.
  uint8_t char_height;
} VideoModeMetadata;

// Character width and height for text modes.
enum {
  // CGA text mode character width.
  kCGACharWidth = 8,
  // CGA text mode character height.
  kCGACharHeight = 8,
  // MDA text mode character width.
  kMDACharWidth = 9,
  // MDA text mode character height.
  kMDACharHeight = 14,
};

// Check if video mode is valid and supported.
extern bool IsSupportedVideoMode(uint8_t mode);
// Get current video mode. Returns kInvalidVideoMode if the video mode in the
// BIOS Data Area (BDA) is invalid.
extern VideoMode GetCurrentVideoMode(struct BIOSState* bios);
// Get current video mode metadata, or NULL if the video mode in the BIOS Data
// Area (BDA) is invalid.
extern const VideoModeMetadata* GetCurrentVideoModeMetadata(
    struct BIOSState* bios);
// Switch video mode.
extern bool SwitchVideoMode(struct BIOSState* bios, VideoMode mode);

// Text mode - clear screen.
extern void TextClearScreen(struct BIOSState* bios);
// Text mode - get current page.
extern uint8_t TextGetCurrentPage(struct BIOSState* bios);
// Text mode - get cursor position on a page.
extern TextPosition TextGetCursorPositionForPage(
    struct BIOSState* bios, uint8_t page);
// Text mode - get cursor position in current page.
extern TextPosition TextGetCursorPosition(struct BIOSState* bios);

// Render the current page in the emulated video RAM to the real display.
// Invokes the write_pixel callback to do the actual pixel rendering.
extern bool RenderCurrentVideoPage(struct BIOSState* bios);

// Caller-provided configuration for MDA text mode rendering.
typedef struct MDAConfig {
  // Foreground color.
  RGB foreground;
  // Intense foreground color.
  RGB intense_foreground;
  // Background color.
  RGB background;
} MDAConfig;

// Default MDA config.
static const MDAConfig kDefaultMDAConfig = {
    .foreground = {.r = 0xAA, .g = 0xAA, .b = 0xAA},
    .intense_foreground = {.r = 0xFF, .g = 0xFF, .b = 0xFF},
    .background = {.r = 0x00, .g = 0x00, .b = 0x00}};

// ============================================================================
// BIOS state
// ============================================================================

// Caller-provided runtime configuration.
typedef struct BIOSConfig {
  // Custom data passed through to callbacks.
  void* context;

  // Physical memory size in KB (1024 bytes). Must be between 64 and 640.
  uint16_t memory_size_kb;

  // MDA text mode configuration.
  MDAConfig mda_config;

  // Callback to read a byte from physical memory.
  //
  // On the 8086, accessing an invalid memory address will yield garbage data
  // rather than causing a page fault. This callback interface mirrors that
  // behavior.
  //
  // For simplicity, we use a single 8-bit interface for memory access, similar
  // to the real-life 8088.
  uint8_t (*read_memory_byte)(struct BIOSState* bios, uint32_t address);

  // Callback to write a byte to physical memory.
  //
  // On the 8086, accessing an invalid memory address will yield garbage data
  // rather than causing a page fault. This callback interface mirrors that
  // behavior.
  //
  // For simplicity, we use a single 8-bit interface for memory access, similar
  // to the real-life 8088.
  void (*write_memory_byte)(
      struct BIOSState* bios, uint32_t address, uint8_t value);

  // Callback to read a byte from the emulated video RAM.
  uint8_t (*read_vram_byte)(struct BIOSState* bios, uint32_t address);

  // Callback to write a byte to the emulated video RAM.
  void (*write_vram_byte)(
      struct BIOSState* bios, uint32_t address, uint8_t value);

  // Callback to write an RGB pixel value to the real display, invoked from
  // RenderCurrentVideoPage().
  void (*write_pixel)(struct BIOSState* bios, Position position, RGB rgb);
} BIOSConfig;

STATIC_VECTOR_TYPE(MemoryRegions, MemoryRegion, kMaxMemoryRegions)

// State of the BIOS.
typedef struct BIOSState {
  // Pointer to caller-provided runtime configuration
  BIOSConfig* config;

  // Memory map.
  MemoryRegions memory_regions;
} BIOSState;

// Initialize BIOS state with the provided configuration.
void InitBIOS(BIOSState* bios, BIOSConfig* config);

// Handle a BIOS interrupt. Follows the handle_interrupt callback signature in
// the CPUConfig structure.
//   - Return kExecuteSuccess if the interrupt was handled and execution
//     should continue.
//   - Return kExecuteUnhandledInterrupt if the interrupt was not handled and
//     should be handled by the VM instead.
//   - Return any other value to terminate the execution loop.
ExecuteStatus HandleBIOSInterrupt(
    BIOSState* bios, CPUState* cpu, uint8_t interrupt_number);

// ============================================================================
// BIOS Data Area (BDA)
// ============================================================================

enum {
  // Address of the BIOS Data Area.
  kBDAAddress = 0x0040,

  // 0x00: Base I/O address for serial ports.
  kBDASerialPortAddress = 0x00,
  // 0x08: Base I/O address for parallel ports.
  kBDAParallelPortAddress = 0x08,
  // 0x10: Equipment word.
  kBDAEquipmentWord = 0x10,
  // 0x12: POST status / Manufacturing test initialization flags
  kBDAPOSTStatus = 0x12,
  // 0x13: Base memory size in kilobytes (0-640)
  kBDAMemorySize = 0x13,
  // 0x15: Manufacturing test scratch pad
  kBDAManufacturingTest1 = 0x15,
  // 0x16: Manufacturing test scratch pad / BIOS control flags
  kBDAManufacturingTest2 = 0x16,
  // 0x17: Keyboard status flags 1
  kBDAKeyboardStatus1 = 0x17,
  // 0x18: Keyboard status flags 2
  kBDAKeyboardStatus2 = 0x18,
  // 0x19: Keyboard: Alt-nnn keypad workspace
  kBDAKeyboardAltNumpad = 0x19,
  // 0x1A: Keyboard: ptr to next character in keyboard buffer
  kBDAKeyboardBufferHead = 0x1A,
  // 0x1C: Keyboard: ptr to first free slot in keyboard buffer
  kBDAKeyboardBufferTail = 0x1C,
  // 0x1E: Keyboard circular buffer (16 words)
  kBDAKeyboardBuffer = 0x1E,
  // 0x3E: Diskette recalibrate status
  kBDADisketteRecalibrateStatus = 0x3E,
  // 0x3F: Diskette motor status
  kBDADisketteMotorStatus = 0x3F,
  // 0x40: Diskette motor turn-off time-out count
  kBDADisketteMotorTimeout = 0x40,
  // 0x41: Diskette last operation status
  kBDADisketteLastStatus = 0x41,
  // 0x42: Diskette/Fixed disk status/command bytes (7 bytes)
  kBDADisketteStatusCommand = 0x42,
  // 0x49: Video current mode
  kBDAVideoMode = 0x49,
  // 0x4A: Video columns on screen
  kBDAVideoColumns = 0x4A,
  // 0x4C: Video page (regen buffer) size in bytes
  kBDAVideoPageSize = 0x4C,
  // 0x4E: Video current page start address in regen buffer
  kBDAVideoPageOffset = 0x4E,
  // 0x50: Video cursor position (col, row) for eight pages
  kBDAVideoCursorPos = 0x50,
  // 0x60: Video cursor type, 6845 compatible
  kBDAVideoCursorType = 0x60,
  // 0x62: Video current page number
  kBDAVideoCurrentPage = 0x62,
  // 0x63: Video CRT controller base address
  kBDAVideoCRTBaseAddress = 0x63,
  // 0x65: Video current setting of mode select register
  kBDAVideoModeSelect = 0x65,
  // 0x66: Video current setting of CGA palette register
  kBDAVideoCGAPalette = 0x66,
  // 0x67: POST real mode re-entry point after certain resets
  kBDAPostReentryPoint = 0x67,
  // 0x6B: POST last unexpected interrupt
  kBDAPostLastInterrupt = 0x6B,
  // 0x6C: Timer ticks since midnight
  kBDATimerTicks = 0x6C,
  // 0x70: Timer overflow, non-zero if has counted past midnight
  kBDATimerOverflow = 0x70,
  // 0x71: Ctrl-Break flag
  kBDACtrlBreakFlag = 0x71,
  // 0x72: POST reset flag
  kBDAPostResetFlag = 0x72,
  // 0x74: Fixed disk last operation status
  kBDAFixedDiskStatus = 0x74,
  // 0x75: Fixed disk: number of fixed disk drives
  kBDAFixedDiskCount = 0x75,
  // 0x76: Fixed disk: control byte
  kBDAFixedDiskControl = 0x76,
  // 0x77: Fixed disk: I/O port offset
  kBDAFixedDiskPortOffset = 0x77,
  // 0x78: Parallel devices 1-3 time-out counters
  kBDAParallelTimeout = 0x78,
  // 0x7C: Serial devices 1-4 time-out counters
  kBDASerialTimeout = 0x7C,
  // 0x80: Keyboard buffer start offset
  kBDAKeyboardBufferStart = 0x80,
  // 0x82: Keyboard buffer end+1 offset
  kBDAKeyboardBufferEnd = 0x82,
  // 0x84: Video EGA/MCGA/VGA rows on screen minus one
  kBDAVideoRows = 0x84,
  // 0x85: Video EGA/MCGA/VGA character height in scan-lines
  kBDAVideoCharHeight = 0x85,
  // 0x87: Video EGA/VGA control
  kBDAVideoEGAControl = 0x87,
  // 0x88: Video EGA/VGA switches
  kBDAVideoEGASwitches = 0x88,
  // 0x89: Video MCGA/VGA mode-set option control
  kBDAVideoVGAControl = 0x89,
  // 0x8A: Video index into Display Combination Code table
  kBDAVideoDCCIndex = 0x8A,
  // 0x8B: Diskette media control
  kBDADisketteMediaControl = 0x8B,
  // 0x8C: Fixed disk controller status
  kBDAFixedDiskControllerStatus = 0x8C,
  // 0x8D: Fixed disk controller Error Status
  kBDAFixedDiskErrorStatus = 0x8D,
  // 0x8E: Fixed disk Interrupt Control
  kBDAFixedDiskInterruptControl = 0x8E,
  // 0x8F: Diskette controller information
  kBDADisketteControllerInfo = 0x8F,
  // 0x90: Diskette drive 0 media state
  kBDADisketteDrive0MediaState = 0x90,
  // 0x91: Diskette drive 1 media state
  kBDADisketteDrive1MediaState = 0x91,
  // 0x92: Diskette drive 0 media state at start of operation
  kBDADisketteDrive0StartState = 0x92,
  // 0x93: Diskette drive 1 media state at start of operation
  kBDADisketteDrive1StartState = 0x93,
  // 0x94: Diskette drive 0 current track number
  kBDADisketteDrive0Track = 0x94,
  // 0x95: Diskette drive 1 current track number
  kBDADisketteDrive1Track = 0x95,
  // 0x96: Keyboard status byte 3
  kBDAKeyboardStatus3 = 0x96,
  // 0x97: Keyboard status byte 4
  kBDAKeyboardStatus4 = 0x97,
  // 0x98: Timer2: ptr to user wait-complete flag
  kBDATimer2WaitFlagPtr = 0x98,
  // 0x9C: Timer2: user wait count in microseconds
  kBDATimer2WaitCount = 0x9C,
  // 0xA0: Timer2: Wait active flag
  kBDATimer2WaitActive = 0xA0,
  // 0xA1: Reserved for network adapters (7 bytes)
  kBDANetworkReserved = 0xA1,
  // 0xA8: Video: EGA/MCGA/VGA ptr to Video Save Pointer Table
  kBDAVideoSavePointerTable = 0xA8,
  // 0xAC: Reserved (4 bytes)
  kBDAReservedAC = 0xAC,
  // 0xB0: ptr to 3363 Optical disk driver or BIOS entry point
  kBDAOpticalDiskPtr = 0xB0,
  // 0xB4: Reserved (2 bytes)
  kBDAReservedB4 = 0xB4,
  // 0xB6: Reserved for POST (3 bytes)
  kBDAReservedPost = 0xB6,
  // 0xB9: Unknown (7 bytes)
  kBDAUnknownB9 = 0xB9,
  // 0xC0: Reserved (14 bytes)
  kBDAReservedC0 = 0xC0,
  // 0xCE: Count of days since last boot
  kBDADaysSinceBoot = 0xCE,
  // 0xD0: Reserved (32 bytes)
  kBDAReservedD0 = 0xD0,
  // 0xF0: Reserved for user (16 bytes)
  kBDAUserReserved = 0xF0,
};

// Structure of the equipment word in the BDA at offset 0x10.
typedef struct EquipmentWord {
  // bits 15-14: number of parallel devices
  uint8_t parallel_devices : 2;
  // bit 13: Internal modem
  uint8_t reserved_13 : 1;
  // bit 12: reserved
  uint8_t reserved_12 : 1;
  // bits 11-9: number of serial devices
  uint8_t serial_devices : 3;
  // bit 8: reserved
  uint8_t reserved_8 : 1;
  // bits 7-6: number of diskette drives minus one
  uint8_t diskette_drives : 2;
  // bits 5-4: Initial video mode:
  //     00b = EGA,VGA,PGA
  //     01b = 40 x 25 color
  //     10b = 80 x 25 color
  //     11b = 80 x 25 mono
  uint8_t video_mode : 2;
  // bit 3: reserved
  uint8_t reserved_3 : 1;
  // bit 2: 1 if pointing device
  uint8_t pointing_device : 1;
  // bit 1: 1 if math co-processor
  uint8_t math_coprocessor : 1;
  // bit 0: 1 if diskette available for boot
  uint8_t diskette_boot_available : 1;
} EquipmentWord;

// Parse uint16_t as EquipmentWord.
EquipmentWord ParseEquipmentWord(uint16_t raw_equipment_word);
// Convert EquipmentWord to uint16_t.
uint16_t SerializeEquipmentWord(EquipmentWord equipment);

#endif  // YAX86_BIOS_PUBLIC_H


// ==============================================================================
// src/bios/public.h end
// ==============================================================================


#ifdef YAX86_IMPLEMENTATION

// ==============================================================================
// src/util/common.h start
// ==============================================================================

#line 1 "./src/util/common.h"
#ifndef YAX86_UTIL_COMMON_H
#define YAX86_UTIL_COMMON_H

// Macro that expands to `static` when bundled. Use for variables and functions
// that need to be visible to other files within the same module, but not
// publicly to users of the bundled library.
//
// This enables better IDE integration as it allows each source file to be
// compiled independently in unbundled form, but still keeps the symbols private
// when bundled.
#ifdef YAX86_IMPLEMENTATION
// When bundled, static linkage so that the symbol is only visible within the
// implementation file.
#define YAX86_PRIVATE static
#else
// When unbundled, use default linkage.
#define YAX86_PRIVATE
#endif  // YAX86_IMPLEMENTATION

#endif  // YAX86_UTIL_COMMON_H


// ==============================================================================
// src/util/common.h end
// ==============================================================================

// ==============================================================================
// src/bios/memory.c start
// ==============================================================================

#line 1 "./src/bios/memory.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "public.h"
#endif  // YAX86_IMPLEMENTATION

// Look up the memory region corresponding to an address. Returns NULL if the
// address is not mapped to a known memory region.
MemoryRegion* GetMemoryRegionForAddress(
    struct BIOSState* bios, uint32_t address) {
  // TODO: Use a more efficient data structure for lookups, such as a sorted
  // array with binary search.
  for (uint8_t i = 0; i < MemoryRegionsLength(&bios->memory_regions); ++i) {
    MemoryRegion* region = MemoryRegionsGet(&bios->memory_regions, i);
    if (address >= region->start && address < region->start + region->size) {
      return region;
    }
  }
  return NULL;
}

// Look up a memory region by type. Returns NULL if no region found with the
// specified type.
MemoryRegion* GetMemoryRegionByType(
    struct BIOSState* bios, uint8_t region_type) {
  for (uint8_t i = 0; i < MemoryRegionsLength(&bios->memory_regions); ++i) {
    MemoryRegion* region = MemoryRegionsGet(&bios->memory_regions, i);
    if (region->region_type == region_type) {
      return region;
    }
  }
  return NULL;
}

// Read a byte from a logical memory address.
uint8_t ReadMemoryByte(struct BIOSState* bios, uint32_t address) {
  MemoryRegion* region = GetMemoryRegionForAddress(bios, address);
  if (!region || !region->read_memory_byte) {
    return 0xFF;
  }
  return region->read_memory_byte(bios, address - region->start);
}

// Read a word from a logical memory address.
uint16_t ReadMemoryWord(struct BIOSState* bios, uint32_t address) {
  uint8_t low_byte = ReadMemoryByte(bios, address);
  uint8_t high_byte = ReadMemoryByte(bios, address + 1);
  return (high_byte << 8) | low_byte;
}

// Write a byte to a logical memory address.
void WriteMemoryByte(struct BIOSState* bios, uint32_t address, uint8_t value) {
  MemoryRegion* region = GetMemoryRegionForAddress(bios, address);
  if (!region || !region->write_memory_byte) {
    return;
  }
  region->write_memory_byte(bios, address - region->start, value);
}

// Write a word to a logical memory address.
void WriteMemoryWord(struct BIOSState* bios, uint32_t address, uint16_t value) {
  WriteMemoryByte(bios, address, value & 0xFF);
  WriteMemoryByte(bios, address + 1, (value >> 8) & 0xFF);
}


// ==============================================================================
// src/bios/memory.c end
// ==============================================================================

// ==============================================================================
// src/bios/fonts.h start
// ==============================================================================

#line 1 "./src/bios/fonts.h"
#ifndef YAX86_BIOS_FONTS_H
#define YAX86_BIOS_FONTS_H

#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "public.h"

// MDA 9x14 font bitmaps.
extern const uint16_t kFontMDA9x14Bitmap[256][kMDACharHeight];
// CGA 8x8 font bitmaps.
extern const uint8_t kFontCGA8x8Bitmap[256][kCGACharHeight];

#endif  // YAX86_IMPLEMENTATION

#endif  // YAX86_BIOS_FONTS_H


// ==============================================================================
// src/bios/fonts.h end
// ==============================================================================

// ==============================================================================
// src/bios/fonts.c start
// ==============================================================================

#line 1 "./src/bios/fonts.c"
#ifndef YAX86_IMPLEMENTATION
#include "fonts.h"

#include "../util/common.h"
#endif  // YAX86_IMPLEMENTATION

// MDA 9x14 font bitmaps. Each character is actually 8x14, with the rightmost
// column left blank except for block characters.
//
// From pcface project:
// https://github.com/susam/pcface/blob/main/out/oldschool-mda-9x14/fontlist.js
YAX86_PRIVATE const uint16_t kFontMDA9x14Bitmap[256][kMDACharHeight] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [] (0)
    {0x00, 0x00, 0xfc, 0x102, 0x14a, 0x102, 0x102, 0x17a, 0x132, 0x102, 0xfc,
     0x00, 0x00, 0x00},  // [☺] (1)
    {0x00, 0x00, 0xfc, 0x1fe, 0x1b6, 0x1fe, 0x1fe, 0x186, 0x1ce, 0x1fe, 0xfc,
     0x00, 0x00, 0x00},  // [☻] (2)
    {0x00, 0x00, 0x00, 0x6c, 0xfe, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
     0x00, 0x00},  // [♥] (3)
    {0x00, 0x00, 0x00, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00, 0x00,
     0x00, 0x00},  // [♦] (4)
    {0x00, 0x00, 0x30, 0x78, 0x78, 0x1ce, 0x1ce, 0x1ce, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [♣] (5)
    {0x00, 0x00, 0x30, 0x78, 0xfc, 0x1fe, 0x1fe, 0xfc, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [♠] (6)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x78, 0x78, 0x30, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [•] (7)
    {0x1fe, 0x1fe, 0x1fe, 0x1fe, 0x1fe, 0x1ce, 0x186, 0x186, 0x1ce, 0x1fe,
     0x1fe, 0x1fe, 0x1fe, 0x1fe},  // [◘] (8)
    {0x00, 0x00, 0x00, 0x00, 0x78, 0xcc, 0x84, 0x84, 0xcc, 0x78, 0x00, 0x00,
     0x00, 0x00},  // [○] (9)
    {0x1fe, 0x1fe, 0x1fe, 0x1fe, 0x186, 0x132, 0x17a, 0x17a, 0x132, 0x186,
     0x1fe, 0x1fe, 0x1fe, 0x1fe},  // [◙] (10)
    {0x00, 0x00, 0x1e, 0x0e, 0x1a, 0x32, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
     0x00, 0x00},  // [♂] (11)
    {0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0xfc, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [♀] (12)
    {0x00, 0x00, 0x7e, 0x66, 0x7e, 0x60, 0x60, 0x60, 0xe0, 0x1e0, 0x1c0, 0x00,
     0x00, 0x00},  // [♪] (13)
    {0x00, 0x00, 0xfe, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xce, 0x1ce, 0x1cc, 0x180,
     0x00, 0x00},  // [♫] (14)
    {0x00, 0x00, 0x30, 0x30, 0x1b6, 0x78, 0x1ce, 0x78, 0x1b6, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [☼] (15)
    {0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0xc0, 0x80, 0x00,
     0x00, 0x00},  // [►] (16)
    {0x00, 0x00, 0x02, 0x06, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x06, 0x02, 0x00,
     0x00, 0x00},  // [◄] (17)
    {0x00, 0x00, 0x30, 0x78, 0xfc, 0x30, 0x30, 0x30, 0xfc, 0x78, 0x30, 0x00,
     0x00, 0x00},  // [↕] (18)
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x66, 0x00,
     0x00, 0x00},  // [‼] (19)
    {0x00, 0x00, 0xfe, 0x1b6, 0x1b6, 0x1b6, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x00,
     0x00, 0x00},  // [¶] (20)
    {0x00, 0x7c, 0xc6, 0x60, 0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x38, 0x0c, 0xc6,
     0x7c, 0x00},  // [§] (21)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfe, 0x00,
     0x00, 0x00},  // [▬] (22)
    {0x00, 0x00, 0x30, 0x78, 0xfc, 0x30, 0x30, 0x30, 0xfc, 0x78, 0x30, 0xfc,
     0x00, 0x00},  // [↨] (23)
    {0x00, 0x00, 0x30, 0x78, 0xfc, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [↑] (24)
    {0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x78, 0x30, 0x00,
     0x00, 0x00},  // [↓] (25)
    {0x00, 0x00, 0x00, 0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [→] (26)
    {0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [←] (27)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [∟] (28)
    {0x00, 0x00, 0x00, 0x00, 0x48, 0xcc, 0x1fe, 0xcc, 0x48, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [↔] (29)
    {0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7c, 0x7c, 0xfe, 0xfe, 0x00, 0x00,
     0x00, 0x00},  // [▲] (30)
    {0x00, 0x00, 0x00, 0xfe, 0xfe, 0x7c, 0x7c, 0x38, 0x38, 0x10, 0x00, 0x00,
     0x00, 0x00},  // [▼] (31)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [ ] (32)
    {0x00, 0x00, 0x30, 0x78, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [!] (33)
    {0x00, 0xc6, 0xc6, 0xc6, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // ["] (34)
    {0x00, 0x00, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
     0x00, 0x00},  // [#] (35)
    {0x18, 0x18, 0x7c, 0xc6, 0xc2, 0xc0, 0x7c, 0x06, 0x86, 0xc6, 0x7c, 0x18,
     0x18, 0x00},  // [$] (36)
    {0x00, 0x00, 0x00, 0x00, 0xc2, 0xc6, 0x0c, 0x18, 0x30, 0x66, 0xc6, 0x00,
     0x00, 0x00},  // [%] (37)
    {0x00, 0x00, 0x38, 0x6c, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [&] (38)
    {0x00, 0x60, 0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // ['] (39)
    {0x00, 0x00, 0x18, 0x30, 0x60, 0x60, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
     0x00, 0x00},  // [(] (40)
    {0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00,
     0x00, 0x00},  // [)] (41)
    {0x00, 0x00, 0x00, 0x00, 0xcc, 0x78, 0x1fe, 0x78, 0xcc, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [*] (42)
    {0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x1fe, 0x30, 0x30, 0x30, 0x00, 0x00,
     0x00, 0x00},  // [+] (43)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x60,
     0x00, 0x00},  // [,] (44)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1fe, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [-] (45)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [.] (46)
    {0x00, 0x00, 0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00, 0x00,
     0x00, 0x00},  // [/] (47)
    {0x00, 0x00, 0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [0] (48)
    {0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00,
     0x00, 0x00},  // [1] (49)
    {0x00, 0x00, 0x7c, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00,
     0x00, 0x00},  // [2] (50)
    {0x00, 0x00, 0x7c, 0xc6, 0x06, 0x06, 0x3c, 0x06, 0x06, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [3] (51)
    {0x00, 0x00, 0x0c, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x0c, 0x1e, 0x00,
     0x00, 0x00},  // [4] (52)
    {0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0, 0xfc, 0x06, 0x06, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [5] (53)
    {0x00, 0x00, 0x38, 0x60, 0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [6] (54)
    {0x00, 0x00, 0xfe, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [7] (55)
    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [8] (56)
    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x06, 0x0c, 0x78, 0x00,
     0x00, 0x00},  // [9] (57)
    {0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00,
     0x00, 0x00},  // [:] (58)
    {0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60, 0x00,
     0x00, 0x00},  // [;] (59)
    {0x00, 0x00, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x00,
     0x00, 0x00},  // [<] (60)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [=] (61)
    {0x00, 0x00, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x00,
     0x00, 0x00},  // [>] (62)
    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x0c, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00,
     0x00, 0x00},  // [?] (63)
    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xde, 0xde, 0xde, 0xdc, 0xc0, 0x7c, 0x00,
     0x00, 0x00},  // [@] (64)
    {0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [A] (65)
    {0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x66, 0xfc, 0x00,
     0x00, 0x00},  // [B] (66)
    {0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xc0, 0xc2, 0x66, 0x3c, 0x00,
     0x00, 0x00},  // [C] (67)
    {0x00, 0x00, 0xf8, 0x6c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
     0x00, 0x00},  // [D] (68)
    {0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66, 0xfe, 0x00,
     0x00, 0x00},  // [E] (69)
    {0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0xf0, 0x00,
     0x00, 0x00},  // [F] (70)
    {0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xde, 0xc6, 0x66, 0x3a, 0x00,
     0x00, 0x00},  // [G] (71)
    {0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [H] (72)
    {0x00, 0x00, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [I] (73)
    {0x00, 0x00, 0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
     0x00, 0x00},  // [J] (74)
    {0x00, 0x00, 0xe6, 0x66, 0x6c, 0x6c, 0x78, 0x6c, 0x6c, 0x66, 0xe6, 0x00,
     0x00, 0x00},  // [K] (75)
    {0x00, 0x00, 0xf0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
     0x00, 0x00},  // [L] (76)
    {0x00, 0x00, 0x186, 0x1ce, 0x1fe, 0x1b6, 0x186, 0x186, 0x186, 0x186, 0x186,
     0x00, 0x00, 0x00},  // [M] (77)
    {0x00, 0x00, 0xc6, 0xe6, 0xf6, 0xfe, 0xde, 0xce, 0xc6, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [N] (78)
    {0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
     0x00, 0x00},  // [O] (79)
    {0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0xf0, 0x00,
     0x00, 0x00},  // [P] (80)
    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xde, 0x7c, 0x0c, 0x0e,
     0x00, 0x00},  // [Q] (81)
    {0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x66, 0xe6, 0x00,
     0x00, 0x00},  // [R] (82)
    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x60, 0x38, 0x0c, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [S] (83)
    {0x00, 0x00, 0x1fe, 0x1b6, 0x132, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [T] (84)
    {0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [U] (85)
    {0x00, 0x00, 0x186, 0x186, 0x186, 0x186, 0x186, 0x186, 0xcc, 0x78, 0x30,
     0x00, 0x00, 0x00},  // [V] (86)
    {0x00, 0x00, 0x186, 0x186, 0x186, 0x186, 0x1b6, 0x1b6, 0x1fe, 0xcc, 0xcc,
     0x00, 0x00, 0x00},  // [W] (87)
    {0x00, 0x00, 0x186, 0x186, 0xcc, 0x78, 0x30, 0x78, 0xcc, 0x186, 0x186, 0x00,
     0x00, 0x00},  // [X] (88)
    {0x00, 0x00, 0x186, 0x186, 0x186, 0xcc, 0x78, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [Y] (89)
    {0x00, 0x00, 0x1fe, 0x186, 0x10c, 0x18, 0x30, 0x60, 0xc2, 0x186, 0x1fe,
     0x00, 0x00, 0x00},  // [Z] (90)
    {0x00, 0x00, 0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
     0x00, 0x00},  // [[] (91)
    {0x00, 0x00, 0x80, 0xc0, 0xe0, 0x70, 0x38, 0x1c, 0x0e, 0x06, 0x02, 0x00,
     0x00, 0x00},  // [\] (92)
    {0x00, 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
     0x00, 0x00},  // []] (93)
    {0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [^] (94)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x1fe, 0x00},  // [_] (95)
    {0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [`] (96)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [a] (97)
    {0x00, 0x00, 0xe0, 0x60, 0x60, 0x78, 0x6c, 0x66, 0x66, 0x66, 0xdc, 0x00,
     0x00, 0x00},  // [b] (98)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [c] (99)
    {0x00, 0x00, 0x1c, 0x0c, 0x0c, 0x3c, 0x6c, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [d] (100)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [e] (101)
    {0x00, 0x00, 0x38, 0x6c, 0x64, 0x60, 0xf8, 0x60, 0x60, 0x60, 0xf0, 0x00,
     0x00, 0x00},  // [f] (102)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xcc,
     0x78, 0x00},  // [g] (103)
    {0x00, 0x00, 0xe0, 0x60, 0x60, 0x6c, 0x76, 0x66, 0x66, 0x66, 0xe6, 0x00,
     0x00, 0x00},  // [h] (104)
    {0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
     0x00, 0x00},  // [i] (105)
    {0x00, 0x00, 0x0c, 0x0c, 0x00, 0x1c, 0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc,
     0x78, 0x00},  // [j] (106)
    {0x00, 0x00, 0xe0, 0x60, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
     0x00, 0x00},  // [k] (107)
    {0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
     0x00, 0x00},  // [l] (108)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x1cc, 0x1fe, 0x1b6, 0x1b6, 0x1b6, 0x1b6,
     0x00, 0x00, 0x00},  // [m] (109)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00,
     0x00, 0x00},  // [n] (110)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [o] (111)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60,
     0xf0, 0x00},  // [p] (112)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0x0c,
     0x1e, 0x00},  // [q] (113)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0x60, 0xf0, 0x00,
     0x00, 0x00},  // [r] (114)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x70, 0x1c, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [s] (115)
    {0x00, 0x00, 0x10, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x36, 0x1c, 0x00,
     0x00, 0x00},  // [t] (116)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [u] (117)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x186, 0x186, 0x186, 0xcc, 0x78, 0x30, 0x00,
     0x00, 0x00},  // [v] (118)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x186, 0x186, 0x1b6, 0x1b6, 0x1fe, 0xcc,
     0x00, 0x00, 0x00},  // [w] (119)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
     0x00, 0x00},  // [x] (120)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c,
     0x78, 0x00},  // [y] (121)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xcc, 0x18, 0x30, 0x66, 0xfe, 0x00,
     0x00, 0x00},  // [z] (122)
    {0x00, 0x00, 0x1c, 0x30, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x30, 0x1c, 0x00,
     0x00, 0x00},  // [{] (123)
    {0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x00, 0x30, 0x30, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [|] (124)
    {0x00, 0x00, 0xe0, 0x30, 0x30, 0x30, 0x1c, 0x30, 0x30, 0x30, 0xe0, 0x00,
     0x00, 0x00},  // [}] (125)
    {0x00, 0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [~] (126)
    {0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00, 0x00,
     0x00, 0x00},  // [⌂] (127)
    {0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xc2, 0x66, 0x3c, 0x0c, 0x06,
     0x7c, 0x00},  // [Ç] (128)
    {0x00, 0x00, 0xcc, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [ü] (129)
    {0x00, 0x0c, 0x18, 0x30, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [é] (130)
    {0x00, 0x10, 0x38, 0x6c, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [â] (131)
    {0x00, 0x00, 0xcc, 0xcc, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [ä] (132)
    {0x00, 0x60, 0x30, 0x18, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [à] (133)
    {0x00, 0x38, 0x6c, 0x38, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [å] (134)
    {0x00, 0x00, 0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x18, 0x0c, 0x78,
     0x00, 0x00},  // [ç] (135)
    {0x00, 0x10, 0x38, 0x6c, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [ê] (136)
    {0x00, 0x00, 0xcc, 0xcc, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [ë] (137)
    {0x00, 0x60, 0x30, 0x18, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [è] (138)
    {0x00, 0x00, 0xcc, 0xcc, 0x00, 0x70, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [ï] (139)
    {0x00, 0x30, 0x78, 0xcc, 0x00, 0x70, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [î] (140)
    {0x00, 0xc0, 0x60, 0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [ì] (141)
    {0x00, 0xc6, 0xc6, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [Ä] (142)
    {0x38, 0x6c, 0x38, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [Å] (143)
    {0x18, 0x30, 0x60, 0x00, 0xfe, 0x66, 0x60, 0x7c, 0x60, 0x66, 0xfe, 0x00,
     0x00, 0x00},  // [É] (144)
    {0x00, 0x00, 0x00, 0x00, 0xdc, 0x76, 0x36, 0xfc, 0x1b0, 0x1b8, 0xee, 0x00,
     0x00, 0x00},  // [æ] (145)
    {0x00, 0x00, 0x3e, 0x6c, 0xcc, 0xcc, 0xfe, 0xcc, 0xcc, 0xcc, 0xce, 0x00,
     0x00, 0x00},  // [Æ] (146)
    {0x00, 0x10, 0x38, 0x6c, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [ô] (147)
    {0x00, 0x00, 0xc6, 0xc6, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [ö] (148)
    {0x00, 0x60, 0x30, 0x18, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [ò] (149)
    {0x00, 0x30, 0x78, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [û] (150)
    {0x00, 0x60, 0x30, 0x18, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [ù] (151)
    {0x00, 0x00, 0xc6, 0xc6, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c,
     0x78, 0x00},  // [ÿ] (152)
    {0x00, 0xc6, 0xc6, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
     0x00, 0x00},  // [Ö] (153)
    {0x00, 0xc6, 0xc6, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [Ü] (154)
    {0x00, 0x30, 0x30, 0xfc, 0x186, 0x180, 0x180, 0x186, 0xfc, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [¢] (155)
    {0x00, 0x38, 0x6c, 0x64, 0x60, 0xf0, 0x60, 0x60, 0x60, 0xe6, 0xfc, 0x00,
     0x00, 0x00},  // [£] (156)
    {0x00, 0x00, 0x186, 0xcc, 0x78, 0x30, 0x1fe, 0x30, 0x1fe, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [¥] (157)
    {0x00, 0x1f8, 0xcc, 0xcc, 0xf8, 0xc4, 0xcc, 0xde, 0xcc, 0xcc, 0x1e6, 0x00,
     0x00, 0x00},  // [₧] (158)
    {0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x30, 0x1b0,
     0xe0, 0x00},  // [ƒ] (159)
    {0x00, 0x18, 0x30, 0x60, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [á] (160)
    {0x00, 0x18, 0x30, 0x60, 0x00, 0x70, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
     0x00, 0x00},  // [í] (161)
    {0x00, 0x18, 0x30, 0x60, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [ó] (162)
    {0x00, 0x18, 0x30, 0x60, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
     0x00, 0x00},  // [ú] (163)
    {0x00, 0x00, 0x76, 0xdc, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00,
     0x00, 0x00},  // [ñ] (164)
    {0x76, 0xdc, 0x00, 0xc6, 0xe6, 0xf6, 0xfe, 0xde, 0xce, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [Ñ] (165)
    {0x00, 0x78, 0xd8, 0xd8, 0x7c, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [ª] (166)
    {0x00, 0x70, 0xd8, 0xd8, 0x70, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [º] (167)
    {0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, 0xc6, 0xc6, 0x7c, 0x00,
     0x00, 0x00},  // [¿] (168)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0, 0x00, 0x00,
     0x00, 0x00},  // [⌐] (169)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x06, 0x06, 0x06, 0x00, 0x00,
     0x00, 0x00},  // [¬] (170)
    {0x00, 0xc0, 0x1c0, 0xc6, 0xcc, 0xd8, 0x30, 0x60, 0xdc, 0x186, 0x0c, 0x18,
     0x3e, 0x00},  // [½] (171)
    {0x00, 0xc0, 0x1c0, 0xc6, 0xcc, 0xd8, 0x30, 0x66, 0xce, 0x19e, 0x3e, 0x06,
     0x06, 0x00},  // [¼] (172)
    {0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x78, 0x78, 0x78, 0x30, 0x00,
     0x00, 0x00},  // [¡] (173)
    {0x00, 0x00, 0x00, 0x00, 0x36, 0x6c, 0xd8, 0x6c, 0x36, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [«] (174)
    {0x00, 0x00, 0x00, 0x00, 0xd8, 0x6c, 0x36, 0x6c, 0xd8, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [»] (175)
    {0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88,
     0x22, 0x88},  // [░] (176)
    {0xaa, 0x154, 0xaa, 0x154, 0xaa, 0x154, 0xaa, 0x154, 0xaa, 0x154, 0xaa,
     0x154, 0xaa, 0x154},  // [▒] (177)
    {0x1ba, 0xee, 0x1ba, 0xee, 0x1ba, 0xee, 0x1ba, 0xee, 0x1ba, 0xee, 0x1ba,
     0xee, 0x1ba, 0xee},  // [▓] (178)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [│] (179)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1f0, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [┤] (180)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x1f0, 0x30, 0x1f0, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [╡] (181)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ec, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [╢] (182)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1fc, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [╖] (183)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x1f0, 0x30, 0x1f0, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [╕] (184)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ec, 0x0c, 0x1ec, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [╣] (185)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [║] (186)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x1fc, 0x0c, 0x1ec, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [╗] (187)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ec, 0x0c, 0x1fc, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [╝] (188)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1fc, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [╜] (189)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x1f0, 0x30, 0x1f0, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [╛] (190)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f0, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [┐] (191)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3f, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [└] (192)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [┴] (193)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [┬] (194)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3f, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [├] (195)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [─] (196)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1ff, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [┼] (197)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x3f, 0x30, 0x3f, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [╞] (198)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6f, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [╟] (199)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6f, 0x60, 0x7f, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [╚] (200)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x60, 0x6f, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [╔] (201)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ef, 0x00, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [╩] (202)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x00, 0x1ef, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [╦] (203)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6f, 0x60, 0x6f, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [╠] (204)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x00, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [═] (205)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ef, 0x00, 0x1ef, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [╬] (206)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x1ff, 0x00, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [╧] (207)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [╨] (208)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x00, 0x1ff, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [╤] (209)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [╥] (210)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x7f, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [╙] (211)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x3f, 0x30, 0x3f, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [╘] (212)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x30, 0x3f, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [╒] (213)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [╓] (214)
    {0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x1ff, 0x6c, 0x6c, 0x6c, 0x6c,
     0x6c, 0x6c},  // [╫] (215)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x1ff, 0x30, 0x1ff, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [╪] (216)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1f0, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [┘] (217)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [┌] (218)
    {0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff,
     0x1ff, 0x1ff, 0x1ff, 0x1ff},  // [█] (219)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1ff, 0x1ff, 0x1ff, 0x1ff,
     0x1ff, 0x1ff, 0x1ff},  // [▄] (220)
    {0x1e0, 0x1e0, 0x1e0, 0x1e0, 0x1e0, 0x1e0, 0x1e0, 0x1e0, 0x1e0, 0x1e0,
     0x1e0, 0x1e0, 0x1e0, 0x1e0},  // [▌] (221)
    {0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
     0x1f, 0x1f},  // [▐] (222)
    {0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00},  // [▀] (223)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0xd8, 0xd8, 0xdc, 0x76, 0x00,
     0x00, 0x00},  // [α] (224)
    {0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xfc, 0xc6, 0xc6, 0xfc, 0xc0, 0xc0,
     0x40, 0x00},  // [ß] (225)
    {0x00, 0x00, 0xfe, 0xc6, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x00,
     0x00, 0x00},  // [Γ] (226)
    {0x00, 0x00, 0x00, 0x00, 0xfe, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00,
     0x00, 0x00},  // [π] (227)
    {0x00, 0x00, 0xfe, 0xc6, 0x60, 0x30, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00,
     0x00, 0x00},  // [Σ] (228)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xd8, 0xd8, 0xd8, 0xd8, 0x70, 0x00,
     0x00, 0x00},  // [σ] (229)
    {0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xc0,
     0x00, 0x00},  // [µ] (230)
    {0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
     0x00, 0x00},  // [τ] (231)
    {0x00, 0x00, 0xfc, 0x30, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0xfc, 0x00,
     0x00, 0x00},  // [Φ] (232)
    {0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
     0x00, 0x00},  // [Θ] (233)
    {0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x6c, 0x6c, 0xee, 0x00,
     0x00, 0x00},  // [Ω] (234)
    {0x00, 0x00, 0x3c, 0x60, 0x30, 0x18, 0x7c, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
     0x00, 0x00},  // [δ] (235)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1b6, 0x1b6, 0xfc, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [∞] (236)
    {0x00, 0x00, 0x06, 0x0c, 0xfc, 0x1b6, 0x1b6, 0x1e6, 0xfc, 0xc0, 0x180, 0x00,
     0x00, 0x00},  // [φ] (237)
    {0x00, 0x00, 0x38, 0x60, 0xc0, 0xc0, 0xf8, 0xc0, 0xc0, 0x60, 0x38, 0x00,
     0x00, 0x00},  // [ε] (238)
    {0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,
     0x00, 0x00},  // [∩] (239)
    {0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00,
     0x00, 0x00},  // [≡] (240)
    {0x00, 0x00, 0x30, 0x30, 0x30, 0x1fe, 0x30, 0x30, 0x30, 0x00, 0x1fe, 0x00,
     0x00, 0x00},  // [±] (241)
    {0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00, 0xfc, 0x00,
     0x00, 0x00},  // [≥] (242)
    {0x00, 0x00, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00, 0xfc, 0x00,
     0x00, 0x00},  // [≤] (243)
    {0x00, 0x00, 0x1c, 0x36, 0x36, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30},  // [⌠] (244)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1b0, 0x1b0, 0xe0, 0x00,
     0x00, 0x00},  // [⌡] (245)
    {0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x1fe, 0x00, 0x00, 0x30, 0x30, 0x00,
     0x00, 0x00},  // [÷] (246)
    {0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0x00, 0x76, 0xdc, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [≈] (247)
    {0x00, 0x70, 0xd8, 0xd8, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [°] (248)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [∙] (249)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [·] (250)
    {0x00, 0x1e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1d8, 0xd8, 0x78, 0x38, 0x00,
     0x00, 0x00},  // [√] (251)
    {0x00, 0x1b0, 0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [ⁿ] (252)
    {0x00, 0xe0, 0x1b0, 0x60, 0xc0, 0x190, 0x1f0, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [²] (253)
    {0x00, 0x00, 0x00, 0x00, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x00, 0x00,
     0x00, 0x00},  // [■] (254)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00},  // [ ] (255)
};

// CGA 8x8 font bitmaps.
//
// From pcface project:
// https://github.com/susam/pcface/blob/main/out/oldschool-cga-8x8/fontlist.js
YAX86_PRIVATE const uint8_t kFontCGA8x8Bitmap[256][kCGACharHeight] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // [] (0)
    {0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e},  // [☺] (1)
    {0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e},  // [☻] (2)
    {0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00},  // [♥] (3)
    {0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00},  // [♦] (4)
    {0x38, 0x7c, 0x38, 0xfe, 0xfe, 0xd6, 0x10, 0x38},  // [♣] (5)
    {0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x10, 0x38},  // [♠] (6)
    {0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00},  // [•] (7)
    {0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff},  // [◘] (8)
    {0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00},  // [○] (9)
    {0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff},  // [◙] (10)
    {0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78},  // [♂] (11)
    {0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18},  // [♀] (12)
    {0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0},  // [♪] (13)
    {0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0},  // [♫] (14)
    {0x18, 0xdb, 0x3c, 0xe7, 0xe7, 0x3c, 0xdb, 0x18},  // [☼] (15)
    {0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00},  // [►] (16)
    {0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00},  // [◄] (17)
    {0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18},  // [↕] (18)
    {0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00},  // [‼] (19)
    {0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00},  // [¶] (20)
    {0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78},  // [§] (21)
    {0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00},  // [▬] (22)
    {0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff},  // [↨] (23)
    {0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00},  // [↑] (24)
    {0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00},  // [↓] (25)
    {0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00},  // [→] (26)
    {0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00},  // [←] (27)
    {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00},  // [∟] (28)
    {0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00},  // [↔] (29)
    {0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00},  // [▲] (30)
    {0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00},  // [▼] (31)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // [ ] (32)
    {0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00},  // [!] (33)
    {0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00},  // ["] (34)
    {0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00},  // [#] (35)
    {0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00},  // [$] (36)
    {0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00},  // [%] (37)
    {0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00},  // [&] (38)
    {0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00},  // ['] (39)
    {0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00},  // [(] (40)
    {0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00},  // [)] (41)
    {0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00},  // [*] (42)
    {0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00},  // [+] (43)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60},  // [,] (44)
    {0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00},  // [-] (45)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00},  // [.] (46)
    {0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00},  // [/] (47)
    {0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00},  // [0] (48)
    {0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00},  // [1] (49)
    {0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00},  // [2] (50)
    {0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00},  // [3] (51)
    {0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00},  // [4] (52)
    {0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00},  // [5] (53)
    {0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00},  // [6] (54)
    {0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00},  // [7] (55)
    {0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00},  // [8] (56)
    {0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00},  // [9] (57)
    {0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00},  // [:] (58)
    {0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60},  // [;] (59)
    {0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00},  // [<] (60)
    {0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00},  // [=] (61)
    {0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00},  // [>] (62)
    {0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00},  // [?] (63)
    {0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00},  // [@] (64)
    {0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00},  // [A] (65)
    {0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00},  // [B] (66)
    {0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00},  // [C] (67)
    {0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00},  // [D] (68)
    {0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00},  // [E] (69)
    {0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00},  // [F] (70)
    {0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00},  // [G] (71)
    {0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00},  // [H] (72)
    {0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},  // [I] (73)
    {0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00},  // [J] (74)
    {0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00},  // [K] (75)
    {0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00},  // [L] (76)
    {0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00},  // [M] (77)
    {0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00},  // [N] (78)
    {0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00},  // [O] (79)
    {0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00},  // [P] (80)
    {0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00},  // [Q] (81)
    {0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00},  // [R] (82)
    {0x78, 0xcc, 0x60, 0x30, 0x18, 0xcc, 0x78, 0x00},  // [S] (83)
    {0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},  // [T] (84)
    {0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00},  // [U] (85)
    {0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00},  // [V] (86)
    {0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00},  // [W] (87)
    {0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00},  // [X] (88)
    {0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00},  // [Y] (89)
    {0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00},  // [Z] (90)
    {0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00},  // [[] (91)
    {0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00},  // [\] (92)
    {0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00},  // []] (93)
    {0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00},  // [^] (94)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff},  // [_] (95)
    {0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},  // [`] (96)
    {0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00},  // [a] (97)
    {0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00},  // [b] (98)
    {0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00},  // [c] (99)
    {0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00},  // [d] (100)
    {0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},  // [e] (101)
    {0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00},  // [f] (102)
    {0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},  // [g] (103)
    {0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00},  // [h] (104)
    {0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},  // [i] (105)
    {0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78},  // [j] (106)
    {0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00},  // [k] (107)
    {0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},  // [l] (108)
    {0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00},  // [m] (109)
    {0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00},  // [n] (110)
    {0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00},  // [o] (111)
    {0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0},  // [p] (112)
    {0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e},  // [q] (113)
    {0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00},  // [r] (114)
    {0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00},  // [s] (115)
    {0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00},  // [t] (116)
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00},  // [u] (117)
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00},  // [v] (118)
    {0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00},  // [w] (119)
    {0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00},  // [x] (120)
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},  // [y] (121)
    {0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00},  // [z] (122)
    {0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00},  // [{] (123)
    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},  // [|] (124)
    {0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00},  // [}] (125)
    {0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // [~] (126)
    {0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00},  // [⌂] (127)
    {0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x18, 0x0c, 0x78},  // [Ç] (128)
    {0x00, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},  // [ü] (129)
    {0x1c, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},  // [é] (130)
    {0x7e, 0xc3, 0x3c, 0x06, 0x3e, 0x66, 0x3f, 0x00},  // [â] (131)
    {0xcc, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},  // [ä] (132)
    {0xe0, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},  // [à] (133)
    {0x30, 0x30, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},  // [å] (134)
    {0x00, 0x00, 0x78, 0xc0, 0xc0, 0x78, 0x0c, 0x38},  // [ç] (135)
    {0x7e, 0xc3, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00},  // [ê] (136)
    {0xcc, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},  // [ë] (137)
    {0xe0, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},  // [è] (138)
    {0xcc, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},  // [ï] (139)
    {0x7c, 0xc6, 0x38, 0x18, 0x18, 0x18, 0x3c, 0x00},  // [î] (140)
    {0xe0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},  // [ì] (141)
    {0xc6, 0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0xc6, 0x00},  // [Ä] (142)
    {0x30, 0x30, 0x00, 0x78, 0xcc, 0xfc, 0xcc, 0x00},  // [Å] (143)
    {0x1c, 0x00, 0xfc, 0x60, 0x78, 0x60, 0xfc, 0x00},  // [É] (144)
    {0x00, 0x00, 0x7f, 0x0c, 0x7f, 0xcc, 0x7f, 0x00},  // [æ] (145)
    {0x3e, 0x6c, 0xcc, 0xfe, 0xcc, 0xcc, 0xce, 0x00},  // [Æ] (146)
    {0x78, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},  // [ô] (147)
    {0x00, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},  // [ö] (148)
    {0x00, 0xe0, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},  // [ò] (149)
    {0x78, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},  // [û] (150)
    {0x00, 0xe0, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},  // [ù] (151)
    {0x00, 0xcc, 0x00, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},  // [ÿ] (152)
    {0xc3, 0x18, 0x3c, 0x66, 0x66, 0x3c, 0x18, 0x00},  // [Ö] (153)
    {0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x00},  // [Ü] (154)
    {0x18, 0x18, 0x7e, 0xc0, 0xc0, 0x7e, 0x18, 0x18},  // [¢] (155)
    {0x38, 0x6c, 0x64, 0xf0, 0x60, 0xe6, 0xfc, 0x00},  // [£] (156)
    {0xcc, 0xcc, 0x78, 0xfc, 0x30, 0xfc, 0x30, 0x30},  // [¥] (157)
    {0xf8, 0xcc, 0xcc, 0xfa, 0xc6, 0xcf, 0xc6, 0xc7},  // [₧] (158)
    {0x0e, 0x1b, 0x18, 0x3c, 0x18, 0x18, 0xd8, 0x70},  // [ƒ] (159)
    {0x1c, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},  // [á] (160)
    {0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},  // [í] (161)
    {0x00, 0x1c, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},  // [ó] (162)
    {0x00, 0x1c, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},  // [ú] (163)
    {0x00, 0xf8, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0x00},  // [ñ] (164)
    {0xfc, 0x00, 0xcc, 0xec, 0xfc, 0xdc, 0xcc, 0x00},  // [Ñ] (165)
    {0x3c, 0x6c, 0x6c, 0x3e, 0x00, 0x7e, 0x00, 0x00},  // [ª] (166)
    {0x38, 0x6c, 0x6c, 0x38, 0x00, 0x7c, 0x00, 0x00},  // [º] (167)
    {0x30, 0x00, 0x30, 0x60, 0xc0, 0xcc, 0x78, 0x00},  // [¿] (168)
    {0x00, 0x00, 0x00, 0xfc, 0xc0, 0xc0, 0x00, 0x00},  // [⌐] (169)
    {0x00, 0x00, 0x00, 0xfc, 0x0c, 0x0c, 0x00, 0x00},  // [¬] (170)
    {0xc3, 0xc6, 0xcc, 0xde, 0x33, 0x66, 0xcc, 0x0f},  // [½] (171)
    {0xc3, 0xc6, 0xcc, 0xdb, 0x37, 0x6f, 0xcf, 0x03},  // [¼] (172)
    {0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00},  // [¡] (173)
    {0x00, 0x33, 0x66, 0xcc, 0x66, 0x33, 0x00, 0x00},  // [«] (174)
    {0x00, 0xcc, 0x66, 0x33, 0x66, 0xcc, 0x00, 0x00},  // [»] (175)
    {0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88},  // [░] (176)
    {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa},  // [▒] (177)
    {0xdb, 0x77, 0xdb, 0xee, 0xdb, 0x77, 0xdb, 0xee},  // [▓] (178)
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},  // [│] (179)
    {0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18},  // [┤] (180)
    {0x18, 0x18, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18},  // [╡] (181)
    {0x36, 0x36, 0x36, 0x36, 0xf6, 0x36, 0x36, 0x36},  // [╢] (182)
    {0x00, 0x00, 0x00, 0x00, 0xfe, 0x36, 0x36, 0x36},  // [╖] (183)
    {0x00, 0x00, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18},  // [╕] (184)
    {0x36, 0x36, 0xf6, 0x06, 0xf6, 0x36, 0x36, 0x36},  // [╣] (185)
    {0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36},  // [║] (186)
    {0x00, 0x00, 0xfe, 0x06, 0xf6, 0x36, 0x36, 0x36},  // [╗] (187)
    {0x36, 0x36, 0xf6, 0x06, 0xfe, 0x00, 0x00, 0x00},  // [╝] (188)
    {0x36, 0x36, 0x36, 0x36, 0xfe, 0x00, 0x00, 0x00},  // [╜] (189)
    {0x18, 0x18, 0xf8, 0x18, 0xf8, 0x00, 0x00, 0x00},  // [╛] (190)
    {0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18},  // [┐] (191)
    {0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00},  // [└] (192)
    {0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00},  // [┴] (193)
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18},  // [┬] (194)
    {0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 0x18},  // [├] (195)
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00},  // [─] (196)
    {0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18},  // [┼] (197)
    {0x18, 0x18, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18},  // [╞] (198)
    {0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36},  // [╟] (199)
    {0x36, 0x36, 0x37, 0x30, 0x3f, 0x00, 0x00, 0x00},  // [╚] (200)
    {0x00, 0x00, 0x3f, 0x30, 0x37, 0x36, 0x36, 0x36},  // [╔] (201)
    {0x36, 0x36, 0xf7, 0x00, 0xff, 0x00, 0x00, 0x00},  // [╩] (202)
    {0x00, 0x00, 0xff, 0x00, 0xf7, 0x36, 0x36, 0x36},  // [╦] (203)
    {0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36},  // [╠] (204)
    {0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00},  // [═] (205)
    {0x36, 0x36, 0xf7, 0x00, 0xf7, 0x36, 0x36, 0x36},  // [╬] (206)
    {0x18, 0x18, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00},  // [╧] (207)
    {0x36, 0x36, 0x36, 0x36, 0xff, 0x00, 0x00, 0x00},  // [╨] (208)
    {0x00, 0x00, 0xff, 0x00, 0xff, 0x18, 0x18, 0x18},  // [╤] (209)
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x36, 0x36, 0x36},  // [╥] (210)
    {0x36, 0x36, 0x36, 0x36, 0x3f, 0x00, 0x00, 0x00},  // [╙] (211)
    {0x18, 0x18, 0x1f, 0x18, 0x1f, 0x00, 0x00, 0x00},  // [╘] (212)
    {0x00, 0x00, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18},  // [╒] (213)
    {0x00, 0x00, 0x00, 0x00, 0x3f, 0x36, 0x36, 0x36},  // [╓] (214)
    {0x36, 0x36, 0x36, 0x36, 0xff, 0x36, 0x36, 0x36},  // [╫] (215)
    {0x18, 0x18, 0xff, 0x18, 0xff, 0x18, 0x18, 0x18},  // [╪] (216)
    {0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00},  // [┘] (217)
    {0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18},  // [┌] (218)
    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},  // [█] (219)
    {0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff},  // [▄] (220)
    {0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0},  // [▌] (221)
    {0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f},  // [▐] (222)
    {0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},  // [▀] (223)
    {0x00, 0x00, 0x76, 0xdc, 0xc8, 0xdc, 0x76, 0x00},  // [α] (224)
    {0x00, 0x78, 0xcc, 0xf8, 0xcc, 0xf8, 0xc0, 0xc0},  // [ß] (225)
    {0x00, 0xfc, 0xcc, 0xc0, 0xc0, 0xc0, 0xc0, 0x00},  // [Γ] (226)
    {0x00, 0xfe, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00},  // [π] (227)
    {0xfc, 0xcc, 0x60, 0x30, 0x60, 0xcc, 0xfc, 0x00},  // [Σ] (228)
    {0x00, 0x00, 0x7e, 0xd8, 0xd8, 0xd8, 0x70, 0x00},  // [σ] (229)
    {0x00, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0xc0},  // [µ] (230)
    {0x00, 0x76, 0xdc, 0x18, 0x18, 0x18, 0x18, 0x00},  // [τ] (231)
    {0xfc, 0x30, 0x78, 0xcc, 0xcc, 0x78, 0x30, 0xfc},  // [Φ] (232)
    {0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0x6c, 0x38, 0x00},  // [Θ] (233)
    {0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x6c, 0xee, 0x00},  // [Ω] (234)
    {0x1c, 0x30, 0x18, 0x7c, 0xcc, 0xcc, 0x78, 0x00},  // [δ] (235)
    {0x00, 0x00, 0x7e, 0xdb, 0xdb, 0x7e, 0x00, 0x00},  // [∞] (236)
    {0x06, 0x0c, 0x7e, 0xdb, 0xdb, 0x7e, 0x60, 0xc0},  // [φ] (237)
    {0x38, 0x60, 0xc0, 0xf8, 0xc0, 0x60, 0x38, 0x00},  // [ε] (238)
    {0x78, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x00},  // [∩] (239)
    {0x00, 0xfc, 0x00, 0xfc, 0x00, 0xfc, 0x00, 0x00},  // [≡] (240)
    {0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0xfc, 0x00},  // [±] (241)
    {0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xfc, 0x00},  // [≥] (242)
    {0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xfc, 0x00},  // [≤] (243)
    {0x0e, 0x1b, 0x1b, 0x18, 0x18, 0x18, 0x18, 0x18},  // [⌠] (244)
    {0x18, 0x18, 0x18, 0x18, 0x18, 0xd8, 0xd8, 0x70},  // [⌡] (245)
    {0x30, 0x30, 0x00, 0xfc, 0x00, 0x30, 0x30, 0x00},  // [÷] (246)
    {0x00, 0x76, 0xdc, 0x00, 0x76, 0xdc, 0x00, 0x00},  // [≈] (247)
    {0x38, 0x6c, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00},  // [°] (248)
    {0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00},  // [∙] (249)
    {0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00},  // [·] (250)
    {0x0f, 0x0c, 0x0c, 0x0c, 0xec, 0x6c, 0x3c, 0x1c},  // [√] (251)
    {0x78, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00},  // [ⁿ] (252)
    {0x70, 0x18, 0x30, 0x60, 0x78, 0x00, 0x00, 0x00},  // [²] (253)
    {0x00, 0x00, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00},  // [■] (254)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // [ ] (255)
};


// ==============================================================================
// src/bios/fonts.c end
// ==============================================================================

// ==============================================================================
// src/bios/video.h start
// ==============================================================================

#line 1 "./src/bios/video.h"
#ifndef YAX86_BIOS_VIDEO_H
#define YAX86_BIOS_VIDEO_H

#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "public.h"

// Initialize the display in text mode.
extern void InitVideo(BIOSState* bios);

// Read a byte from video RAM.
extern uint8_t ReadVRAMByte(BIOSState* bios, uint32_t address);
// Write a byte to video RAM.
extern void WriteVRAMByte(BIOSState* bios, uint32_t address, uint8_t value);

// Table of video mode metadata, indexed by VideoMode enum values.
extern const VideoModeMetadata kVideoModeMetadataTable[kNumVideoModes];

#endif  // YAX86_IMPLEMENTATION

#endif  // YAX86_BIOS_VIDEO_H


// ==============================================================================
// src/bios/video.h end
// ==============================================================================

// ==============================================================================
// src/bios/video.c start
// ==============================================================================

#line 1 "./src/bios/video.c"
#ifndef YAX86_IMPLEMENTATION
#include "video.h"

#include "../util/common.h"
#include "fonts.h"
#include "public.h"
#endif  // YAX86_IMPLEMENTATION

const VideoModeMetadata kVideoModeMetadataTable[kNumVideoModes] = {
    // CGA text mode 0x00: Text, 40×25, grayscale, 320x200, 8x8
    {
        .mode = kVideoTextModeCGA00,
        .type = kVideoTextMode,
        .vram_address = 0xB8000,
        .vram_size = 16 * 1024,
        .width = 320,
        .height = 200,
        .columns = 40,
        .rows = 25,
        .char_width = kCGACharWidth,
        .char_height = kCGACharHeight,
    },
    // CGA text mode 0x01: Text, 40×25, 16 colors, 320x200, 8x8
    {
        .mode = kVideoTextModeCGA01,
        .type = kVideoTextMode,
        .vram_address = 0xB8000,
        .vram_size = 16 * 1024,
        .width = 320,
        .height = 200,
        .columns = 40,
        .rows = 25,
        .char_width = kCGACharWidth,
        .char_height = kCGACharHeight,
    },
    // CGA text mode 0x02: Text, 80×25, grayscale, 640x200, 8x8
    {
        .mode = kVideoTextModeCGA02,
        .type = kVideoTextMode,
        .vram_address = 0xB8000,
        .vram_size = 16 * 1024,
        .width = 640,
        .height = 200,
        .columns = 80,
        .rows = 25,
        .char_width = kCGACharWidth,
        .char_height = kCGACharHeight,
    },
    // CGA text mode 0x03: Text, 80×25, 16 colors, 640x200, 8x8
    {
        .mode = kVideoTextModeCGA03,
        .type = kVideoTextMode,
        .vram_address = 0xB8000,
        .vram_size = 16 * 1024,
        .width = 640,
        .height = 200,
        .columns = 80,
        .rows = 25,
        .char_width = kCGACharWidth,
        .char_height = kCGACharHeight,
    },
    // CGA graphics mode 0x04: Graphics, 4 colors, 320×200
    {
        .mode = kVideoGraphicsModeCGA04,
        .type = kVideoGraphicsMode,
        .vram_address = 0xB8000,
        .vram_size = 16 * 1024,
        .width = 320,
        .height = 200,
    },
    // CGA graphics mode 0x05: Graphics, grayscale, 320×200
    {
        .mode = kVideoGraphicsModeCGA05,
        .type = kVideoGraphicsMode,
        .vram_address = 0xB8000,
        .vram_size = 16 * 1024,
        .width = 320,
        .height = 200,
    },
    // CGA graphics mode 0x06: Graphics, monochrome, 640×200
    {
        .mode = kVideoGraphicsModeCGA06,
        .type = kVideoGraphicsMode,
        .vram_address = 0xB8000,
        .vram_size = 16 * 1024,
        .width = 640,
        .height = 200,
    },
    // MDA text mode 0x07: Text, 80×25, monochrome, 720x350, 9x14
    {
        .mode = kVideoTextModeMDA07,
        .type = kVideoTextMode,
        .vram_address = 0xB0000,
        .vram_size = 4 * 1024,
        .width = 720,
        .height = 350,
        .columns = 80,
        .rows = 25,
        .char_width = kMDACharWidth,
        .char_height = kMDACharHeight,
    },
};

enum {
  // Position of underline in MDA text mode.
  kMDAUnderlinePosition = 12,
};

// Check if video mode is valid and supported.
bool IsSupportedVideoMode(uint8_t mode) {
  if (mode >= kNumVideoModes) {
    return false;
  }
  return kVideoModeMetadataTable[mode].type != kVideoModeUnsupported;
}

// Get current video mode. Returns kInvalidVideoMode if the video mode in the
// BIOS Data Area (BDA) is invalid.
VideoMode GetCurrentVideoMode(struct BIOSState* bios) {
  uint8_t mode = ReadMemoryByte(bios, kBDAAddress + kBDAVideoMode);
  return IsSupportedVideoMode(mode) ? (VideoMode)mode : kInvalidVideoMode;
}

// Get current video mode metadata, or NULL if the video mode in the BIOS Data
// Area (BDA) is invalid.
const VideoModeMetadata* GetCurrentVideoModeMetadata(struct BIOSState* bios) {
  VideoMode mode = GetCurrentVideoMode(bios);
  return IsSupportedVideoMode(mode) ? &kVideoModeMetadataTable[mode] : NULL;
}

YAX86_PRIVATE uint8_t ReadVRAMByte(BIOSState* bios, uint32_t address) {
  const VideoModeMetadata* metadata = GetCurrentVideoModeMetadata(bios);
  if (!metadata || address >= metadata->vram_size) {
    return 0xFF;
  }
  return bios->config->read_vram_byte(bios, address);
}

YAX86_PRIVATE void WriteVRAMByte(
    BIOSState* bios, uint32_t address, uint8_t value) {
  const VideoModeMetadata* metadata = GetCurrentVideoModeMetadata(bios);
  if (!metadata || address >= metadata->vram_size) {
    return;
  }
  bios->config->write_vram_byte(bios, address, value);
}

// Switch video mode.
bool SwitchVideoMode(struct BIOSState* bios, VideoMode mode) {
  if (!IsSupportedVideoMode(mode)) {
    return false;
  }

  // Update the video mode in the BIOS Data Area (BDA).
  WriteMemoryByte(bios, kBDAAddress + kBDAVideoMode, (uint8_t)mode);
  // Update memory map.
  const VideoModeMetadata* metadata = &kVideoModeMetadataTable[mode];
  MemoryRegion vram_region = {
      .region_type = kMemoryRegionVideo,
      .start = metadata->vram_address,
      .size = metadata->vram_size,
      .read_memory_byte = ReadVRAMByte,
      .write_memory_byte = WriteVRAMByte,
  };
  MemoryRegion* existing_vram_region =
      GetMemoryRegionByType(bios, kMemoryRegionVideo);
  if (existing_vram_region) {
    *existing_vram_region = vram_region;
  } else {
    MemoryRegionsAppend(&bios->memory_regions, &vram_region);
  }

  if (metadata->type == kVideoTextMode) {
    // Update text mode metadata in the BDA.
    WriteMemoryByte(bios, kBDAAddress + kBDAVideoColumns, metadata->columns);
    WriteMemoryByte(bios, kBDAAddress + kBDAVideoRows, metadata->rows - 1);
    WriteMemoryByte(
        bios, kBDAAddress + kBDAVideoCharHeight, metadata->char_height);

    // Update page state.
    // One page is 2 bytes per character (char + attr).
    WriteMemoryWord(
        bios, kBDAAddress + kBDAVideoPageSize,
        metadata->columns * metadata->rows * 2);
    WriteMemoryByte(bios, kBDAAddress + kBDAVideoPageOffset, 0);
    WriteMemoryByte(bios, kBDAAddress + kBDAVideoCurrentPage, 0);

    // Update cursor state.
    // Default cursor type is two scan lines at bottom of the character cell.
    uint16_t default_cursor =
        (metadata->char_height - 2) << 8 | (metadata->char_height - 1);
    WriteMemoryWord(bios, kBDAAddress + kBDAVideoCursorType, default_cursor);
    // Set cursor position to (0, 0) for all pages.
    for (uint8_t i = 0; i < 8; ++i) {
      WriteMemoryWord(bios, kBDAAddress + kBDAVideoCursorPos + i * 2, 0);
    }

    // Clear screen.
    TextClearScreen(bios);
  }

  return true;
}

// Text mode - clear screen.
void TextClearScreen(struct BIOSState* bios) {
  const VideoModeMetadata* metadata = GetCurrentVideoModeMetadata(bios);
  if (!metadata || metadata->type != kVideoTextMode) {
    return;
  }
  for (uint32_t i = 0; i < metadata->vram_size; i += 2) {
    WriteVRAMByte(bios, i, ' ');
    // All text modes use 0x07 as the default attribute byte.
    WriteVRAMByte(bios, i + 1, 0x07);
  }
}

// Text mode - get current page.
uint8_t TextGetCurrentPage(struct BIOSState* bios) {
  const VideoModeMetadata* metadata = GetCurrentVideoModeMetadata(bios);
  if (!metadata || metadata->type != kVideoTextMode) {
    return 0;
  }
  return ReadMemoryByte(bios, kBDAAddress + kBDAVideoCurrentPage);
}

// Text mode - get cursor position on a page.
TextPosition TextGetCursorPositionForPage(
    struct BIOSState* bios, uint8_t page) {
  static const TextPosition kInvalidTextPosition = {
      .col = 0,
      .row = 0,
  };
  if (page >= 8) {
    return kInvalidTextPosition;
  }
  const VideoModeMetadata* metadata = GetCurrentVideoModeMetadata(bios);
  if (!metadata || metadata->type != kVideoTextMode) {
    return kInvalidTextPosition;
  }

  uint32_t cursor_address = kBDAAddress + kBDAVideoCursorPos + page * 2;
  TextPosition position = {
      .col = ReadMemoryByte(bios, cursor_address),
      .row = ReadMemoryByte(bios, cursor_address + 1),
  };
  return position;
}

// Text mode - get cursor position in current page.
TextPosition TextGetCursorPosition(struct BIOSState* bios) {
  return TextGetCursorPositionForPage(bios, TextGetCurrentPage(bios));
}

YAX86_PRIVATE void InitVideo(BIOSState* bios) {
  // Set initial video mode in BDA equipment list word, bits 4-5.
  //   00b - EGA, VGA, or other (use other BIOS data area locations)
  //   01b - 40×25 color (CGA)
  //   10b - 80×25 color (CGA)
  //   11b - 80×25 monochrome (MDA)
  uint16_t equipment_word =
      ReadMemoryWord(bios, kBDAAddress + kBDAEquipmentWord);
  equipment_word |= (0x03 << 4);  // MDA
  WriteMemoryWord(bios, kBDAAddress + kBDAEquipmentWord, equipment_word);

  SwitchVideoMode(bios, kVideoTextModeMDA07);
}

// Write a character to display in MDA text mode. For the attribute byte, we
// follow the description in the book Programmer's Reference Manual for IBM
// Personal Computers.
//
// Attribute byte structure:
//   - Bit 7: blink (0 = normal, 1 = blink)
//   - Bits 6-4: background
//   - Bit 3: intense foreground (0 = normal, 1 = intense)
//   - Bits 2-0: foreground
//
// Valid MDA character background and foreground attribute combinations:
//   - Normal: background = 000, foreground = 111
//   - Inverse video: background = 111, foreground = 000
//   - Invisible: background = 000, foreground = 000
//   - Underline: background = 000, foreground = 001
//
// Other combinations are undefined, but we will treat them as normal.
// TODO: Support blinking.
YAX86_PRIVATE void WriteCharMDA(
    BIOSState* bios, const VideoModeMetadata* metadata, uint8_t page,
    TextPosition char_pos) {
  if (char_pos.col >= metadata->columns || char_pos.row >= metadata->rows) {
    return;
  }

  uint32_t char_address = (page * metadata->rows * metadata->columns +
                           char_pos.row * metadata->columns + char_pos.col) *
                          2;
  uint8_t char_value = ReadVRAMByte(bios, char_address);
  uint8_t attr_value = ReadVRAMByte(bios, char_address + 1);
  const uint16_t* char_bitmap = kFontMDA9x14Bitmap[char_value];

  const RGB* foreground;
  const RGB* background;
  bool underline = false;

  bool intense = ((attr_value >> 3) & 0x01) != 0;
  uint8_t background_attr = (attr_value >> 4) & 0x07;
  uint8_t foreground_attr = attr_value & 0x07;
  if (background_attr == 0x00 && foreground_attr == 0x07) {
    // Normal video mode.
    foreground = intense ? &bios->config->mda_config.intense_foreground
                         : &bios->config->mda_config.foreground;
    background = &bios->config->mda_config.background;
  } else if (background_attr == 0x07 && foreground_attr == 0x00) {
    // Inverse video mode.
    foreground = &bios->config->mda_config.background;
    background = &bios->config->mda_config.foreground;
  } else if (background_attr == 0x00 && foreground_attr == 0x00) {
    // Invisible mode.
    foreground = &bios->config->mda_config.background;
    background = &bios->config->mda_config.background;
  } else if (background_attr == 0x00 && foreground_attr == 0x01) {
    // Underline mode.
    underline = true;
    foreground = &bios->config->mda_config.foreground;
    background = &bios->config->mda_config.background;
  } else {
    // Other combinations are treated as normal.
    foreground = intense ? &bios->config->mda_config.intense_foreground
                         : &bios->config->mda_config.foreground;
    background = &bios->config->mda_config.background;
  }

  Position origin_pixel_pos = {
      .x = char_pos.col * metadata->char_width,
      .y = char_pos.row * metadata->char_height,
  };
  for (uint8_t y = 0; y < metadata->char_height; ++y) {
    uint16_t row_bitmap;
    // If underline, set entire underline row to foreground color.
    if (y == kMDAUnderlinePosition && underline) {
      row_bitmap = 0xFFFF;
    } else {
      row_bitmap = char_bitmap[y];
    }
    for (uint8_t x = 0; x < metadata->char_width; ++x) {
      Position pixel_pos = {
          .x = origin_pixel_pos.x + x,
          .y = origin_pixel_pos.y + y,
      };
      bool is_foreground =
          (row_bitmap & (1 << (metadata->char_width - 1 - x))) != 0;
      const RGB* pixel_rgb = is_foreground ? foreground : background;
      bios->config->write_pixel(bios, pixel_pos, *pixel_rgb);
    }
  }
}

// Handler to write a character to the display in text mode.
typedef void (*WriteCharHandler)(
    struct BIOSState* bios, const VideoModeMetadata* metadata, uint8_t page,
    TextPosition char_pos);
// Table of handlers for writing characters in different text modes, indexed by
// VideoMode enum values.
const WriteCharHandler kWriteCharHandlers[] = {
    // CGA text mode 0x00: 40×25, grayscale, 320x200, 8x8
    0,
    // CGA text mode 0x01: 40×25, 16 colors, 320x200, 8x8
    0,
    // CGA text mode 0x02: 80×25, grayscale, 640x200, 8x8
    0,
    // CGA text mode 0x03: 80×25, 16 colors, 640x200, 8x8
    0,
    // CGA graphics mode 0x04: 4 colors, 320×200
    0,
    // CGA graphics mode 0x05: grayscale, 320×200
    0,
    // CGA graphics mode 0x06: monochrome, 640×200
    0,
    // MDA text mode 0x07: 80×25, monochrome, 720x350, 9x14
    WriteCharMDA,
};

// Render the current page in the emulated video RAM to the real display.
// Invokes the write_pixel callback to do the actual pixel rendering.
bool RenderCurrentVideoPage(struct BIOSState* bios) {
  const VideoModeMetadata* metadata = GetCurrentVideoModeMetadata(bios);
  if (!metadata) {
    return false;
  }
  switch (metadata->type) {
    case kVideoTextMode: {
      WriteCharHandler handler = kWriteCharHandlers[metadata->mode];
      if (!handler) {
        return false;
      }
      uint8_t page = TextGetCurrentPage(bios);
      for (uint8_t row = 0; row < metadata->rows; ++row) {
        for (uint8_t col = 0; col < metadata->columns; ++col) {
          TextPosition char_pos = {.col = col, .row = row};
          handler(bios, metadata, page, char_pos);
        }
      }
      return true;
    }
    case kVideoGraphicsMode: {
      return false;
    }
    default:
      return false;
  }
}


// ==============================================================================
// src/bios/video.c end
// ==============================================================================

// ==============================================================================
// src/bios/interrupts.h start
// ==============================================================================

#line 1 "./src/bios/interrupts.h"
#ifndef YAX86_BIOS_INTERRUPTS_H
#define YAX86_BIOS_INTERRUPTS_H

#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "public.h"

// Signature of a BIOS interrupt handler, i.e. a function that handles
// an interrupt number.
typedef ExecuteStatus (*BIOSInterruptHandler)(
    BIOSState* bios, CPUState* cpu, uint8_t ah);

// BIOS interrupt 0x05 - Print screen
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt05PrintScreen(BIOSState* bios, CPUState* cpu, uint8_t ah);
// BIOS interrupt 0x10 - Video I/O
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10VideoIO(BIOSState* bios, CPUState* cpu, uint8_t ah);
// BIOS interrupt 0x11 - Equipment determination
YAX86_PRIVATE ExecuteStatus HandleBIOSInterrupt11EquipmentDetermination(
    BIOSState* bios, CPUState* cpu, uint8_t ah);
// BIOS interrupt 0x12 - Memory size determination
YAX86_PRIVATE ExecuteStatus HandleBIOSInterrupt12MemorySizeDetermination(
    BIOSState* bios, CPUState* cpu, uint8_t ah);
// BIOS interrupt 0x13 - Disk I/O
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13DiskIO(BIOSState* bios, CPUState* cpu, uint8_t ah);
// BIOS interrupt 0x14 - RS-232 Serial I/O
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt14SerialIO(BIOSState* bios, CPUState* cpu, uint8_t ah);
// BIOS interrupt 0x15 - Cassette Tape I/O
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt15CassetteTapeIO(BIOSState* bios, CPUState* cpu, uint8_t ah);
// BIOS interrupt 0x16 - Keyboard I/O
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt16KeyboardIO(BIOSState* bios, CPUState* cpu, uint8_t ah);
// BIOS interrupt 0x17 - Printer I/O
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt17PrinterIO(BIOSState* bios, CPUState* cpu, uint8_t ah);
// BIOS interrupt 0x18 - ROM BASIC
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt18ROMBASIC(BIOSState* bios, CPUState* cpu, uint8_t ah);
// BIOS interrupt 0x19 - Bootstrap Loader (reboot the system)
YAX86_PRIVATE ExecuteStatus HandleBIOSInterrupt19BootstrapLoader(
    BIOSState* bios, CPUState* cpu, uint8_t ah);
// BIOS interrupt 0x1A - Time-of-Day
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt1ATimeOfDay(BIOSState* bios, CPUState* cpu, uint8_t ah);

// Signature of a BIOS interrupt function handler, i.e. a function that handles
// a specific interrupt number and AH register value.
typedef ExecuteStatus (*BIOSInterruptFunctionHandler)(
    BIOSState* bios, CPUState* cpu);

enum {
  // Number of BIOS functions for interrupt 0x10.
  kNumBIOSInterrupt10Functions = 0x14,
  // Number of BIOS functions for interrupt 0x13.
  kNumBIOSInterrupt13Functions = 0x18,
  // Number of BIOS functions for interrupt 0x14.
  kNumBIOSInterrupt14Functions = 0x04,
  // Number of BIOS functions for interrupt 0x15.
  kNumBIOSInterrupt15Functions = 0x04,
  // Number of BIOS functions for interrupt 0x16.
  kNumBIOSInterrupt16Functions = 0x03,
  // Number of BIOS functions for interrupt 0x17.
  kNumBIOSInterrupt17Functions = 0x03,
  // Number of BIOS functions for interrupt 0x1A.
  kNumBIOSInterrupt1AFunctions = 0x08,
};

// No-op BIOS interrupt function handler.
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterruptNoOp(BIOSState* bios, CPUState* cpu);

// BIOS Interrupt 0x10, AH = 0x00 - Set video mode
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH00SetVideoMode(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x01 - Set cursor shape
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH01SetCursorShape(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x02 - Set cursor position
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH02SetCursorPosition(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x03 - Read cursor position
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH03ReadCursorPosition(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x04 - Read light pen position
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH04ReadLightPenPosition(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x05 - Set active display page
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH05SetActiveDisplayPage(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x06 - Scroll active page up
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH06ScrollActivePageUp(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x07 - Scroll active page down
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH07ScrollActivePageDown(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x08 - Read character and attribute
YAX86_PRIVATE ExecuteStatus HandleBIOSInterrupt10AH08ReadCharacterAndAttribute(
    BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x09 - Write character and attribute
YAX86_PRIVATE ExecuteStatus HandleBIOSInterrupt10AH09WriteCharacterAndAttribute(
    BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x0A - Write character
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH0AWriteCharacter(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x0B - Set color palette
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH0BSetColorPalette(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x0C - Write dot
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH0CWriteDot(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x0D - Read dot
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH0DReadDot(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x0E - Write character as teletype
YAX86_PRIVATE ExecuteStatus HandleBIOSInterrupt10AH0EWriteCharacterAsTeletype(
    BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x0F - Get current video mode
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH0FGetCurrentVideoMode(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x10, AH = 0x13 - Write string
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt10AH13WriteString(BIOSState* bios, CPUState* cpu);

// BIOS Interrupt 0x13, AH = 0x00 - Reset disk
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH00ResetDisk(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x01 - Get disk status
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH01GetDiskStatus(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x02 - Read disk sectors
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH02ReadDiskSectors(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x03 - Write disk sectors
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH03WriteDiskSectors(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x04 - Verify disk sectors
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH04VerifyDiskSectors(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x05 - Format track
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH05FormatTrack(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x08 - Get current drive parameters
YAX86_PRIVATE ExecuteStatus HandleBIOSInterrupt13AH08GetCurrentDriveParameters(
    BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x09 - Initialize drive pair characteristics
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH09InitializeDrivePairCharacteristics(
    BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x0A - Read long
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH0AReadLong(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x0B - Write long
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH0BWriteLong(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x0C - Seek
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH0CSeek(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x0D - Reset hard disk
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH0DResetHardDisk(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x10 - Test for drive ready
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH10TestForDriveReady(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x11 - Recalibrate drive
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH11RecalibrateDrive(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x14 - Controller internal diagnostic
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH14ControllerInternalDiagnostic(
    BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x15 - Get disk type
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH15GetDiskType(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x16 - Disk change status
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH16DiskChangeStatus(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x13, AH = 0x17 - Set disk type
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt13AH17SetDiskType(BIOSState* bios, CPUState* cpu);

// BIOS Interrupt 0x14, AH = 0x00 - Initialize serial port
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt14AH00InitializeSerialPort(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x14, AH = 0x01 - Send one character
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt14AH01SendOneCharacter(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x14, AH = 0x02 - Receive one character
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt05AH02ReceiveOneCharacter(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x14, AH = 0x03 - Get serial port status
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt14AH03GetSerialPortStatus(BIOSState* bios, CPUState* cpu);

// BIOS Interrupt 0x15, AH = 0x00 - Turn on cassette motor
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt15AH00TurnOnCassetteMotor(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x15, AH = 0x01 - Turn off cassette motor
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt15AH01TurnOffCassetteMotor(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x15, AH = 0x02 - Read blocks of data
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt15AH02ReadCassetteDataBlocks(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x15, AH = 0x03 - Write blocks of data
YAX86_PRIVATE ExecuteStatus HandleBIOSInterrupt15AH03WriteCassetteDataBlocks(
    BIOSState* bios, CPUState* cpu);

// BIOS Interrupt 0x16, AH = 0x00 - Read next keyboard character
YAX86_PRIVATE ExecuteStatus HandleBIOSInterrupt16AH00ReadNextKeyboardCharacter(
    BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x16, AH = 0x01 - Determine whether character is available
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt16AH01DetermineCharacterAvailable(
    BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x16, AH = 0x02 - Get current shift status
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt16AH02GetCurrentShiftStatus(BIOSState* bios, CPUState* cpu);

// BIOS Interrupt 0x17, AH = 0x00 - Print character
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt17AH00PrintCharacter(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x17, AH = 0x01 - Initialize printer port
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt17AH01InitializePrinterPort(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x17, AH = 0x02 - Get printer status
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt17AH02GetPrinterStatus(BIOSState* bios, CPUState* cpu);

// BIOS Interrupt 0x1A, AH = 0x00 - Read the current clock value
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt1AAH00ReadCurrentClockValue(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x1A, AH = 0x01 - Set the current clock value
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt05AH01SetCurrentClockValue(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x1A, AH = 0x02 - Read the time from the battery-powered clock
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt1AAH02ReadRealTimeClockTime(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x1A, AH = 0x03 - Set the time on the battery-powered clock
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt1AAH03SetRealTimeClockTime(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x1A, AH = 0x04 - Read the date from the battery-powered clock
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt1AAH04ReadRealTimeClockDate(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x1A, AH = 0x05 - Set the date on the battery-powered clock
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt1AAH05SetRealTimeClockDate(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x1A, AH = 0x06 - Set the alarm
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt1AAH06SetAlarm(BIOSState* bios, CPUState* cpu);
// BIOS Interrupt 0x1A, AH = 0x07 - Reset the alarm
YAX86_PRIVATE ExecuteStatus
HandleBIOSInterrupt1AAH07ResetAlarm(BIOSState* bios, CPUState* cpu);

// Function handlers for BIOS interrupt 0x10.
YAX86_PRIVATE BIOSInterruptFunctionHandler
    bios_interrupt_10_handlers[kNumBIOSInterrupt10Functions];
// Function handlers for BIOS interrupt 0x13.
YAX86_PRIVATE BIOSInterruptFunctionHandler
    bios_interrupt_13_handlers[kNumBIOSInterrupt13Functions];
// Function handlers for BIOS interrupt 0x14.
YAX86_PRIVATE BIOSInterruptFunctionHandler
    bios_interrupt_14_handlers[kNumBIOSInterrupt14Functions];
// Function handlers for BIOS interrupt 0x15.
YAX86_PRIVATE BIOSInterruptFunctionHandler
    bios_interrupt_15_handlers[kNumBIOSInterrupt15Functions];
// Function handlers for BIOS interrupt 0x16.
YAX86_PRIVATE BIOSInterruptFunctionHandler
    bios_interrupt_16_handlers[kNumBIOSInterrupt16Functions];
// Function handlers for BIOS interrupt 0x17.
YAX86_PRIVATE BIOSInterruptFunctionHandler
    bios_interrupt_17_handlers[kNumBIOSInterrupt17Functions];
// Function handlers for BIOS interrupt 0x1A.
YAX86_PRIVATE BIOSInterruptFunctionHandler
    bios_interrupt_1A_handlers[kNumBIOSInterrupt1AFunctions];

#endif  // YAX86_IMPLEMENTATION

#endif  // YAX86_CPU_INSTRUCTIONS_H


// ==============================================================================
// src/bios/interrupts.h end
// ==============================================================================

// ==============================================================================
// src/bios/bios.c start
// ==============================================================================

#line 1 "./src/bios/bios.c"
#ifndef YAX86_IMPLEMENTATION
#include "../util/common.h"
#include "public.h"
#include "video.h"
#endif  // YAX86_IMPLEMENTATION

void InitBIOS(BIOSState* bios, BIOSConfig* config) {
  // Zero out the BIOS state.
  BIOSState empty_bios = {0};
  *bios = empty_bios;

  bios->config = config;

  MemoryRegionsInit(&bios->memory_regions);
  MemoryRegion conventional_memory = {
      .region_type = kMemoryRegionConventional,
      .start = 0x0000,
      .size = config->memory_size_kb * (2 << 10),
      .read_memory_byte = config->read_memory_byte,
      .write_memory_byte = config->write_memory_byte,
  };
  MemoryRegionsAppend(&bios->memory_regions, &conventional_memory);

  InitVideo(bios);

  // TODO: Set BDA values.
}


// ==============================================================================
// src/bios/bios.c end
// ==============================================================================


#endif  // YAX86_IMPLEMENTATION

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  // YAX86_BIOS_BUNDLE_H

